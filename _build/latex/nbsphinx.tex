%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


% Jupyter Notebook code cell colors
\definecolor{nbsphinxin}{HTML}{307FC1}
\definecolor{nbsphinxout}{HTML}{BF5B3D}
\definecolor{nbsphinx-code-bg}{HTML}{F5F5F5}
\definecolor{nbsphinx-code-border}{HTML}{E0E0E0}
\definecolor{nbsphinx-stderr}{HTML}{FFDDDD}
% ANSI colors for output streams and traceback highlighting
\definecolor{ansi-black}{HTML}{3E424D}
\definecolor{ansi-black-intense}{HTML}{282C36}
\definecolor{ansi-red}{HTML}{E75C58}
\definecolor{ansi-red-intense}{HTML}{B22B31}
\definecolor{ansi-green}{HTML}{00A250}
\definecolor{ansi-green-intense}{HTML}{007427}
\definecolor{ansi-yellow}{HTML}{DDB62B}
\definecolor{ansi-yellow-intense}{HTML}{B27D12}
\definecolor{ansi-blue}{HTML}{208FFB}
\definecolor{ansi-blue-intense}{HTML}{0065CA}
\definecolor{ansi-magenta}{HTML}{D160C4}
\definecolor{ansi-magenta-intense}{HTML}{A03196}
\definecolor{ansi-cyan}{HTML}{60C6C8}
\definecolor{ansi-cyan-intense}{HTML}{258F8F}
\definecolor{ansi-white}{HTML}{C5C1B4}
\definecolor{ansi-white-intense}{HTML}{A1A6B2}
\definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
\definecolor{ansi-default-inverse-bg}{HTML}{000000}

% Define an environment for non-plain-text code cell outputs (e.g. images)
\makeatletter
\newenvironment{nbsphinxfancyoutput}{%
    % Avoid fatal error with framed.sty if graphics too long to fit on one page
    \let\sphinxincludegraphics\nbsphinxincludegraphics
    \nbsphinx@image@maxheight\textheight
    \advance\nbsphinx@image@maxheight -2\fboxsep   % default \fboxsep 3pt
    \advance\nbsphinx@image@maxheight -2\fboxrule  % default \fboxrule 0.4pt
    \advance\nbsphinx@image@maxheight -\baselineskip
\def\nbsphinxfcolorbox{\spx@fcolorbox{nbsphinx-code-border}{white}}%
\def\FrameCommand{\nbsphinxfcolorbox\nbsphinxfancyaddprompt\@empty}%
\def\FirstFrameCommand{\nbsphinxfcolorbox\nbsphinxfancyaddprompt\sphinxVerbatim@Continues}%
\def\MidFrameCommand{\nbsphinxfcolorbox\sphinxVerbatim@Continued\sphinxVerbatim@Continues}%
\def\LastFrameCommand{\nbsphinxfcolorbox\sphinxVerbatim@Continued\@empty}%
\MakeFramed{\advance\hsize-\width\@totalleftmargin\z@\linewidth\hsize\@setminipage}%
\lineskip=1ex\lineskiplimit=1ex\raggedright%
}{\par\unskip\@minipagefalse\endMakeFramed}
\makeatother
\newbox\nbsphinxpromptbox
\def\nbsphinxfancyaddprompt{\ifvoid\nbsphinxpromptbox\else
    \kern\fboxrule\kern\fboxsep
    \copy\nbsphinxpromptbox
    \kern-\ht\nbsphinxpromptbox\kern-\dp\nbsphinxpromptbox
    \kern-\fboxsep\kern-\fboxrule\nointerlineskip
    \fi}
\newlength\nbsphinxcodecellspacing
\setlength{\nbsphinxcodecellspacing}{0pt}

% Define support macros for attaching opening and closing lines to notebooks
\newsavebox\nbsphinxbox
\makeatletter
\newcommand{\nbsphinxstartnotebook}[1]{%
    \par
    % measure needed space
    \setbox\nbsphinxbox\vtop{{#1\par}}
    % reserve some space at bottom of page, else start new page
    \needspace{\dimexpr2.5\baselineskip+\ht\nbsphinxbox+\dp\nbsphinxbox}
    % mimick vertical spacing from \section command
      \addpenalty\@secpenalty
      \@tempskipa 3.5ex \@plus 1ex \@minus .2ex\relax
      \addvspace\@tempskipa
      {\Large\@tempskipa\baselineskip
             \advance\@tempskipa-\prevdepth
             \advance\@tempskipa-\ht\nbsphinxbox
             \ifdim\@tempskipa>\z@
               \vskip \@tempskipa
             \fi}
    \unvbox\nbsphinxbox
    % if notebook starts with a \section, prevent it from adding extra space
    \@nobreaktrue\everypar{\@nobreakfalse\everypar{}}%
    % compensate the parskip which will get inserted by next paragraph
    \nobreak\vskip-\parskip
    % do not break here
    \nobreak
}% end of \nbsphinxstartnotebook

\newcommand{\nbsphinxstopnotebook}[1]{%
    \par
    % measure needed space
    \setbox\nbsphinxbox\vbox{{#1\par}}
    \nobreak % it updates page totals
    \dimen@\pagegoal
    \advance\dimen@-\pagetotal \advance\dimen@-\pagedepth
    \advance\dimen@-\ht\nbsphinxbox \advance\dimen@-\dp\nbsphinxbox
    \ifdim\dimen@<\z@
      % little space left
      \unvbox\nbsphinxbox
      \kern-.8\baselineskip
      \nobreak\vskip\z@\@plus1fil
      \penalty100
      \vskip\z@\@plus-1fil
      \kern.8\baselineskip
    \else
      \unvbox\nbsphinxbox
    \fi
}% end of \nbsphinxstopnotebook

% Ensure height of an included graphics fits in nbsphinxfancyoutput frame
\newdimen\nbsphinx@image@maxheight % set in nbsphinxfancyoutput environment
\newcommand*{\nbsphinxincludegraphics}[2][]{%
    \gdef\spx@includegraphics@options{#1}%
    \setbox\spx@image@box\hbox{\includegraphics[#1,draft]{#2}}%
    \in@false
    \ifdim \wd\spx@image@box>\linewidth
      \g@addto@macro\spx@includegraphics@options{,width=\linewidth}%
      \in@true
    \fi
    % no rotation, no need to worry about depth
    \ifdim \ht\spx@image@box>\nbsphinx@image@maxheight
      \g@addto@macro\spx@includegraphics@options{,height=\nbsphinx@image@maxheight}%
      \in@true
    \fi
    \ifin@
      \g@addto@macro\spx@includegraphics@options{,keepaspectratio}%
    \fi
    \setbox\spx@image@box\box\voidb@x % clear memory
    \expandafter\includegraphics\expandafter[\spx@includegraphics@options]{#2}%
}% end of "\MakeFrame"-safe variant of \sphinxincludegraphics
\makeatother

\makeatletter
\renewcommand*\sphinx@verbatim@nolig@list{\do\'\do\`}
\begingroup
\catcode`'=\active
\let\nbsphinx@noligs\@noligs
\g@addto@macro\nbsphinx@noligs{\let'\PYGZsq}
\endgroup
\makeatother
\renewcommand*\sphinxbreaksbeforeactivelist{\do\<\do\"\do\'}
\renewcommand*\sphinxbreaksafteractivelist{\do\.\do\,\do\:\do\;\do\?\do\!\do\/\do\>\do\-}
\makeatletter
\fvset{codes*=\sphinxbreaksattexescapedchars\do\^\^\let\@noligs\nbsphinx@noligs}
\makeatother



\title{TM129 Robotics Practical Activities}
\date{Dec 18, 2020}
\release{}
\author{Tony Hirst}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


A website version of the Open University TM129 Robotics practical activities generated
from the original Jupyter notebook style materials.

Note that these materials \sphinxstyleemphasis{do not} support interactive use that are associated with the course.


\chapter{Contents:}
\label{\detokenize{index:contents}}

\section{NOTES FOR TUTORS}
\label{\detokenize{index:notes-for-tutors}}

\subsection{Getting Started}
\label{\detokenize{content/00_NOTES_FOR_TUTORS/GETTING_STARTED:Getting-Started}}\label{\detokenize{content/00_NOTES_FOR_TUTORS/GETTING_STARTED::doc}}
Welcome to the TM129 Robotics block practical activities.

The practical activities are delivered through a new environment, \sphinxstyleemphasis{RoboLab}, that replaces the \sphinxstyleemphasis{RobotLab} application used in presentations priort to 20J. \sphinxstyleemphasis{RoboLab} is an example of an \sphinxcode{\sphinxupquote{Open Computing Lab (OCL)}} environment configured specifically to support the TM129 Robotics activities.

The \sphinxcode{\sphinxupquote{Open Computing Lab}} approach is being trialled on several Open University modules and aims to provide a common approach to delivering complex software and computing envronments on personal computers as well as via remotely hosted online servers.

To install the environment, use the installation instructions that are provided for students.


\subsubsection{The Jupyter Notebook Environment}
\label{\detokenize{content/00_NOTES_FOR_TUTORS/GETTING_STARTED:The-Jupyter-Notebook-Environment}}
The teaching and learning materials used to support the activities are provided as Jupyter notebooks.

Jupyter notebooks have been used deliver practical activities in \sphinxstyleemphasis{TM351 Data Management and Analysis}, the OU produced FutureLearn/OpenLearn unit \sphinxstyleemphasis{Learn to Code for Data Analysis}, materials which are also used in \sphinxstyleemphasis{S818 Space Science}, and to support a brief, optional set of activities in TM112.

They will also be used in several courses currently in production including \sphinxstyleemphasis{M269 Algorithms}, \sphinxstyleemphasis{TM358 Machine Learning} and \sphinxstyleemphasis{M348 Linear Models}.

Originally developed to support computational research activities, Jupyter notebooks provide a cell based web\sphinxhyphen{}based read\sphinxhyphen{}write\sphinxhyphen{}execute document editor that blends rich text, executable code and code outputs.

Within text areas, code can by highlighted in a language sensitive way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sayHello}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello World}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Code is executed in a “kernel” shell environment running on a backend server.

Kernels for a \sphinxhref{https://github.com/jupyter/jupyter/wiki/Jupyter-kernels}{wide variety of programming languages} are available; in TM129, we will be using a full Python kernel, as well as a simple in\sphinxhyphen{}browser Skulpt Python environment that runs code inside a simple in\sphinxhyphen{}browser 2D robot simulator.

When a code cell is run, outputs can be printed or displayed, and any value returned by the last object in the cell object will be displayed as cell output.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}def sayHello():
    print(\PYGZsq{}Hello World\PYGZsq{})
    return \PYGZdq{}done...\PYGZdq{}

sayHello()
\end{sphinxVerbatim}
}


\subsubsection{Using Notebooks to Support Learning}
\label{\detokenize{content/00_NOTES_FOR_TUTORS/GETTING_STARTED:Using-Notebooks-to-Support-Learning}}
The read\sphinxhyphen{}write\sphinxhyphen{}execute nature of Jupyter notebooks provides us with a medium that can be used to develop a wide range of active learning materials. Students are encouraged to take ownership of the notebooks, use them as guided materials, as well as in a curiosity driven, exploratory way, and annotate them as they would print materials.

For example, students can:
\begin{itemize}
\item {} 
run simple interactive applications in the notebook;

\end{itemize}
\begin{itemize}
\item {} 
run provided code examples and inspect code outputs;

\end{itemize}
\begin{itemize}
\item {} 
edit and run their own code and produce their own code outputs;

\end{itemize}
\begin{itemize}
\item {} 
edit the course text, from fixing minor typos as they work through the materials, to annotating the materials with their own comments and clarifications;

\end{itemize}
\begin{itemize}
\item {} 
add predictions about what they expect a code fragment to do when it is executed, record their observations when it does, and reflect on how well their predictions matched their observations, and what they learned as a result.

\end{itemize}


\subsubsection{Using Notebooks to Support Direct Teaching / Tutorials}
\label{\detokenize{content/00_NOTES_FOR_TUTORS/GETTING_STARTED:Using-Notebooks-to-Support-Direct-Teaching-/-Tutorials}}
The Jupyter notebook environment we have provided includes a slideshow extension, \sphinxhref{https://rise.readthedocs.io/en/stable/}{RISE}, that allows you to turn individual Jupyter notebooks into interactive slideshow presentations.

As with the notebooks themselves, each slide includes editable text and code cells, can display interactive applications, and can be used to execute code fragments and displaying the resulting code output (including error messages…).

Notebooks are configured as slides through the addition of cell tags that control whether, and how, each cell in the notebook is to be treated in presentation mode.

Several of the notebooks, including this one, have been marked up as presentations. To run the slideshow, click once on the top cell in the notebook to select it as the starting point from the presentation, then click on the \sphinxstyleemphasis{Enter/Exit RISE Slideshow} icon (it looks like a bar chart) on the notebook toolbar.

Slides themselves are interactive in other ways.

For example, this notebook supports the presentation \sphinxhref{https://rise.readthedocs.io/en/stable/customize.html\#enable-chalkboard-capabilities}{chalkboard} which allows you to draw on the slide directly.

(Click the pens in the bottom left corner of the slide to toggle the chalkboard mode.)


\subsubsection{What Next?}
\label{\detokenize{content/00_NOTES_FOR_TUTORS/GETTING_STARTED:What-Next?}}
If you are not familiar with Jupyter notebooks, please spend some time familiarising yourself with them.

We believe they provide a powerful tool to support teaching and learning and it’s still early days for us in finding out how to make most effective use of them.

If you have any ideas anout how we can imporve our current use of the notebooks, or make more effective use of them, please let us know.


\section{READ ME FIRST}
\label{\detokenize{index:read-me-first}}

\subsection{Developer Notes}
\label{\detokenize{content/00_READ_ME_FIRST/Section:Developer-Notes}}\label{\detokenize{content/00_READ_ME_FIRST/Section::doc}}
Key things to be aware of when developing on this project.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{ev3devsim}} Hacking}
\label{\detokenize{content/00_READ_ME_FIRST/Section:ev3devsim-Hacking}}
The \sphinxcode{\sphinxupquote{ev3devsim}} code runs under skulpt. To develop on the following packages:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ev3dev2/*}} packages;

\item {} 
\sphinxcode{\sphinxupquote{ev3dev2\_glue.js}}

\end{itemize}

the packages new to be built into the Skulpt distribution used by \sphinxcode{\sphinxupquote{nbev3devsim}}. When updating those files, you need to:
\begin{itemize}
\item {} 
copy the updated files into a Skulpt repo \sphinxcode{\sphinxupquote{src/lib/}} directory;

\item {} 
in the Skulpt repo root directory, run \sphinxcode{\sphinxupquote{npm run dist}};

\item {} 
grab the \sphinxcode{\sphinxupquote{skulpt\sphinxhyphen{}stdlib.js}}, \sphinxcode{\sphinxupquote{skulpt.min.js}} and \sphinxcode{\sphinxupquote{skulpt.min.js.map}} files and copy them into \sphinxcode{\sphinxupquote{nbev3devsim/js/}}.

\end{itemize}


\subsection{Introduction}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_01_Introduction:Introduction}}\label{\detokenize{content/00_READ_ME_FIRST/Section_00_01_Introduction::doc}}
Welcome to the practical activities associated with Block 1 of TM129.

The aim of these practical sessions is to introduce you to some of the ways in which we can programme a simple simulated robot running inside a two\sphinxhyphen{}dimensional world simulator in your web browser. You will also have the opportunity to try out some simple artificial intelligence and machine learning programmes.

The main environment provided for working through the activities is a customised Jupyter notebook environment. Jupyter notebooks were originally designed to support reproducible computational data analysis and research. They are now commonly used across a wide range of disciplines, and are increasingly used to support interactive code\sphinxhyphen{}based tutorials as well as distributing teaching materials.

The programming language you will be using in this block is the Python programming language. If you have not used the Python programming language before, or even if you haven’t done \sphinxstyleemphasis{any} programming before, \sphinxstyleemphasis{DON’T PANIC}. We have tried to take a pragmatic approach to demonstrating how use to Python code to \sphinxstyleemphasis{get things done}, and the provided examples show you all you need to know to programme the simulated robot yourself.

Although the interface to the programming activities is provided through a web browser (most reliably, the Chrome web\sphinxhyphen{}browser), the software supporting the activities run inside a virtual machine (you’ll learn more about virtual machines later in the module).

To run the virtual machine locally, you will need to install the Docker application (we’ll provide full guidance around this). It is also possible to run the application using free or paid for services on the web, and we provide some guidance on how to do this. However, you should be aware that free services may not always be available or reliable, and some are “free” only in exchange for someone else, such as personal registration data.


\subsection{1.2 Workload}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_02_Workload:1.2-Workload}}\label{\detokenize{content/00_READ_ME_FIRST/Section_00_02_Workload::doc}}
The RoboLab practical sessions have been written so that if you are an absolute beginner with no experience of robotics or programming you can complete the work each week in four to five hours. The pace is deliberately unhurried and we recommend you take your time. If you already have some programming experience RoboLab should take you less time.

Each week’s practical session combines two aspects of robotics. We will teach you the basics of programming in RoboLab, introducing features gradually during the sessions. You will also carry out some investigations using the simulated robot which will give you a taste of some of the more practical aspects of robotics.

Throughout the RoboLab sessions you may encounter a number of activities that are labelled as ‘challenges’. We’ve defined these tasks as challenges because:
\begin{itemize}
\item {} 
there may be several ways of achieving a solution to the task, rather than a single best approach

\item {} 
it may be possible to refine any particular solution and improve its performance.

\end{itemize}

Challenges implicitly incorporate some performance measure that you can use to rate the effectiveness of your solution, such as the time taken for the robot to complete a task, or the accuracy with which it does so. There is thus a mildly competitive element to the activity. You may not get the chance to compare your solution with those of other students, but you can think about trying to improve the quality of your own solution \textendash{} though you should not spend too long trying for perfection!


\subsubsection{Assessment}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_02_Workload:Assessment}}
We hope that by the end of the RoboLab practical sessions you understand some of the basic ideas and can program the simulated robot to do some basic tasks. This should ensure that you can do the assignment and complete the block satisfactorily. The assessment will not include any material covered in optional practical activities.


\subsection{1.3 Accessibility}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_03_Accessibility:1.3-Accessibility}}\label{\detokenize{content/00_READ_ME_FIRST/Section_00_03_Accessibility::doc}}
We have tried our best to make RoboLab accessible to all students, whatever their particular needs.

\sphinxstylestrong{TO DO \sphinxhyphen{} I havenlt test accessibility toolbar in conjucntion with the simulator; they may or may not play well together…}

The Jupyter environment includes an \sphinxhref{https://github.com/uclixnjupyternbaccessibility/accessibility\_toolbar}{accessibility toolbar extension} that allows you to control the presentation style of the Jupyter notebook; for example, you can change the font style, size and spacing, the notebook background colour, and so on. Several predefined custom themes are available {[}BROKEN{]} and you can also define your own. The extension also supports voice control {[}BROKEN{]}.

\sphinxstylestrong{TO DO: there is also a}\sphinxhref{https://github.com/dunovank/jupyter-themes}{jupyter\sphinxhyphen{}themes}\sphinxstylestrong{extension that we could pre\sphinxhyphen{}install, perhaps with one or more OU custome themes? This may be in addtion to, or in place of, the accessibility toolbar. There are also simple tricks and tools for speaking out code cell contents, such as the}\sphinxhref{https://github.com/jameslmartin/jupyter-a11y}{jupyter\sphinxhyphen{}a11y}\sphinxstylestrong{extension.}

All of the styles are saved into local storage when refreshing the page. This means that if you use notebooks on different servers with the same browser, the same accessibility settings will be applied to notebooks on all servers within which you have enabled the accessibilty extension.


\subsubsection{Enabling the Accessibility Extension}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_03_Accessibility:Enabling-the-Accessibility-Extension}}
The accessibility is \sphinxstylestrong{disabled} in the RoboLab environment by default. To use the accessibility extension, you need to enable it first. You can do this from the \sphinxcode{\sphinxupquote{nbextensions}} tab on the notebook homepage: check the \sphinxcode{\sphinxupquote{Accessibility toolbar}} extension to enable the toolbar. When you open a new notebook, the toolbar should be displayed.

\noindent\sphinxincludegraphics[width=2344\sphinxpxdimen,height=1326\sphinxpxdimen]{{00_01_nb_extensions_accessibility}.png}

Check the \sphinxhref{https://github.com/uclixnjupyternbaccessibility/accessibility\_toolbar\#toolbar-summary}{accessibility toolbar documentation} for more information.

The Module Team welcome feedback on these features.


\subsubsection{Colours and fonts}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_03_Accessibility:Colours-and-fonts}}
If you wish to change the font and interface colours used in RoboLab to improve readability, the accessibility toolbar allows you to select the font style, size and colour. You can also modify the line spacing and spacing between individual characters.

\noindent\sphinxincludegraphics[width=1051\sphinxpxdimen,height=510\sphinxpxdimen]{{00_01_accessibility_display}.png}

The font style applies to \sphinxstyleemphasis{all} text elements within the notebook itself. This includes the contents of markdown (text) cells, code cells and code cell outputs.

The toolbar can also be used to control the notebook’s background colour and the cell background colour.

You can also save a style you have defined from the \sphinxcode{\sphinxupquote{Add new style...}} option in \sphinxcode{\sphinxupquote{Predefined styles}} menu. Once saved, it will be added to the menu list so you can apply it as required.


\subsubsection{Keyboard interface}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_03_Accessibility:Keyboard-interface}}
The Jupyter notebook interface supports a wide range of pre\sphinxhyphen{}defined keyboard shortcuts to menu and toolbar options. The shortcuts can be displayed using the \sphinxcode{\sphinxupquote{Keyboard shortcuts}} item from the notebook \sphinxcode{\sphinxupquote{Help}} menu or via the \sphinxcode{\sphinxupquote{ESC\sphinxhyphen{}h}} keyboard shortcut.

\noindent\sphinxincludegraphics[width=1370\sphinxpxdimen,height=1154\sphinxpxdimen]{{00_01_jupyter_nb_shortcuts}.png}

You can also add additional shortcuts and/or edit exist shortcuts via the \sphinxcode{\sphinxupquote{Edit Keyboard shortcuts}} menu item.

\noindent\sphinxincludegraphics[width=1358\sphinxpxdimen,height=1142\sphinxpxdimen]{{00_01_jupyter_nb_edit_shortcuts}.png}

\sphinxstylestrong{TO DO: is Jyro keyboard accessible??}

\sphinxstylestrong{TO DO: what’s best way of tabbing through the notebook? Or should notebook keyboard shortcuts be used? Are any potentially useufl navigation style keyboard shortcuts missing?}


\subsubsection{Magnification}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_03_Accessibility:Magnification}}
The apparent size of the notebook contents in general and the Jyro simulator in particular can be zoomed using standard browser magnification tools. \sphinxstylestrong{TO DO: check this works for Jyro}

Alternatively, use operating systems tools such as \sphinxstyleemphasis{Windows Magnify} or the MacOS \sphinxstyleemphasis{Zoom Window}, or other assistive software.


\subsubsection{Other assistive software}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_03_Accessibility:Other-assistive-software}}
\sphinxstylestrong{TO DO: to what extent will screen readers and dictation systems operate features of RoboLab??}

Please contact the Module Team if you discover that the material does not work with a particular screen reader or dictation system that you would typically expect to be able to use.


\subsubsection{Audio}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_03_Accessibility:Audio}}
Some RoboLab programs ‘speak’. Where the speech is generated as a part of a program flow, a visual display of the spoken phrase will also typically be displayed at the time the phrase is spoken.

\_\_TO DO: need to make sure we do this; a custom widget might help that maps to both audio and a text display widget.\_


\subsection{1.4 Writing Style Compliant Code}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_04_Writing_Code:1.4-Writing-Style-Compliant-Code}}\label{\detokenize{content/00_READ_ME_FIRST/Section_00_04_Writing_Code::doc}}
\sphinxstylestrong{NOTE TO CRITICAL READERS: THIS IS INTENDED AS GENERIC TO JUPYTER ENVTS AND AIMS TO NUDGE STUDENTS TOWARDS GOOD CODE STYLE PRACTICE IF THEY WANT NUDGING.}

Whilst this is not specifically a programming course, this may well be the first time you have done any sort of programming at all, let alone any programming in Python.

The style of programming we are teaching is geared towards helping you understand how we might be able to control robots through programme code, rather than formally teaching you programming in general, or Python coding in particular.

However, we will try to to demonstrate code examples that are well written and that comply with the popular \sphinxhref{https://www.python.org/dev/peps/pep-0008/}{PEP 8 — Style Guide for Python Code}. This guide sets out a set of stylistic convention for writing clear Python code.

There are many tools available that can be used to support code authors and we have installed some of them into the RoboLab environment.

One particular tool is know as a “linter”. When you run a code cell, this tool can post warnings about where the code diverges from PEP\sphinxhyphen{}8 guidelines.

Error codes are described via the following links:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{E*}}, \sphinxcode{\sphinxupquote{W*}}: \sphinxhref{https://pycodestyle.readthedocs.io/en/latest/intro.html\#error-codes}{show code lookups};

\item {} 
\sphinxcode{\sphinxupquote{D*}}: \sphinxhref{http://www.pydocstyle.org/en/2.1.1/error\_codes.html}{show code lookups};

\item {} 
\sphinxcode{\sphinxupquote{F*}}: \sphinxhref{http://flake8.pycqa.org/en/3.7.9/user/error-codes.html}{show code lookups}.

\end{itemize}

The linter can be enabled in a notebook by running the following magic:

\sphinxcode{\sphinxupquote{\%flake8\_on \sphinxhyphen{}\sphinxhyphen{}ignore D100}}

\sphinxstylestrong{TO DO: flake seems to be broken atm tho pycodestyle ok; also note probably only works with native code cells, not magic ones, though I may be able to fix that by tweaking magic to ignore the \textasciigrave{}\textasciigrave{}\%\%sim\_magic\textasciigrave{}\textasciigrave{} call…}

When you run a code cell, if the linter detects a difference from the style guide, it will display a warning of the form:

TO DO

??show line numbers ??fix ??rerun

Another useful extension that is installed, but not enabled, is the \sphinxcode{\sphinxupquote{Autopep8}} extension. You can enable the extension from the \sphinxcode{\sphinxupquote{nbextensions Configurator}} {[}\sphinxhref{/nbextensions/?nbextension=code\_prettify/autopep8}{direct link}{]}. Enabling this extension provides a “hammer” toolbar button that you can use to prettify your code in accord with some PEP\sphinxhyphen{}8 recommendations at least. Simply select a code select, and hit the button; it will prettify the code, if it can, in a more PEP\sphinxhyphen{}8 compliant way.
(But it won’t change the way your code executes, so it won’t tend to fix bugs in your code for you…)

One way of using the \sphinxcode{\sphinxupquote{flake8}} linter and \sphinxcode{\sphinxupquote{Autopep8}} button together is to let the linter raise a warning (if you do make an error), use the button to try to fix the code, then run the cell again to invoke the linter and see if the warning(s) were addressed. If they were, \sphinxstyleemphasis{inspect the fixed code to see what change the \textasciigrave{}\textasciigrave{}Autopep8\textasciigrave{}\textasciigrave{} tool made} (\sphinxcode{\sphinxupquote{CTRL\sphinxhyphen{}z}} (Win), \sphinxcode{\sphinxupquote{CMD\sphinxhyphen{}z}} (Mac) will undo the last cell edit; \sphinxcode{\sphinxupquote{SHIFT\sphinxhyphen{}CTRL\sphinxhyphen{}z}} (Win), \sphinxcode{\sphinxupquote{SHFT\sphinxhyphen{}CMD\sphinxhyphen{}z}} (Mac) will then redo it).

Tools are also available to support writing markdown text in markdoan cells. For example, enabling the \sphinxcode{\sphinxupquote{livemdpreview}} extension will display an inline live preview of the rendered markdown directly beneath a markdown cell as you edit it {[}\sphinxhref{/nbextensions/?nbextension=livemdpreview/livemdpreview}{direct link}{]}.

Spell checkers are also available, either as the \sphinxcode{\sphinxupquote{spellchecker}} notebook extension {[}\sphinxhref{https://hub.gke.mybinder.org/user/innovationoutsi-29-robotics2020-o5z3lwky/nbextensions/?nbextension=spellchecker/main}{direct link}) or via the Accessibility toolbar.


\subsection{1.5 Gaining Access to the RoboLab Environment}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:1.5-Gaining-Access-to-the-RoboLab-Environment}}\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab::doc}}
RoboLab is an example of an \sphinxcode{\sphinxupquote{Open Computing Lab (OCL)}} environment configured specifically to support your TM129 activities.

The \sphinxcode{\sphinxupquote{Open Computing Lab}} approach is being trialled on several Open University modules and aims to provide a common approach to delivering complex software and computing envronments on personal computers as well as via remotely hosted online servers.

There are several ways in which you can access the RoboLab OCL environment:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{as a “temporary” online service using MyBinder}

\item {} 
\sphinxstyleemphasis{via the OU hosted JupyterHub environment WHICH DOESN’T EXIST YET}

\item {} 
\sphinxstyleemphasis{locally on your own computer}

\end{itemize}

The current recommended approach is \sphinxstylestrong{download Docker to your own computer and launch the environment from the command line}.


\subsubsection{Accessing RoboLab Online \sphinxhyphen{} MyBinder / BinderHub}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Accessing-RoboLab-Online---MyBinder-/-BinderHub}}
You can run the RoboLab environment online using the MyBinder service \sphinxhref{https://mybinder.org/v2/gh/innovationOUtside/tm129-robotics2020/master}{\sphinxincludegraphics{{/home/runner/work/tm129-robotics2020/tm129-robotics2020/_build/latex/.doctrees/images/564aeb29a2e0a759592d48f87044710bf7928b8a/badge_logo}.svg}}.

If you want to save any of the notebooks used there, you will have to download them as follows:
\begin{itemize}
\item {} 
as a single notebook from the notebook page \sphinxcode{\sphinxupquote{File}} menu;

\item {} 
as a zipped archive file of all notebooks using the the download button on the notebook homepage.

\end{itemize}

You can also upload your own notebooks from the notebook homepage either individually, or as a zip file. If you upload a zip file, you will need to unzip it. You can do this from a notebook command cell using the \sphinxcode{\sphinxupquote{unzip}} shell command or \sphinxhref{https://thispointer.com/python-how-to-unzip-a-file-extract-single-multiple-or-all-files-from-a-zip-archive/}{using Python code}. More details can be found in the \sphinxstylestrong{TO DO?? \sphinxhyphen{} see the \textasciigrave{}\textasciigrave{}RoboLab Environment FAQ\textasciigrave{}\textasciigrave{}}


\subsubsection{Running An Open Computing Lab Environment On Your Own Computer \sphinxhyphen{} Computer Requirements}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Running-An-Open-Computing-Lab-Environment-On-Your-Own-Computer---Computer-Requirements}}
To run an Open Computing Lab environment on your computer, we suggest you install the prebuilt OCL environment developed for your module. For TM129, this is the prebuilr RoboLab environment. Using this environment has the advantage that the module team knows exactly what’s inside it and how to help fix things if they appear to go wrong.

The downside is that the environment is quite large in terms of memory requirements: you will need at least 5GB of free memory to install it the environment, as well as its dependencies.

The underlying Docker application, which provides the virtualisation tools used to run the environment, is also happiest on computers with at least 4GB of RAM available.


\subsubsection{Downloading and Installing Your Open Computing Lab Environment}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Downloading-and-Installing-Your-Open-Computing-Lab-Environment}}
Open Computing Lab environments run in a simple virtual machine known as a Docker container.

To run an Open Computing Lab environment on your own computer, you will need to download and install the \sphinxstyleemphasis{Docker} application. Optionally, you may also choose the download the \sphinxstyleemphasis{ContainDS} application, which provides a graphical user interface for managing a Docker containers. If you do not download \sphinxstyleemphasis{ContainDS}, you can still control your Docker containers using command line commands issued from a terminal or command prompt.


\subsubsection{Download and Install Docker}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Download-and-Install-Docker}}
Docker is the virtualisation platform that runs the RoboLab environment. You should download and install the latest version of Docker from the \sphinxhref{https://www.docker.com/products/docker-desktop}{Docker website}, following the instructions for your particular operating system:
\begin{itemize}
\item {} 
\sphinxhref{https://docs.docker.com/docker-for-windows/install/}{Docker Desktop for Windows} (\sphinxhref{https://download.docker.com/win/stable/Docker\%20for\%20Windows\%20Installer.exe}{direct download link}): \sphinxstyleemphasis{requires Windows 10 64\sphinxhyphen{}bit: Pro, Enterprise, or Education}
\begin{itemize}
\item {} 
if your Windows machine does not meet the requirements for installing \sphinxstyleemphasis{Docker Desktop for Windows}, you should still be able to run Docker using the \sphinxhref{https://docs.docker.com/toolbox/toolbox\_install\_windows/}{Docker Toolbox on Windows}

\end{itemize}

\item {} 
\sphinxhref{https://docs.docker.com/docker-for-mac/install/}{Docker Desktop for Mac} (\sphinxhref{https://download.docker.com/mac/stable/Docker.dmg}{direct download link}): \sphinxstyleemphasis{requires macOS 10.12 or newer, hardware from 2010 or newer})
\begin{itemize}
\item {} 
for older Macs that do not meet the requirements for installing \sphinxstyleemphasis{Docker Desktop for Mac}, you may still be able to run Docker using the \sphinxhref{https://docs.docker.com/toolbox/toolbox\_install\_mac/}{Docker Toolbox on Mac OS}

\end{itemize}

\item {} 
\sphinxstyleemphasis{Linux}: you may find that Docker is already installed on your Linux computer (in a terminal, run the command \sphinxcode{\sphinxupquote{docker \sphinxhyphen{}\sphinxhyphen{}version}} to check). If it isn’t available, you should install the latest version of the \sphinxstyleemphasis{Docker Engne \sphinxhyphen{} Community Edition} from the Docker repository. Find your flavour of Linux on the \sphinxhref{https://docs.docker.com/install/}{Docker Engine overview} page and follow the links to install the package on your particular operating system.

\end{itemize}

Locate the folder containing the downloaded installer: your browser may have a \sphinxcode{\sphinxupquote{Downloads}} folder or it may have saved the downloaded file to the \sphinxcode{\sphinxupquote{My Documents}} or \sphinxcode{\sphinxupquote{Desktop}} folder. Inside the download folder, find the downloaded installer file and double\sphinxhyphen{}click it to run it.

\sphinxstylestrong{TO DO \sphinxhyphen{} could we get any security warnings?? If so, what, and how do we resolve them??}

\sphinxstylestrong{TO DO: There may be issues on Windows around things like virtualisation settings (HyperV and Docker don’t necessarily play nice). Please add any issues / problems relating specifically to getting Docker and the Docker container working to}\sphinxhref{https://github.com/innovationOUtside/tm129-robotics2020/issues/7}{this tracking issue}\sphinxstylestrong{.}

If you saved the installer earlier, you may now delete it since it is no longer required.

Docker runs as an application service and it should automatically start and run in the background.


\subsubsection{Running an Open Computing Lab Environment Via Docker}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Running-an-Open-Computing-Lab-Environment-Via-Docker}}
There are two recommended ways you can run your Open Computing Lab environment:
\begin{itemize}
\item {} 
by issuing commands on the command line from a terminal / command prompt \sphinxstylestrong{{[}CURRENTLY RECOMMENDED ROUTE{]}};

\item {} 
using a Docker container management application suchs as \sphinxstyleemphasis{ContainDS}.

\end{itemize}


\paragraph{Running an Open Computing Lab Environment from the Command Line}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Running-an-Open-Computing-Lab-Environment-from-the-Command-Line}}
It is quite possible to launch the RoboLab virtual environment from a terminal / command prompt and then access the actual environment via your browser in the normal way, although it is slightly more fiddly than using ContainDS.


\subparagraph{On a Mac / Linux Machine:}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:On-a-Mac-/-Linux-Machine:}}
Open a terminal. From the command prompt, do the following:
\begin{itemize}
\item {} 
create a working directory / folder to work in by entering the command: \sphinxcode{\sphinxupquote{mkdir TM129}};

\item {} 
change directory into that directory by running the command: \sphinxcode{\sphinxupquote{cd TM129}};

\item {} 
start the container by running the command: \sphinxcode{\sphinxupquote{docker run \sphinxhyphen{}\sphinxhyphen{}name tm129test \sphinxhyphen{}p 8129:8888 \sphinxhyphen{}v \$PWD:/home/jovyan/notebooks \sphinxhyphen{}e JUPYTER\_TOKEN="letmein" ousefuldemos/tm129\sphinxhyphen{}robotics2020:latest}}

\end{itemize}


\subparagraph{On Windows:}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:On-Windows:}}
Open a command prompt and run the following commands {[}UNTESTED{]}:
\begin{itemize}
\item {} 
create a working directory / folder to work in by entering the command: \sphinxcode{\sphinxupquote{mkdir TM129}};

\item {} 
change directory into that directory by running the command: \sphinxcode{\sphinxupquote{cd TM129}};

\item {} 
check the current directory path: \sphinxcode{\sphinxupquote{cd}}. Assuming it returns something like \sphinxcode{\sphinxupquote{C:\textbackslash{}\textbackslash{}users\textbackslash{}YOURUSER\textbackslash{}TM129}}, start the container by running the command: \sphinxcode{\sphinxupquote{docker run \sphinxhyphen{}\sphinxhyphen{}name tm129test \sphinxhyphen{}\sphinxhyphen{}rm \sphinxhyphen{}d \sphinxhyphen{}p 8897:8888 \sphinxhyphen{}v //C/users/YOURUSER/TM129/notebooks:/home/jovyan/notebooks  ousefuldemos/tm351\sphinxhyphen{}binderised:latest}}

\end{itemize}

\sphinxstylestrong{TO DO: does this require the notebooks dir to be available? If so: \textasciigrave{}\textasciigrave{}mkdir notebooks\textasciigrave{}\textasciigrave{} before the \textasciigrave{}\textasciigrave{}docker run…\textasciigrave{}\textasciigrave{} command.} In Windows, you cannot mount on to a non\sphinxhyphen{}empty directory inside the container. You can, however, define and automaticaly create your own directory. For it to be visible to the notebook server homepage, the shared directory needs to be mounted along the \sphinxcode{\sphinxupquote{/home/jovyan/\textquotesingle{} directory path. For example,}}\sphinxhyphen{}v
c:\tm`129share:nbsphinx-math:notebooks\textasciigrave{}:c:\home\jovyan\mySharedDirectory\textasciigrave{}.


\paragraph{Once the Docker Container is running…}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Once-the-Docker-Container-is-running_u2026}}
When you run the \sphinxcode{\sphinxupquote{docker run ...}} command, several things will happen:
\begin{itemize}
\item {} 
first, docker will download the container image from DockerHub (this may take some time but only happens the first time you try to run the container);

\item {} 
then, docker will launch the container and a Jupyter notebook server will start running inside it.

\end{itemize}

When the container is running, go to \sphinxcode{\sphinxupquote{localhost:8129}} in your browser (if that doesn’t work, try \sphinxcode{\sphinxupquote{http://127.0.0.1:8129}}) and you should see a running notebook server there.

Use the token \sphinxcode{\sphinxupquote{letmein}} to access the server (you should only need to do this once).

\noindent\sphinxincludegraphics[width=1786\sphinxpxdimen,height=1576\sphinxpxdimen]{{Jupyter_Notebook_token}.png}


\subparagraph{What to do if the Token isn’t set or doesn’t work}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:What-to-do-if-the-Token-isn_u2019t-set-or-doesn_u2019t-work}}
As a simple security measure, the notebook server requires a token or password the first time the server is accessed from a particular web browser.

If the token you have tried does not work, or if you did not start the container with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}e JUPYTER\_TOKEN="letmein"}} environmental variable setting, you will need to find the token used to access the notebook server. Run the command\sphinxhyphen{}line command:

\sphinxcode{\sphinxupquote{docker exec \sphinxhyphen{}it tm129test jupyter notebook list}}

This will display something along the lines of:

\sphinxcode{\sphinxupquote{Currently running servers: http://0.0.0.0:8888/?token=dca25d6755dbd2a1c9b346dca3b8c839e44c9271e20bc416 :: /home/jovyan}}

Use the token value (in the above example, \sphinxcode{\sphinxupquote{dca25d6755dbd2a1c9b346dca3b8c839e44c9271e20bc416}}) to log in to the server.


\subsubsection{Sharing Files into the Container}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Sharing-Files-into-the-Container}}
Any files in the local \sphinxcode{\sphinxupquote{TM129}} directory on your host computer should appear in the notebooks folder in the notebook homepage directory listing.

The run command will create a notebooks directory in the directory you issued the run command from, and then share it into the \sphinxcode{\sphinxupquote{notebooks}} folder that you can see from the notebook server homepage. OpenRefine projects are also shared between your local machine and the container.

Files that exist outside the \sphinxcode{\sphinxupquote{/home/joyan/notebooks}} directory path in the container (which is to say, outside the \sphinxcode{\sphinxupquote{notebooks}} directory viewable from the notebook server homepage, \sphinxstyleemphasis{will not be shared to your local desktop}.


\paragraph{Running an Open Computing Lab Environment via the ContainDS Application}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Running-an-Open-Computing-Lab-Environment-via-the-ContainDS-Application}}
\sphinxstylestrong{TO DO: ContainDS has moved on since this guidance was originally written. If the instructions are wrong / don’t work, please comment back to}\sphinxhref{https://github.com/innovationOUtside/tm129-robotics2020/issues/6}{this issue}\sphinxstylestrong{.}

\sphinxstyleemphasis{ContainDS} is a cross\sphinxhyphen{}platform (MacOS, Windows) desktop application that simplifies the launching and management of Docker containers in general, and Docker containers that incorporate Jupyter notebook servers in particular.

\sphinxstyleemphasis{You can also launch and use the RobotLab environment from the command\sphinxhyphen{}line on any platform (}\sphinxstylestrong{TO DO?? \sphinxhyphen{} see the \textasciigrave{}\textasciigrave{}RoboLab Environment FAQ\textasciigrave{}\textasciigrave{}}\sphinxstyleemphasis{). It’s just that ContainDS makes life much easier…}

Download and install the latest version of the ContainDS application directly from the \sphinxhref{https://containds.com/}{ContainDS website}:
\begin{itemize}
\item {} 
\sphinxstylestrong{Windows} — use \sphinxstyleemphasis{one} of the following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textasciigrave{}exe}} installer \textless{}\sphinxurl{http://containdsreleases.s3-website.us-east-2.amazonaws.com/latest/exe}\textgreater{}\textasciigrave{}\_\_

\item {} 
\sphinxcode{\sphinxupquote{\textasciigrave{}msi}} installer \textless{}\sphinxurl{http://containdsreleases.s3-website.us-east-2.amazonaws.com/latest/msi}\textgreater{}\textasciigrave{}\_\_

\end{itemize}

\item {} 
\sphinxstylestrong{MacOS} — use \sphinxstyleemphasis{one} of the following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textasciigrave{}pkg}} installer \textless{}\sphinxurl{http://containdsreleases.s3-website.us-east-2.amazonaws.com/latest/pkg}\textgreater{}\textasciigrave{}\_\_

\item {} 
\sphinxcode{\sphinxupquote{\textasciigrave{}dmg}} installer \textless{}\%60http://containdsreleases.s3\sphinxhyphen{}website.us\sphinxhyphen{}east\sphinxhyphen{}2.amazonaws.com/latest/dmg\%60\textgreater{}\textasciigrave{}\_\_

\item {} 
\sphinxstylestrong{Linux}: \sphinxstyleemphasis{not currently available} \sphinxstylestrong{TO DO: Kitematic might be a GUI fall back; or command line, which might make sense anyway.}

\end{itemize}

\end{itemize}

Alternatively, you may save the installer to your computer by right\sphinxhyphen{}clicking the appropriate link and choosing \sphinxcode{\sphinxupquote{Save Link As…}} or \sphinxcode{\sphinxupquote{Save Target As…}}.

Locate the folder containing the downloaded installer: your browser may have a \sphinxcode{\sphinxupquote{Downloads}} folder, or it may have saved the downloaded file to the \sphinxcode{\sphinxupquote{My Documents}} or \sphinxcode{\sphinxupquote{Desktop}} folder. Inside the download folder, find the downloaded installer file and double\sphinxhyphen{}click it to run it.

\sphinxstylestrong{TO DO \sphinxhyphen{} could we get any security warnings?? If so, what, and how do we resolve them??}

If you saved the installer earlier, you may now delete it since it is no longer required.

The ContainDS application is a desktop application. Run it as you would any other application:
\begin{itemize}
\item {} 
Windows: launch the application \sphinxstylestrong{TO DO: how??}

\item {} 
MacOS: the application will be installed into your \sphinxcode{\sphinxupquote{Applications}} folder. You can launch it from there, or add the application icon the Dock to make it easier to find and launch. See also: \sphinxhref{https://support.apple.com/en-gb/guide/mac-help/mh35859/mac}{MacOS documentation \sphinxhyphen{} using the Dock}.

\end{itemize}


\subsubsection{Using ContainDS to Install the Prebuilt Open Computing Lab Container Image}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Using-ContainDS-to-Install-the-Prebuilt-Open-Computing-Lab-Container-Image}}
\sphinxstyleemphasis{Note that in this approach, you will}\sphinxstylestrong{not}\sphinxstyleemphasis{be able to synchronise files inside the container with a persistent directory on your desktop.}

Open the ContainDS application, select the \sphinxcode{\sphinxupquote{Docker}} tab and search for \sphinxcode{\sphinxupquote{tm129}}. Select the \sphinxcode{\sphinxupquote{tm129\sphinxhyphen{}robotics2020}} image.

\noindent\sphinxincludegraphics[width=2146\sphinxpxdimen,height=956\sphinxpxdimen]{{00_01_ContainDS_tm129_download}.png}

If you have not previously downloaded the image, ContainDS will download it for you:

\noindent\sphinxincludegraphics[width=1694\sphinxpxdimen,height=1016\sphinxpxdimen]{{00_01_ContainDS_tm129_downloading}.png}

Do not be concerned if the download percentage indicator sometimes goes down as well as up — the downloader is actually downloading multiple items at once. (The container image is made up from several layers, each of which is downloaded separately, before they are combined in the final image.)

When everything had downloded, you may find your computer appears to be doing nothing for a minute or two, or even appears to get stuck just short of a 100\% complete donwload. \sphinxstyleemphasis{Don’t Panic!} The downloaded layers are all compressed files, and it may take some time for your computer to unzip them all.

Once downloaded, you will be prompted for a method of starting the container. Select “Standard”:

\noindent\sphinxincludegraphics[width=980\sphinxpxdimen,height=298\sphinxpxdimen]{{00_01_ContainDS_standard_run}.png}

The container will now be launched and a log trace displayed.

At this point, you need to \sphinxcode{\sphinxupquote{STOP}} the container and remove it:

\noindent\sphinxincludegraphics[width=1636\sphinxpxdimen,height=1196\sphinxpxdimen]{{00_01_containds_stopRemove}.png}

Now create a running version of the container from the \sphinxstyleemphasis{local} Docker image. This will allow you to share a local directory into the container as well as clicking through directly to the notebook homep{[}age in your browser.


\subsubsection{Using ContainDS To Run the Open Computing Lab Environment from a Local Docker Image}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Using-ContainDS-To-Run-the-Open-Computing-Lab-Environment-from-a-Local-Docker-Image}}
Click on the \sphinxcode{\sphinxupquote{+NEW}} button and then select the \sphinxcode{\sphinxupquote{Docker}} tab and then the \sphinxcode{\sphinxupquote{Local Images}} tab:

\noindent\sphinxincludegraphics[width=2136\sphinxpxdimen,height=946\sphinxpxdimen]{{00_01_ContainDS_local}.png}

\sphinxcode{\sphinxupquote{SELECT}} the local copy of the \sphinxcode{\sphinxupquote{tm129\sphinxhyphen{}robotics2020}} container which will open the container workspace configuration page:

\noindent\sphinxincludegraphics[width=1248\sphinxpxdimen,height=1064\sphinxpxdimen]{{00_01_local_workspace}.png}

Set the path to the directory on your host computer that you want to share into the container. This will create a \sphinxcode{\sphinxupquote{notebooks}} directory in that directory that will be mapped onto the \sphinxcode{\sphinxupquote{notebooks}} directory visible from the notebook homepage.

When you \sphinxcode{\sphinxupquote{CREATE}} the container, it will run automatically. Clicking the \sphinxcode{\sphinxupquote{WEB}} link should take you to the notebook home page in your browser. \sphinxstyleemphasis{(Note that the file listing in the screenshot may differ from the file listing you see.)}

\noindent\sphinxincludegraphics[width=2114\sphinxpxdimen,height=388\sphinxpxdimen]{{00_01_simple_nb_home}.png}

When you save your notebooks, they will be saved into the shared directory on your own computer.


\subsubsection{Using ContainDS to Build and Run a RoboLab Container from Scratch}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Using-ContainDS-to-Build-and-Run-a-RoboLab-Container-from-Scratch}}
As well as running the prebuilt RoboLab container, ContainDS can also build the container image, and then launch an image from it, from scratch. (The image only needs to be built once.)

Launch the ContainDS application, and then select the \sphinxcode{\sphinxupquote{Binder}} tab.

Enter the name of the source repository:

\sphinxcode{\sphinxupquote{innovationOUtside/tm129\sphinxhyphen{}robotics2020}}

and click the \sphinxcode{\sphinxupquote{LAUNCH}} button.

\noindent\sphinxincludegraphics[width=1962\sphinxpxdimen,height=1208\sphinxpxdimen]{{00_01_ContainDS_binderhub}.png}

As the image is built, you will see several temporary containers being created and destroed along the way. Note that the build process may take some time (up to 10 minutes or more).

Once the image has been built, a running container will be launched from it.

Click on the \sphinxcode{\sphinxupquote{WEB}} link and you should be taken directly to the notebook homepage in your browser without needing to provide any notebook server token yourself.

\noindent\sphinxincludegraphics[width=2138\sphinxpxdimen,height=886\sphinxpxdimen]{{00_01_containds_built_container}.png}

\sphinxcode{\sphinxupquote{STOP}} and remove the container, and then run it from a Local Docker Image; this will allow you to share a local directory into the container and directly click through to the notebook server homepage in your browser.


\subsubsection{Obtaining the RoboLab Instructional Materials}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Obtaining-the-RoboLab-Instructional-Materials}}
We have provided a complete set of interactive instructional materials for working through the RoboLab activities in the RoboLab environment when run as a standalone container. However, if you share a local directory into the container using ContainDS, this will overwrite all those files.

If you need to download the materials separately, they can be downloaded from:
\begin{itemize}
\item {} 
{[}TEMPORARY{]}: the \sphinxhref{https://github.com/innovationOUtside/tm129-robotics2020}{innovationOUtside/tm129\sphinxhyphen{}robotics2020} repository;

\item {} 
the Resources area of the VLE???? \sphinxstylestrong{TO DO}

\end{itemize}

The contents of the repository can also be , it’s easier to use the \sphinxcode{\sphinxupquote{nbgitpuller}} application. From your notebook homepagem for example at \sphinxcode{\sphinxupquote{http://localhost:32796/tree}} (your port number may well be different to \sphinxcode{\sphinxupquote{32796}}…) change the path from \sphinxcode{\sphinxupquote{tree}} to:

\sphinxcode{\sphinxupquote{git\sphinxhyphen{}pull?repo=https\%3A\%2F\%2Fgithub.com\%2FinnovationOUtside\%2Ftm129\sphinxhyphen{}robotics2020\&urlpath=tree\%2Ftm129\sphinxhyphen{}robotics2020\%2F\&depth=1}}

to give a URL of the form:

\sphinxcode{\sphinxupquote{http://localhost:YOUR\_PORT\_NUMBER/git\sphinxhyphen{}pull?repo=https\%3A\%2F\%2Fgithub.com\%2FinnovationOUtside\%2Ftm129\sphinxhyphen{}robotics2020\&urlpath=tree\%2Ftm129\sphinxhyphen{}robotics2020\%2F\&depth=1}}

Entering this URL will download the contents of the repository, making them available via the notebook server homepage and saving them to you local, shared directory if you are working with a local, shared workspace.

The materials are presented as a set of Jupyter notebooks. They include written guidance and example code that you can edit and execute. You can also add text cells to keep your own commentary and notes inside the notebook, as well as code cells in which you can write and run your own robot programming code.

You will probably want to keep copies of your annotated and executed notebooks as you work through them.


\subsubsection{Saving and Checkpointing Your Work}
\label{\detokenize{content/00_READ_ME_FIRST/Section_00_05_Accessing_RoboLab:Saving-and-Checkpointing-Your-Work}}
Within the notebook environment, the file will be saved automatically every 120 seconds (which is to say, every two minutes).

If you have changed the notebook since it was last autosaved, you will see a statement like the following next to the notebook filename at the top of the notebook:

\sphinxcode{\sphinxupquote{Last Checkpoint: Last Friday at 12:18 AM (unsaved changes)}}

The \sphinxcode{\sphinxupquote{(unsaved changes)}} phrase is akin to the \sphinxcode{\sphinxupquote{*}} indicator you often see next to a filename in a document editor that shows the file has changed since it was last saved.

If you watch for at most a couple of minutes, you’ll note that it soon changes to something with the following form:

\sphinxcode{\sphinxupquote{Last Checkpoint: Last Friday at 12:18 AM (autosaved)}}

You can change the autosave period using magic (yes, really! That’s what it’s called…). For example, run the following statement in a notebook code cell and it will change the autosave period \sphinxstyleemphasis{for that notebook only} to 60 seconds:

\sphinxcode{\sphinxupquote{\%autosave 60}}

The autosave time can also be set using the \sphinxcode{\sphinxupquote{AutoSaveTime}} notebook extension which can be enabled from the \sphinxcode{\sphinxupquote{nbextensions configurator}} {[}\sphinxhref{/nbextensions/?nbextension=autosavetime/main}{direct link}{]}.

As well as allowing your notebooks to be automatically saved, you can also “checkpoint” them.

When you use a keyboard shortcut to manually save the file, or you save a notebook document from the notebook \sphinxcode{\sphinxupquote{File}} menu, you are actually issuing a \sphinxcode{\sphinxupquote{Save and Checkpoint}} command. This saves in the same way that the autosave function does, but it \sphinxstyleemphasis{also} generates a checkpointed (backed up) version of the file in the hidden \sphinxcode{\sphinxupquote{.ipynb\_checkpoints}} folder.

What this means is that if you work on a file, allowing it to be autosaved, and realise that you have made some terrible mistakes in it, you can revert the notebook to a previously checkpointed (manually saved) version.

Note that this will throw away all changes made to the autosaved version of the notebook since the last manual (checkpointing) save, so use this command with care.



---
## 1.6 Activity: The RoboLab Notebook Editable Text Environment


In this short activity I will show you how to organise your RoboLab work environment. You won’t run any robot programs until the next activity.

<div class='alert-danger'>TO DO - this is a 101 in using the environment. We're in an md doc running in notebook, so can use this part of the doc interactively. The workflow / layout may change, but that needs front-end js/ts/css dev and debug skills I donlt have (atm...). I'm working on MVP workflow atm, which may suck, but should work.</div>


If you clicked on the the link to this document from a Jupyter notebook server homepage in the RoboLab environment, it will have opened within the notebook user interface as an interactive notebook document.


### A first look

To start RoboLab, launch the ContainDS application.

If RoboLab is running, you should see it in the side bar, with its status indicator highlighted green.

![ContainDS showing a running container with a green status indicator](../images/00_01_ContainDS_robolab_running.png)

If it is not running, the status indicator will be greyed out. Click on the `START` button to start the container running.

If you cannot see the container in the sidebar, click on the `+NEW` button and following the instructions for *Running the RoboLab Environment from a Local Docker Image*.

If you cannot see a local copy of the image, follow the instructions for `Using ContainDS to Install the Prebuilt RoboLab Container Image`.

With the container running, click on the `WEB` button to open the notebook server homepage in your browser.

When RobotLab starts, the notebook server homepage will look something like the following (the actual file listing may differ).

![Example of the notebook server homepage, including Files, Running and NBextensions tabs and a file listing.](../images/00_01_jupyter_nb_homepage.png)


If you click on a folder link, you will be presented with a list of the files contained in that folder, as you might expect. Click on the directory path links to navigate your way back up the directory listing tree.

The top of the directory listing is the directory that you shared in to the container using ContainDS. If you started the container from the command line, the top level is the `/home/jovyan` directory in the container and files should be mounted into that directory, either directly on on the path (for example, `/home/directory/mySharedDirectory`).


## Working With Notebook Files Interactively

If you are reading this document in a live Jupyter notebook environment, you will be able to interact with it directly.


For example, you can correct the speling mistake in this sentence by editing it directly. Double click on this paragraph, and the cell will become editable. Correct the spelling mistake, then "run" the markdown cell to redisplay it as formatted text.

You can do this in two ways. Either click on the `Run` button in the toolbar, or use a keyboard shortcut: `shift-enter` (that is, the shift key and the enter key at the same time).

Remember, to look up keyboard shortcuts, you can use the `ESC-h` keyboard shortcut (press the escape key and then, quickly after, the `h` key, or the escape key and the `h` at the same time): in the "Edit mode" area, look for "run selected cell".


### Previewing Formatted Markdown

Markdown text is a simple *mark-up* language in which you can write styled text using simple (hopefully intuitive) text elements. For example, to *emphasise* a word using italics, write it as follows: \*emphasis\*.

You may notice my "starred" text is not itself italicised. If you double click on this markdown cell to see its editable view, you will see I have "escaped" the * characters around the word \*emphasis\* with a backslash character — \ — as if to say: *do not process this*. Note that if you have a space between a * and a letter at the start of a word, then the styling is similarly not applied; likewise, to "close" the styling, you need to place the second * right next to the final character in the emphasised text.

*When you have finished looking at the editable text, hit `shift-enter` to return the cell to the rendered view.*

That may all sound complicated, but hopefully it will become natural to you. You may find you use similar techniques anyway when writing emails or social media messages or posts. You may even find that your editor in those environments is actually treating your text markup as markdown anyway.

The next paragraph contains several examples of other forms of mark up. Double click on the cell to make it editable so you can see how the styling was generated.

### Markdown Examples

Double click on this cell to see how markdown is used to create particular styling effects.

We can *italicise text* by wrapping it with single asterisk `*...*` or `_..._` underscore elements.

Use a backslash character to disable the text processing effect, eg if you which to italicise a *\** character.

Strong (__bold__) emphasis can be introduced by wrapping text doubling up the number of * or _ elements.

Unnumbered list items:

- are prefixed by a `-` or single `*` character, followed by a space;
* are clearer in their text for if you precede the first list item with a blank line
  - sublists are indented, and are identified by prefixing the - or * marker by two spaces.

Numbered lists:

1. are identified by prefixing the line with `1.` followed by a space.
1. some flavours of markdown may offer the ability to use alternative numbering schemes (letters, or Roman numerals, for example).


Headings are identified by starting the header line with one or more `#` characters, followed by a space and then the title or (sub) heading. The number of `#` characters identifies the level of heading required.

You can also identify a heading by placing two or more equals signs (`==`) on the line immediately below it, or a subheading by placing two or more dashes (`--`) at the start of the following line.

Dividing lines can also be added: just start a line with three or more dashes (`---`) prefixed by an empty line.


Inline `code` can be identified by wrapping the code item within backticks: \`...\`.

Blocks of code can identified by marking out an area using three or more backticks to start and end the block:

```
# comment
def hello(msg):
    print(msg)

hello("my friend")
```

Syntax highlighting for a particular language can be enabled by declaring the language required immediately after the opening set of backtcicks (although rendereing backticks in backticks can be tricky!). For example, starting a code block with ```` ```python ```` will cause it to be rendered using Python language syntax highlighting:


```python
# comment
def hello(msg):
    print(msg)

hello("my friend")
```

You can also add links you your markdown text, using constructions of the form: `[my link text](https://example.com)`.

## Taking Ownership of Your Notebooks

One of the difficulties in working with electronic texts is that they can often be hard to annotate. Interactive notebook style interfaces offer a different way of working, in that you can annotate or edit the text directly.

One way of annotating the markdown text materials is to use the highlighter pen from notebook toolbar.

![Notebook toolbar showing highlight pen buttons.](../images/00_01_highlighter.png)


<span class="mark">Simply select the text you want to highlight in its rendered view, and then click on the appropriate highlighter pen colour.</span>

Another way is to just start clicking on the markdown cells, adding your own notes, commentary or reflection, or your own questions, explanations and examples, to the text.

There are risks associated with this of course - like accidentally deleting a chunk of module materials, or changing a working example to a broken one. But there are also many advantages - like making the materials meaningful *to you*. And if you want to distinguish your content from the provided materials, you can always highlight them, or put them in a markdown cell of their own, with a heading that identifies the text in that cell as your own work.

Alternatively, from the notebook toolbar, change your own markdown cells to cells of type `Raw NBConvert`. Although this cell type does not render the markdown styling — the text is presented in a "raw" teletype style text view —  if you used markdown annotations *they should still mark up your text in a __meaningful__ way*. And the text is visually distinguishable from the provided, styled, markdown materials.

### Previewing Style Markup

Although I find it second nature to write in markdown (I've been been writing in simple text formats for a long time!) you may find it takes some getting used to, and that you keep having to flip between the edit view and the rendered view to make sure you are creating the text effect you intended.

To make it easier, if you enable the `livemdpreview` notebook extension [[direct link](/nbextensions/?nbextension=livemdpreview/livemdpreview)], you can preview how your rendered markdown looks in a preview window directly underneath a markdown cell you are editing.

*You may need to save your notebook and reload it in your browser after enabling the extension to see the effect. It should be enabled by default for any notebooks you open after enabling the extension.*

A checkbox option in the extension's configuration panel optionally allows you to display the preview alongside, rather then below, the markdown cell being edited. The preview disappears when you return the cell to its display mode.


### WYSIWYG "Text Editor" View
If you really cannot get to grips with writing raw markdown, a WYSIWG editor is available.

Enable the [`jupyter_wysiwyg`](/nbextensions/nbextension=jupyter_wysiwyg/index) extension from the `nbextensions` notebook configuration tab on the notebook server homepage. (You may find that access to the *WYSIWYG text editor* extension is disabled at first; at the top of the extensions configurator page, uncheck the *disable configuration for nbextensions without explicit compatibility* option.)

Save and reload your notebook. When you double click on a markdown cell to edit it, you should now see two buttons have appeared on the left-hand side of the cell, one with a `Rich Text Editing` tooltip when you hover over it, the other with a `Run Cell` tooltip.

The `Run Cell` button provides a convenient additional way of rendereing a markdown cell that is currently in edit mode. You also need to use this button to render the cell if you have been editing it using the rich text WYSIWYG editor.

The `Rich Text Editing` button provides a way of launching the rich text editor. This editor allows you to style your text, and immediately see the result, as you type. You can still see the raw mark-up text by rendering the cell and then double clicking on it to take it into the edit mode. However, you may find that the marked up text is not quite as clean as mark-up text: HTML tags are used to style the text and any previous markdown annotations will be converted to theitr HTML equivalents.


## Creating New Cells

To create a new cell in a notebook, click on the `+` button in the notebook toolbar. A new cell will be created directly below the current selected cell.

By default, a new cell is created as a code cell. To convert the cell to a *markdown* cell type, change the cell type using the cell type drop-down list in the notebook toolbar from `Code` to `Markdown`.

A keyboard shortcut — `ESC-M` (that is, the escape key followed by the letter `m`) — also converts a selected cell in *Edit mode* to the *markdown* cell type.


## Code Cells

Code cells can be used to enter — and *execute* — Python code.

To run a code cell, which is to say, to execute the code contained in a code cell, click in the code cell to select it and then press the run ("play") button on the notebook toolbar. Alternatively, use a keyboard shortcut - `SHIFT-RETURN` — to run the selected cell.

```python
print("Hello!")
```

When a cell has successfully completed executing, the run status indicator is coloured green. After running a code cell, a number in square brackets displays a cell execution index number. Each time a code cell is run, the overall index count goes up by one and is used to indicate the cell execution index (or "cell run number") for that cell.

When a code cell is running, or waiting to run, it is highlighted with a light blue colour on the left hand side. A * character also indicates the status of the running cell.

<img alt="Screenshot of notebook showing one completed cell execution with green run status indicator in the cell sidebar, along with one running cell and one yet to be run cell with a light blue run status indicator." src="../images/00_01_cell_run_status_running.png" width=400 />

If you run all the cells in a notebook, all the cells yet to be run, as well as the running cell, are highlighted with a blue run status indicator and the * cell run number.

<img alt="Screenshot of notebook showing one completed cell execution with green run status indicator in the cell sidebar, along with one running cell and one yet to be run cell with a light blue run status indicator." src="../images/00_01_cell_run_status.png" width=400 />


If an error is raised that causes a code cell not to execute correctly, the run status indicator is coloured pink and an error message is show beneath the the cell in the code cell display area.

<img alt="Screenshot of notebook showing one completed cell execution with green run status indicator in the cell sidebar, along with one running cell and one yet to be run cell with a light blue run status indicator." src="../images/00_01_cell_run_error.png" width=800/>

Clicking on the arrow will at the end of the error messge will reveal the full error message.

<img alt="Screenshot of notebook showing a code cell execution error with expanded error message." src="../images/00_01_cell_run_error_message.png" width=800 />


Run the following cells to see the indicators in action.

```python
import time
```

```python
time.sleep(25)
```

```python
print("hello")
```

```python
print("hello again"
```

### Displaying Code Line Numbers

Sometimes it can be useful to display line numbers in a code cell to more easily reference or refer to a particular line of code. Line numbers can be toggled on and off within a particular code cell using the keyboard shortcut `ESC-L` (that is, *escape* and *l*).

When a notebook is saved, the  line number toggled display settings are also saved.

```python
# Example of code cell line numbering

# This is actually line 3...
```

Click in the above code cell to select it and practice toggling the line numbers on and off.


### Code Style

To make code as readable as possible, the [Pyhton PEP8 style guide](https://www.python.org/dev/peps/pep-0008/) provides guidance on how to lay out your code so that it is easier to read. Code style guidance includes things like:

 - use of white space within lines and between lines
 - naming conventions for function and variable names
 - maximum line lengths to maintain readability

Throughout the notebooks, we have tried to use good practice, although PEP8 standards have not necessarily always been enforced. Various tools are available for warning about breaches of PEP8 style guidelines or even automatically formatting code so that it is style compliant, but these are disabled by default in these notebooks.

*See [Notebook Code Linting](https://github.com/innovationOUtside/TM351_forum_examples/blob/master/Notebook%20Code%20Linting.ipynb) for more information about automatically linting code in Jupyter notebooks.*


## Creating New Code Cells

Single click on this markdown cell to ensure that it has the focus and then create a new code cell by clicking on the `+` button in the notebook toolbar. A new cell will be created directly below the currently selected cell, whatever type of cell it is. By default, newly created cells are created as code cells. The cursor focus is automatically moved to the new cell, so once it is created you can immediately start typing code into it.

__DO:__ *Click on the `+` button in the notebook toolbar to create a new code cell, entry `print('hello world')` and run the cell to execute the code and see the result.*

Feel free to create and run your own notebook code cells to try out your own code examples. Remember, the notebooks *are yours*. So make full use of them...


## How the simulator relates to the notebooks

The simulator we are using is created as an interactive `ipywidget` that is embedded within a Jupyter notebook. In the current iteration, the layout is not ideal, but we are working on improving on it.

The simulator runs as a Javascript programme in the browser tab associated with the notebook the simulator is embedded in. The simulator has various settings that can be configured within the simulator UI, or from the notebook commands that invoke it.

*TO DO: there may also be magicked UIs for various settings; still to be decided.*


Run the following code cell to load in an instance of the simulator and embed it within this notebook:

```python
from nbev3devsim import ev3devsim_nb as eds
%load_ext nbev3devsim

roboSim = eds.Ev3DevWidget()
display(roboSim)
```

Code is "downloaded" from a code cell in the notebook to the simulator by running the code cell with some special IPython *magic* in the first line of the cell.

Run the following code cell to download the code to the simulator. Then click the *Run* button in the simulator to run the downloaded code there.

```python
%%sim_magic_preloaded roboSim

# Stay inside
tank_drive.on(SpeedPercent(50), SpeedPercent(50))
tank_turn.on_for_rotations(-100, SpeedPercent(75), 2)
```

Only a single instance of the simulator should be embedded in any given notebook, although you may have different notebooks open each running their own embedded simulator. (It is generally not advisable to have multiple copies of *the same notebook* open in multiple windows. As the notebooks autosave, you may find that work you have created and saved from one notebook gets overwritten by an earlier version of the notebook in a different browser tab or window.


### Alternative RoboLab User Environments

The original `ev3devsim` simulator ran solely within a web browser (that is, it did not require any support from Jupyter tools). The embedded simulator has been extended and whilst many of the extensions could be integrated back into the original standalone simulator, they have not currently been so.

Withing the Jupyter ecosystem, using tools such as JupyterLab, or Voilà interactive dashboards/applications, there is more scope for controlling the layout of the RoboLab environment. For the initial treatment, however, we are just working with Jupyter notebooks.

One advantage of using Jupyter notebooks is that we can retrieve logged data from sensors mounted on the robot in the simulator back into the notebook environment and then use the full range of Python charting and analysis tools to expore the data.


### Configuring the Simulator Layout

The simulator environment includes a range of user controls that can be used to configure the layout and view of the simulator user interface, as well as controlling operations performed within it. These include positioning the simulated robot, loading in different simulator backgrounds, loading obstacles into the simulated world, displaying status messages from the robot and dynamically charting logged sensor readings, as well as many other features.

You will be introduced to these in more detail as and when they are required.


## Creating and Saving Your Own Code

The activities hve been created within Jupyter notebooks using the embedded simulator. In many activities, you will have the opportunity to create and run your own programmes to run within the simulator, as well as within the notebook's own Python coding environment.

Saving a notebook will save your code and any currently displayed cell outputs (the notebooks also autosave regularly), so you can close the notebook, shutdown the associated notebook process, and then restart the notebook and return to it later.

Although the current simulator view, any other displayed widgets, and the internal state of the simulator and the notebook's own Python environment, are not saved, rerunning the code cells that create them will generate them afresh.

As well as using the provided notebooks, you are also encouraged to create and save your own notebooks and use the simulator for your own exercises.
---


\section{SOFTWARE GUIDE}
\label{\detokenize{index:software-guide}}

\subsection{1 Getting started}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_01_Jupyter_environment:1-Getting-started}}\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_01_Jupyter_environment::doc}}
In which we introduce the working environment for the TM129 Robotics Block practical activities.

\sphinxstyleemphasis{As I edit this, as a direct revision of the original, it’s a very “flat” document. A lot of the things could be made more interactive. eg an interactive tour of elements of the notebook or a Graffiti interaction, rather than a static, linear, screenshot enhanced narration. Middle ground would be a screencast. But could we also instrument that somehow? Certainly, we could capture the visual recording using browser automation.}


\subsubsection{1.1 Introduction to the TM129 Virtual Robotics Lab: RoboLab}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_01_Jupyter_environment:1.1-Introduction-to-the-TM129-Virtual-Robotics-Lab:-RoboLab}}
The \sphinxstyleemphasis{TM129 Virtual Robotics Lab}, or “RoboLab” for short, is a self\sphinxhyphen{}contained, virtualised computing environment. This environment enables you to experiment with, and program, simple simulated robots using the Python programming language. The same environment can be used on different computing platforms (Windows, MacOS, Linux) either running locally on your own computer or via a remote external server accessed over the internet.

You will use RoboLab in a practical session during each study week of this part of the module.

After studying RoboLab you should be able to:
\begin{itemize}
\item {} 
understand the basics of computer programs (e.g. explain what is meant by a sequential computer program, the terms ‘constant’ and ‘variable’, and explain and illustrate the terms ‘branch’ and ‘loop’)

\item {} 
use programs in RoboLab (e.g. run example programs in RoboLab and say what a simple robot control program will do)

\item {} 
manipulate simple programs in RoboLab (e.g. modify the programs to give different behaviours and write your own simple robot control programs).

\end{itemize}

If you already know something about computer programming or robotics we will also provide you with links to various extension activities that you can use to develop your skill further.

Note that the purpose of these activities is \sphinxstyleemphasis{not} to teach you how to write code in the Python programming language specifically, nor to provide you with an introductory course in computer programming in general. Instead, the intention is show you how we can use building blocks of code to programme a simple simulated robot in order to perform a range of simple tasks. The \sphinxstyleemphasis{programming} task is often more to do with decomposing a problem into simple steps we know how to do than it is writing
syntactically correct Python code. So if something new appears in one of the programmes we provide you with in an unexplained way, \sphinxstyleemphasis{DON’T PANIC}. Accept it as a black box that does \sphinxstyleemphasis{something}, and go with it; a fuller explanation will often appear later.

The lab sessions each week consist of exercises using a simulated robot. The simulated robot is based on a small mobile robot with a number of sensors. Robots like this are available at low cost and many are within the reach of amateur enthusiasts.

RoboLab itself is accessed using a Jupyter environment presented via a web browser. Many activities are presented through interactive Jupyter notebooks and make use of a simple graphical robot simulator.


\paragraph{The Jupyer Notebook Environment}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_01_Jupyter_environment:The-Jupyer-Notebook-Environment}}
Jupyter notebooks are are widely used interactive environment for writing “literate” programming scripts in a web browser. Originally developed to support computational data science projects, they are increasingly used as more general computational notebooks that can blend explanatory text with executable code and graphical, or even interactive, code outputs.

The notebook homepage provides a simple listing of files in a particular directory. Additional tabs allow you to monitor currently running notebooks and configure user\sphinxhyphen{}enabled extensions that can be used to customise your notebook environment.

\noindent\sphinxincludegraphics[width=2160\sphinxpxdimen,height=564\sphinxpxdimen]{{00_01_jupyter_nb_homepage}.png}

Clicking on a file of an appropriate type will open it as an interactive Jupyter notebook.

Notebooks are structured using the notion of different sorts of “cell”. For example, \sphinxstyleemphasis{markdown cells} are used to contain explanatory text written using the simple text based markdown script. Executable \sphinxstyleemphasis{code cells} can be used to declare executable Python code, the outputs of which can be displayed as \sphinxstyleemphasis{code cell outputs}.

\noindent\sphinxincludegraphics[width=1802\sphinxpxdimen,height=562\sphinxpxdimen]{{notebook_markdown_and_code_cell}.png}

As well as supporting general computation, code cells are also used to create and display a simulator output:

\noindent\sphinxincludegraphics[width=1736\sphinxpxdimen,height=1426\sphinxpxdimen]{{nbev3devsim_in_notebook_annotated}.png}

In addition, code cells can contain code that is “downloaded” to the simulator when the code cell is run:

\noindent\sphinxincludegraphics[width=1948\sphinxpxdimen,height=894\sphinxpxdimen]{{nbev3devsim_example_code_cell_annotated}.png}

Markdown and code cells can be edited and saved interactively via the notebook’s browser interface.

As well as the notebook environment, a more complex “lab” or “integrated development” style interface, \sphinxstyleemphasis{Jupyterlab}, is also available.

The following shows a JupyterLab set up based around another notebook based simulator, the \sphinxcode{\sphinxupquote{Jyro}} robot simulator. At the current time, the simulator used for the RoboLab activities do not work using the “torn off” simulator output window display mode shown below.

\noindent\sphinxincludegraphics[width=2648\sphinxpxdimen,height=1416\sphinxpxdimen]{{00_01_jupyterlab_example}.png}

Whilst you are welcome to make use of the JupyterLab environment, we will tend to stick to the simple notebook interface for the module activities.

The following cell contains Python code that can be executed by “running” the code cell. The code can produce two sorts of output:
\begin{itemize}
\item {} 
display items rendered as the programme executes via \sphinxcode{\sphinxupquote{display()}} or \sphinxcode{\sphinxupquote{print()}} commands in the code;

\item {} 
a “cell output” value that displays the return value (if any) from the last statement in the cell.

\end{itemize}

The code in the cell can be executed using the “Run” button in the notebook toolbar, as well as via keyboard shortcuts.

(We will explore the mechanics of using the notebooks in more detail later on.)

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}print(\PYGZdq{}hello world...\PYGZdq{})

my\PYGZus{}variable = \PYGZdq{}value of my variable\PYGZdq{}
my\PYGZus{}variable
\end{sphinxVerbatim}
}


\paragraph{Notebook Extensions}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_01_Jupyter_environment:Notebook-Extensions}}
A wide range of notebook extensions are installed in the RoboLab environment, although the majority have not been pre\sphinxhyphen{}enabled.

You can enable and disable extensions, as well as further configuring certain extensions, via the extensions configurator. This can be accessed from the notebook homepage or from the \sphinxcode{\sphinxupquote{nbextensions config}} option in the \sphinxcode{\sphinxupquote{Edit}} menu of an opened notebook.

\noindent\sphinxincludegraphics[width=1858\sphinxpxdimen,height=1440\sphinxpxdimen]{{00_01_nbextension_config}.png}

You are welcome to explore the available extensions, or even add further ones of your own, to personalise your notebook environment, but we will not discuss them further here.

\sphinxstyleemphasis{You may want to share details of any extensions you find particularly useful in your module or tutor group forums.}


\subsubsection{Addendum}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_01_Jupyter_environment:Addendum}}
At the end of some notebooks, there may be an \sphinxstyleemphasis{Addendum} section. These sections are \sphinxstyleemphasis{optional} as far as the module goes, and you are not necessarily expected to, let alone required to, study them, read through them, or even glance at them at all.

In particular, the addendum sections provide additional context or explanation not directly relevant to the module but which may be of interest to the more curious or technically minded amongst you. In some cases, the sections are there to explore in a little more detail how a particular activity or notebook feature works behind the scenes; in other cases, they may hint at other ways in which what you have learned may be applied to other contexts not directly associated with programming robots.


\subsection{2 The RoboLab simulated on\sphinxhyphen{}screen robot (\sphinxstyleliteralintitle{\sphinxupquote{nbev3devsim}})}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02-nb3devsim:2-The-RoboLab-simulated-on-screen-robot-(nbev3devsim)}}\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02-nb3devsim::doc}}
The \sphinxcode{\sphinxupquote{nbev3devsim}} simulator is arranged slightly differently to the original \sphinxcode{\sphinxupquote{ev3devsim}} simulator in order to develop a workflow that more naturally suits notebook style working.

Rather than saving programmes to separate files, each individual robot simulator programme is defined within its own notebook code cell, and can then be “downloaded” to the simulated robot. This means you can keep track of a how a programme develops by writing each version of a programme in its own code cell.



Layout is subject to change…



\noindent\sphinxincludegraphics[width=2518\sphinxpxdimen,height=1592\sphinxpxdimen]{{nbev3devsim_overview}.png}

An expanded range of predefined worlds is available that can be loaded into the simulator, as image files, from a drop down menu. (Source code for generating the background image files is also available in a notebook in the \sphinxcode{\sphinxupquote{backgrounds/}} directory.) When some worlds are loaded in, the robot’s initial (default) location in that world is also specified; other robot settings, such as the positioning of the sensors, may also be initialised when a particular backgound is loaded.

As in \sphinxcode{\sphinxupquote{ev3devsim}}, obstacles can be added to a world using a configuration file opened by clicking the \sphinxcode{\sphinxupquote{Obstacles}} button. The simulated robot is also still configured via a configuration menu.

The simulated robot can be dragged and placed on the simulated background and moved to a specifed location via the \sphinxcode{\sphinxupquote{Move}} button (the target co\sphinxhyphen{}ordinates are updated when the robot is dragged to a new location). A new \sphinxcode{\sphinxupquote{Reset}} button wil move the robot back to it’s default location in the world.

\sphinxstylestrong{{[}TO DO \sphinxhyphen{} would also be useful to be able to rotate the robot?{]}}


\subsubsection{2.1 Activity: Running a program}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02-nb3devsim:2.1-Activity:-Running-a-program}}
QUIck demo \sphinxhyphen{} get a feel for the simulator, even the \sphinxcode{\sphinxupquote{ev3devsim}} one? Or maybe provide this via simple static demos as standalone HTML files? Or actually demo \sphinxcode{\sphinxupquote{nbev3devsim}} here?




\subsection{Move robot forward}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02-nb3devsim:Move-robot-forward}}
from ev3dev2.motor import MoveSteering, OUTPUT\_B, OUTPUT\_C

motor\_pair = MoveSteering(OUTPUT\_B, OUTPUT\_C)


\subsection{Move robot forward for 3 seconds}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02-nb3devsim:Move-robot-forward-for-3-seconds}}
motor\_pair.on\_for\_seconds(steering=0, speed=50, seconds=3)



TO DO \sphinxhyphen{} WE MAY NOT NEED THIS IF WE WORK IN THE NOTEBOOK VIA A WIDGET

Save the programme with a meaningful file name (for example, \sphinxcode{\sphinxupquote{move\_a\_robot.py}}) and clear the programme editor by deleting all the contents from it. If you \sphinxcode{\sphinxupquote{Run}} the (non\sphinxhyphen{}existent) programme, the robot should not move.

Load the file you saved back into the programme window, and run it again. This time the robot should move for 3 seconds again.

TO DO \sphinxhyphen{} LINE NUMBER OPTIONS IN EDITOR?

It is possible to operate the simulated robot in ‘show trail’ or ‘pen\sphinxhyphen{}down’ mode. This enables you to see the path the robot follows.

Check the \sphinxcode{\sphinxupquote{Show trail}} button in the simulator. Run the program again to see the robot’s trail.

TO DO \sphinxhyphen{} keyboard shortcuts would be useful.

TO DO \sphinxhyphen{} a simulator run status indicator would be useful.


\subsubsection{2.2 The Program window}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02-nb3devsim:2.2-The-Program-window}}
So far we have taken a very quick look at how to download programmes from a notebook code cell and run them in the simulator.

the \sphinxcode{\sphinxupquote{Program editor}} and \sphinxcode{\sphinxupquote{Simulator}} windows. In RoboLab Session 2 there will be a much more detailed discussion of computer programs and the principles behind how they work, and the contents of these windows will become clearer. For now let’s look again at the \sphinxcode{\sphinxupquote{Program}} window as it relates to the \sphinxcode{\sphinxupquote{Move\_a\_robot}} program, to see the essential elements of the program and why the robot behaves as it does.

If you don’t already have the \sphinxcode{\sphinxupquote{move\_a\_robot.py}} program open, reopen it now.

The \sphinxcode{\sphinxupquote{move\_a\_robot.py}} program is displayed in the \sphinxcode{\sphinxupquote{Program}} window as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Move robot forward}


\PYG{k+kn}{from} \PYG{n+nn}{ev3dev2}\PYG{n+nn}{.}\PYG{n+nn}{motor} \PYG{k+kn}{import} \PYG{n}{MoveSteering}\PYG{p}{,} \PYG{n}{OUTPUT\PYGZus{}B}\PYG{p}{,} \PYG{n}{OUTPUT\PYGZus{}C}

\PYG{n}{motor\PYGZus{}pair} \PYG{o}{=} \PYG{n}{MoveSteering}\PYG{p}{(}\PYG{n}{OUTPUT\PYGZus{}B}\PYG{p}{,} \PYG{n}{OUTPUT\PYGZus{}C}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Move robot forward for 3 seconds}
\PYG{n}{motor\PYGZus{}pair}\PYG{o}{.}\PYG{n}{on\PYGZus{}for\PYGZus{}seconds}\PYG{p}{(}\PYG{n}{steering}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{speed}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{seconds}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

The program may look a bit cryptic to start with, but it is built up from some very simple steps.

The \sphinxcode{\sphinxupquote{\#}} character at the start of a line is a \sphinxstyleemphasis{line comment} marker that tells the simulator to ignore the rest of the line. This provides a way of putting non\sphinxhyphen{}program text into programs to make the program more readable. The first comment just gives a title describing the program.

The next line, starting \sphinxcode{\sphinxupquote{from ev3dev2.motor import}} tells the programme to \sphinxstyleemphasis{import} some items \sphinxstyleemphasis{from} the \sphinxcode{\sphinxupquote{ev3dev2.motor}} Python package. The import statement commands make additional commands available to our programme that are not defined as part of the basic Python language. In this case, the items define the various motor output ports and a simple programme command that can turn the motors on for a specified time.

The \sphinxcode{\sphinxupquote{OUTPUT\_B}} and \sphinxcode{\sphinxupquote{OUTPUT\_C}} items represent fixed constant identifier labels. The underlying simulator predefines these values so that they refer to the simulated motor outputs used by the simulator.

The \sphinxcode{\sphinxupquote{motor\_pair = MoveSteering(OUTPUT\_B, OUTPUT\_C)}} line associates a \sphinxcode{\sphinxupquote{motor\_pair}} name or label (also known as an \sphinxstyleemphasis{identifier}) with a control block that implements a steering wheel style controller (\sphinxcode{\sphinxupquote{MoveSteering}}); this steering controller uses the two motors on the specified outputs to steer the robot. The controller expects two values passed to it in the form \sphinxcode{\sphinxupquote{MoveSteering(LEFT\_WHEEL\_OUTPUT, RIGHT\_WHEEL\_OUTPUT)}}. These two values are then used to \sphinxstyleemphasis{configure} the output ports used by
the steering block so that they can deliver power to the motors.

Once configured, the \sphinxcode{\sphinxupquote{motor\_pair}} can be told to turn on the motors for a specified period of time (\sphinxcode{\sphinxupquote{motor\_pair.on\_for\_seconds}}).

Note that you can use the underscore character as part of a name to make things clearer, but you must not use spaces or other punctuation when creating an identifier. For example, \sphinxcode{\sphinxupquote{motor\_pair}} can be recognised as a single name, but \sphinxcode{\sphinxupquote{motor pair}} would be treated as two names (\sphinxcode{\sphinxupquote{motor}} and \sphinxcode{\sphinxupquote{pair}}) and result in an error. You are free to make up names as you wish as long as they meet these simple rules. However, some names are already reserved for use as program commands and you must also
avoid these names.

When telling the steering controller to turn on the motors for a specified time, we need to provide it with three essential pieces of information:
\begin{itemize}
\item {} 
a \sphinxcode{\sphinxupquote{steering}} value, which might be though of as a “steering wheel” angle in degrees for the robot; the 0 degrees angle means drive straight ahead;

\item {} 
a \sphinxcode{\sphinxupquote{speed}} value, which is the speed at which the wheels turn;

\item {} 
a \sphinxcode{\sphinxupquote{seconds}} duration which specifies how long the simulated motors powering the wheels should be turned on for.

\end{itemize}

All three values are required to move the robot.

To see all of this working, run the program again.


\subsection{The \sphinxstyleliteralintitle{\sphinxupquote{ev3devsim}} Simulator}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02_ev3devsim_simulator_overview:The-ev3devsim-Simulator}}\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02_ev3devsim_simulator_overview::doc}}
An extension of the \sphinxcode{\sphinxupquote{ev3devsim}} robot simulator will be the focus of many of the programming activities in this block. \sphinxcode{\sphinxupquote{ev3devsim}} itself was inspired by (\sphinxcode{\sphinxupquote{ev3dev}}){[}\sphinxcode{\sphinxupquote{https://www.ev3dev.org/}}{]}, \sphinxstyleemphasis{“a Debian Linux\sphinxhyphen{}based operating system that runs on several LEGO® MINDSTORMS compatible platforms including the LEGO® MINDSTORMS EV3 and Raspberry Pi\sphinxhyphen{}powered BrickPi.”}

Lego EV3 educational robots are widely used in all levels of education. For example, they are used in the Open University residential school course \sphinxstyleemphasis{T176 Engineering: professions, practice and skills 1}.

Low level functions provided by the \sphinxcode{\sphinxupquote{ev3dev}} operating system are “wrapped” by the \sphinxhref{https://github.com/ev3dev/ev3dev-lang-python}{ev3dev\sphinxhyphen{}lang\sphinxhyphen{}python} Python 3 package. This means that a LEGO EV3 robot running the \sphinxcode{\sphinxupquote{ev3dev}} operating system can be programmed using Python code.

The \sphinxcode{\sphinxupquote{ev3devsim}} package implements a cut down version of the {[}\sphinxcode{\sphinxupquote{ev3dev\sphinxhyphen{}lang\sphinxhyphen{}python}}{]} library to control a browser based, 2D\sphinxhyphen{}simulated robot. The \sphinxcode{\sphinxupquote{ev3devsim}} Python codes runs in a Skulpt interpreter (a browser based Python interpreter) to control a Javascript powered robot simulator.

The original \sphinxcode{\sphinxupquote{\textasciigrave{}ev3devsim}} \textless{}\sphinxurl{https://github.com/QuirkyCort/ev3dev-sim}\textgreater{}\textasciigrave{}\_\_ simulator ran as a standalone web application that could be run, even in an offline mode, using just a web browser (\sphinxhref{https://www.aposteriori.com.sg/Ev3devSim/index.html}{try it here}).

{[}\sphinxincludegraphics[width=1618\sphinxpxdimen,height=1470\sphinxpxdimen]{{EV3DEV_Python_Simulator}.png}

Program code is entered into the editor window and run by clicking the simulator \sphinxstyleemphasis{Run} button and halts if there is an error or when the \sphinxstyleemphasis{Stop} button is pressed. An output window display messages sent from the program, such as sensor log values, as well as error messages if the programme throws an error when it is run.

Program files can be saved from, and loaded into the the program editor.

A range of predefined worlds can be loaded into the simulator, as image files, from a drop down menu.

Obstacles can be added to a world using a configuration file opened by clicking the \sphinxcode{\sphinxupquote{Obstacles}} button.

The robot can be configured via a configuration menu.

The robot can be moved to a specifed location y speficifying target location oc\sphinxhyphen{}ordinates and clicking \sphinxcode{\sphinxupquote{Move}}.

The \sphinxcode{\sphinxupquote{\textasciigrave{}nbev3devsim}} \textless{}\sphinxurl{https://github.com/innovationOUtside/nbev3devsim}\textgreater{}\textasciigrave{}\_\_ package builds on the original \sphinxcode{\sphinxupquote{ev3devsim}} to provide an \sphinxcode{\sphinxupquote{ipywidget}} that embeds the simulator in a Jupyter notebook and allows it to be programmed from notebook code cells. Sensor data logged within the simulator can be exported to the notebook’s own Python environment and analysed using the full power of Python’s wide range of charting and data analysis packages.

Whilst the original \sphinxcode{\sphinxupquote{ev3devsim}} simulator runs without any software requirements other than a modern web browser, the \sphinxcode{\sphinxupquote{nbev3devsim}} approach does require the availability of a Jupyter notebook environment. Although this increases the complexity of the software environment, it does provide several benefits:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
instructional material can be provided within a notebook to support each programming activity;

\item {} 
data retrieved from the simulator can be analysed and charted in the notebook kernel context (for example, using Python or R);

\item {} 
the notebook environment provides a read / write environment within which a learner can make their own notes and annotations, as well as keep a record of the various steps they took to develop any particular robot control programme.

\end{enumerate}


\subsection{The EV3 “Brick”}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02_ev3devsim_simulator_overview:The-EV3-_u201cBrick_u201d}}
The physical EV3 controller is capable of supporting four motor outputs referred to as \sphinxcode{\sphinxupquote{OUTPUT A}}, \sphinxcode{\sphinxupquote{OUTPUT B}}, \sphinxcode{\sphinxupquote{OUTPUT C}} and \sphinxcode{\sphinxupquote{OUTPUT D}}. In the simulator, we define a simple two wheeled differential drive robout using two motors configured as follows:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{OUTPUT B}}: left motor;

\item {} 
\sphinxcode{\sphinxupquote{OUTPUT C}}: right motor.

\end{itemize}

THe EV3 brick also support four input ports to which four different, independent sensors can be attached. These range from touch sensors, to light sensors, infrared sensors, ultrasonic sensors and even gyroscopes.

The \sphinxcode{\sphinxupquote{ev3devsim}} simulator this simulates simple robots such as ones that can be built with LEGO Mindstorms.

\sphinxstylestrong{TO DO: this all needs updating, eg with image assets from T176 presentation.}

In fact, RobotLab was originally designed to work with LEGO Mindstorms RCX robots. Robots as simple as this are very useful for getting hands\sphinxhyphen{}on experience with robotics, but naturally they have some limitations compared with more sophisticated (and complex) robot systems. Some of the features of RobotLab and Simon will make more sense if you know a little bit about a simple robot system such as the LEGO Mindstorms RCX kit.





Note: LEGO’s more recent Mindstorms NXT kits differ from the RCX version described here





The robot in Figure 2.2 is built around the LEGO Mindstorms RCX ‘brick’ which is shown in more detail in Figure 2.3. Inside the RCX brick there is a microprocessor and other circuitry. Think of it as a small computer. Built into the brick are three ‘sensor input ports’ labelled 1, 2 and 3, and three ‘actuator output ports’ labelled A, B and C, which are capable of powering motors.

\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f021}.jpg}

Figure 2.3 The RCX controller ‘brick’

The RCX controller ‘brick’, seen from above. This is a large piece of yellow Lego, about 8 x 14 studs in size. At the centre is a control panel with a small LCD screen surrounded by four buttons: these are labelled On\sphinxhyphen{}Off, Run, Prgm (Program) and View. Above the control panel are three sensor input ports, labelled 1, 2, 3. These take the form of 2 × 2 studs which are partly metallic. Below the control panel are three actuator output ports, labelled A, B, C. These also are 2 × 2 studs which are
partly metallic.

The \sphinxstyleemphasis{ports} are interfaces to the external world. Sensors can be attached to the input ports, allowing information about the environment to enter the computer. Motors and other actuators can be attached to the output ports, and the brick can switch them on and off and control their direction and power.

RobotLab assumes that the simulated robot works like an RCX brick. This means that RobotLab needs to know what kinds of sensors and actuators are being used, and how the (simulated) RCX is ‘configured’. You will see how this is done later.

Although I have described the simulated robot in terms of a simple Lego robot, similar considerations would apply to other robotics systems. The control subsystem of any robot is usually flexible and designed to be configured with a variety of sensors and actuators.

\noindent\sphinxincludegraphics[width=4608\sphinxpxdimen,height=2592\sphinxpxdimen]{{nogbad_ev3}.jpg}

{[}Credit: Nigel Gibson / @nogbad{]}


\subsection{Simulator Overview}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02_ev3devsim_simulator_overview:Simulator-Overview}}
The \sphinxcode{\sphinxupquote{ev3devsim}} simulator allows robots to be configured using various components on specific input and output ports:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{OUTPUT\_B}}: left motor (state can be running or blank, not ramping, holding, overloaded, or stalled; stop action is ignored and the robot always stops instantly; \sphinxcode{\sphinxupquote{SpeedPercent}}, \sphinxcode{\sphinxupquote{SpeedNativeUnits}}, \sphinxcode{\sphinxupquote{SpeedRPS}}, \sphinxcode{\sphinxupquote{SpeedRPM}}, \sphinxcode{\sphinxupquote{SpeedDPS}}, \sphinxcode{\sphinxupquote{SpeedDPM}} are all defined, as are \sphinxcode{\sphinxupquote{\textasciigrave{}MotorSet}} \textless{}\sphinxurl{https://ev3dev-lang.readthedocs.io/projects/python-ev3dev/en/stable/motors.html\#motor-set}\textgreater{}\textasciigrave{}\_\_,
\sphinxcode{\sphinxupquote{\textasciigrave{}MoveTank}} \textless{}\sphinxurl{https://ev3dev-lang.readthedocs.io/projects/python-ev3dev/en/stable/motors.html\#move-tank}\textgreater{}\textasciigrave{}\_\_ and \sphinxcode{\sphinxupquote{\textasciigrave{}MoveSteering}} \textless{}\sphinxurl{https://ev3dev-lang.readthedocs.io/projects/python-ev3dev/en/stable/motors.html\#move-steering}\textgreater{}\textasciigrave{}\_\_ motor groups);

\item {} 
\sphinxcode{\sphinxupquote{OUTPUT C}}: right motor;

\end{itemize}

The simulated robot also supports a range of sensors:
\begin{itemize}
\item {} 
an ultrasonic sensor (\sphinxcode{\sphinxupquote{UltrasonicSensor}}) that can be used to detect obstacles ahead {[}TO DO \sphinxhyphen{} CHECK{]} of the sensor. “In an actual ultrasonic sensor, if the angle of incident is too steep, the sound gets reflected away from the sensor resulting in no reading. We try to replicate this by providing readings only if the angle of incident is no more than 50 degrees. The slow update rate of an actual ultrasonic sensor is simulated; readings are only updated around 10 times per sec.” \textless{}\sphinxhyphen{} from the
docs

\item {} 
one or more downward facing light / colour sensors (\sphinxcode{\sphinxupquote{ColorSensor}}) that can be used to sense coloured readings on the world canvas directly below the sensor; sensors give readings of between 0..255.

\item {} 
a gyroscope sensor (\sphinxcode{\sphinxupquote{GyroSensor}}) that measures the angle of the robot; the angle is measure in ??. A gyro reading of 0 corresponds to ??

\end{itemize}

The sensors are available on predefined sensor inut ports. The ultrasonic and color sensors are mounted at default positions on the robot, although the position can be reconfigured using the robot configuration file:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{INPUT 1}} : ultrasonic sensor; by default, this is mounted \sphinxstyleemphasis{front and center} on the robot; \sphinxhref{https://ev3dev-lang.readthedocs.io/projects/python-ev3dev/en/stable/sensors.html\#ultrasonic-sensor}{ultrasonic sensor} (readings provided for angles of incidence up to 50 degrees; slow update rate of an actual ultrasonic sensor is simulated with reading updates approximately every 0.1s);

\item {} 
\sphinxcode{\sphinxupquote{INPUT 2}} : color sensor by default, mounted \sphinxstyleemphasis{front and left} on the robot; left \sphinxhref{https://ev3dev-lang.readthedocs.io/projects/python-ev3dev/en/stable/sensors.html\#color-sensor}{color sensor} (raw values ranges between 0 to 255; ambient\_light\_intensity will always return 0; color and color\_name may not give the same value as the actual sensor);

\item {} 
\sphinxcode{\sphinxupquote{INPUT 3}} : color sensor; by default, mounted \sphinxstyleemphasis{front and right} on the robot; \sphinxcode{\sphinxupquote{INPUT 3}}: right color sensor;

\item {} 
\sphinxcode{\sphinxupquote{INPUT 4}} : gyro sensor; fixed location in the center of the robot; \sphinxhref{https://ev3dev-lang.readthedocs.io/projects/python-ev3dev/en/stable/sensors.html\#gyro-sensor}{gyro sensor}.

\end{itemize}

In the T176 residential school, several activities are defined using different floorplans, such a circular racing track marked out a flat surface that the robots must navigate round as quickly as possible. Such activities are essentially “two dimensional” so you should not feel that just because the simulator we are using is essentially a two dimensional simulator you are not doing a realistic robot programming activity.

(In actual fact, the simulator is more like 2.5D simulator in that it supports an obstacle layer that sits above the plane of the background and within which walls and other smaller obstacles can be detected by a simulated ultrasonic sensor. Note that to keep the “world physics” provided by the simulation as simple as possible, the obstacles do not, in fact, impede the progress of the simulated robot.

\sphinxstylestrong{TO DO \sphinxhyphen{} optionally impede progrgess if robot encouters wall or obstacle.}

The simulated world can be loaded with a selection of predefined background layouts, or uploaded custom layouts, can be used as the basis of specific robot programming tasks or challenges. (Layouts are sized 2362 by 1143 pixels, which corresponds to the size of a First Lego League / World Robot Olympiad (WRO) field mat, with 1 pixel representing 1mm.)

The colour sensors can obtain readings from traces on canvas layer that loads the floor mat; the ultrasonic sensor can sense obstacles on the mat although these are not physical objects that impede the progress of the robot.

\sphinxincludegraphics[width=200\sphinxpxdimen]{{EV3DEV_Python_Simulator_robot}.png}


\subsection{Robot Configuration}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_02_ev3devsim_simulator_overview:Robot-Configuration}}
The simulated robot itself is configured according to a simple set\sphinxhyphen{}up script that defines:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{wheeldiameter}}: the diameter of the robot’s wheels (default: \sphinxcode{\sphinxupquote{56}} mm);

\item {} 
\sphinxcode{\sphinxupquote{wheelSpacing}}: the distance between the robot’s wheels; essentially, this defines the “width” of the robot (default: \sphinxcode{\sphinxupquote{180}} mm);

\item {} 
\sphinxcode{\sphinxupquote{back}}: the distance to the back of the robot from the front; essentially, this defines the “height” of the robot (default: \sphinxcode{\sphinxupquote{120}} mm from the centreline between the wheels (TO DO \sphinxhyphen{} check));

\item {} 
\sphinxcode{\sphinxupquote{weight}}: the weight of the robot (default: \sphinxcode{\sphinxupquote{medium}}) TO DO \sphinxhyphen{} does this affect physics at all?

\item {} 
\sphinxcode{\sphinxupquote{sensor1}}: the physical location on the robot of the color sensor on \sphinxcode{\sphinxupquote{INPUT 2}} (\sphinxcode{\sphinxupquote{sensor1}}, by default registered at location \sphinxcode{\sphinxupquote{(\sphinxhyphen{}20, 30)}} from centre front of the robot and with diameter \sphinxcode{\sphinxupquote{20}};

\item {} 
\sphinxcode{\sphinxupquote{sensor2}}: the physical location on the robot of the color sensor on \sphinxcode{\sphinxupquote{INPUT 3}} at location \sphinxcode{\sphinxupquote{(20, 30)}} and with diameter \sphinxcode{\sphinxupquote{20}};

\item {} 
\sphinxcode{\sphinxupquote{ultrasonic}}: the orientation and physical location on the robot of the ultrasonic sensor on \sphinxcode{\sphinxupquote{INPUT 1}} (by default, in the front center of the robot at (\sphinxcode{\sphinxupquote{0}}, \sphinxcode{\sphinxupquote{20}}) with angle \sphinxcode{\sphinxupquote{0}} degrees relative to the front/back robot center\sphinxhyphen{}line).

\end{itemize}

The configuration can be updated via a pop\sphinxhyphen{}up window in the simulator.

\noindent\sphinxincludegraphics[width=1262\sphinxpxdimen,height=736\sphinxpxdimen]{{00_01_EV3DEV_Python_Simulator-config_robot}.png}

The robot configuration file is a JSON (Javascript Object Notation) object definition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
  \PYG{l+s+s2}{\PYGZdq{}wheeldiameter\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{56}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}wheelSpacing\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{180}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}back\PYGZdq{}}\PYG{o}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{120}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}weight\PYGZdq{}}\PYG{o}{:} \PYG{l+s+s2}{\PYGZdq{}medium\PYGZdq{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}sensor1\PYGZdq{}}\PYG{o}{:} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}x\PYGZdq{}}\PYG{o}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{20}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}y\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{30}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}diameter\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{20}
  \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}sensor2\PYGZdq{}}\PYG{o}{:} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}x\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{20}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}y\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{30}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}diameter\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{20}
  \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}ultrasonic\PYGZdq{}}\PYG{o}{:} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}x\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{0}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}y\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{10}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}angle\PYGZdq{}}\PYG{o}{:} \PYG{l+m+mf}{0}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}



In \sphinxcode{\sphinxupquote{nbev3devsim}}, there is the possibility of moving the set up either to a notebook code cell, a to simple \sphinxcode{\sphinxupquote{ipywidget}} configurator, or via simulator magic parameters. This is currently on the long\sphinxhyphen{}list of to do items. The current pop up works fine.





{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from nbev3devsim import ev3devsim\PYGZus{}nb as eds
import jp\PYGZus{}proxy\PYGZus{}widget

\PYGZsh{}Load the nbtutor extension
\PYGZpc{}load\PYGZus{}ext nbtutor

\PYGZsh{}https://github.com/AaronWatters/jp\PYGZus{}doodle/blob/master/notebooks/misc/JQueryUI\PYGZpc{}20dialogextend\PYGZpc{}20plugin\PYGZpc{}20demo.ipynb
\PYGZsh{}Load and initialise the jquery.dialogextend package

cdn\PYGZus{}url = \PYGZdq{}https://cdn.jsdelivr.net/npm/binary\PYGZhy{}com\PYGZhy{}jquery\PYGZhy{}dialogextended@1.0.0/jquery.dialogextend.js\PYGZdq{}
cdn\PYGZus{}url = eds.get\PYGZus{}file\PYGZus{}path(\PYGZsq{}js/jquery.dialogextend.js\PYGZsq{})
module\PYGZus{}id = \PYGZdq{}dialogExtend\PYGZdq{}

\PYGZsh{} Load the module using a widget (any widget \PYGZhy{}\PYGZhy{} the module loads to the global jQuery object).
loader = jp\PYGZus{}proxy\PYGZus{}widget.JSProxyWidget()

\PYGZsh{} Configure the module to be loaded.
loader.require\PYGZus{}js(module\PYGZus{}id, cdn\PYGZus{}url)

\PYGZsh{} Load the module
loader.js\PYGZus{}init(\PYGZdq{}\PYGZdq{}\PYGZdq{}
    element.requirejs([module\PYGZus{}identifier], function(module\PYGZus{}value) \PYGZob{}
        //element.html(\PYGZdq{}loaded \PYGZdq{} + module\PYGZus{}identifier + \PYGZdq{} : \PYGZdq{} + module\PYGZus{}value);
    \PYGZcb{});
\PYGZdq{}\PYGZdq{}\PYGZdq{}, module\PYGZus{}identifier=module\PYGZus{}id)
loader

\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from nbev3devsim import ev3devsim\PYGZus{}nb as eds

\PYGZsh{}Reset the notebook style
from IPython.core.display import display, HTML, Javascript

\PYGZsh{}display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} resize:vertical; border: 5px solid;  width: 300px; resize: horizontal; overflow: auto; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))
display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:50\PYGZpc{}; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))

\PYGZsh{}Launch the simulator
from nbev3devsim import ev3devsim\PYGZus{}nb as eds
\PYGZpc{}reload\PYGZus{}ext nbev3devsim

roboSim = eds.Ev3DevWidget()

roboSim.element.dialog();


roboSim.js\PYGZus{}init(\PYGZdq{}\PYGZdq{}\PYGZdq{}
element.dialog(\PYGZob{} \PYGZdq{}title\PYGZdq{} : \PYGZdq{}Robot Simulator\PYGZdq{} \PYGZcb{}).dialogExtend(\PYGZob{}
        \PYGZdq{}maximizable\PYGZdq{} : true,
        \PYGZdq{}dblclick\PYGZdq{} : \PYGZdq{}maximize\PYGZdq{},
        \PYGZdq{}icons\PYGZdq{} : \PYGZob{} \PYGZdq{}maximize\PYGZdq{} : \PYGZdq{}ui\PYGZhy{}icon\PYGZhy{}arrow\PYGZhy{}4\PYGZhy{}diag\PYGZdq{} \PYGZcb{}\PYGZcb{});
\PYGZdq{}\PYGZdq{}\PYGZdq{})

display(roboSim)
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{o}{\PYGZpc{}}\PYG{o}{\PYGZpc{}}\PYG{n+nx}{javascript}
\PYG{c+c1}{//This allows us to resize this view}
\PYG{c+c1}{//Click on the right hand edge to drag}
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}notebook\PYGZhy{}container\PYGZdq{}} \PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{resizable}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n+nx}{ghost}\PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}load\PYGZus{}ext nbtutor
\PYGZpc{}load\PYGZus{}ext nbev3devsim
\end{sphinxVerbatim}
}


\subsection{3 Some features of RoboLab}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:3-Some-features-of-RoboLab}}\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour::doc}}
In this section you will run some other RoboLab programs. The purpose is for you to observe what happens, to see some of the features of RoboLab, and to begin to see how other behaviours are controlled by the programs. This section is intended to give you an overview, and you are certainly not expected to remember the details.


\subsubsection{3.1 Activity: Keeping a robot in an area}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:3.1-Activity:-Keeping-a-robot-in-an-area}}
This activity demonstrates how to keep a robot inside a particular area bounded by a boxed area marked out on the floor of the world.

Load the simulator package and then load and display the simulator widget:

Select the \sphinxcode{\sphinxupquote{Loop}} background which loads the robot in to the centre of a large rectangle drawn with thick black lines.

The following \sphinxcode{\sphinxupquote{Stay\_inside}} program causes the robot moves forwards until its light sensor detects the black contour, at which point the robot reverses direction. When it encounters the contour again it changes direction. In this way the robot shuttles backwards and forwards inside the contour indefinitely.

Run the code cell to load the program into the simulator, then click on the simulator \sphinxstyleemphasis{Run} button; hhen you are ready to stop the program, click on the simulator \sphinxstyleemphasis{Stop} button.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

\PYGZsh{} Stay inside
tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

while True:
    print(\PYGZsq{}Light\PYGZus{}left: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity))
    if colorLeft.reflected\PYGZus{}light\PYGZus{}intensity \PYGZlt{} 40:
        tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(\PYGZhy{}50), SpeedPercent(\PYGZhy{}50), 2)
        \PYGZsh{} drive in a turn for 2 rotations of the outer motor
        tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 2)
        tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))
\end{sphinxVerbatim}
}

At the start of the program, a \sphinxcode{\sphinxupquote{\#}} sign identifies the line as a comment line, in this case giving a very concise statement of the objective of the programme. Comments are “free text” areas that are not exeucted as lines of Python code. As such, they can be used to provide annotations or explanations of particular parts of the programme, or “comment out” lines of code that are unnecessary.

The program starts by using a “tank drive” to drive the robot forwards at about half it’s full speed (the left wheel and the right wheen are both powered on at 50\% of their maximum speed).

The \sphinxcode{\sphinxupquote{while True:}} command means \sphinxstyleemphasis{do everything that follows for ever (or until the user stops the program)}. The \sphinxcode{\sphinxupquote{:}} is \sphinxstyleemphasis{required} and it defines what to do if the tested condition evaluates as true.

The next line is indented, and starts the definition of a code block, each line of which will be executed in turn. The lines of code that define the code block are indented to the same level. If the condition evaulated by the \sphinxcode{\sphinxupquote{while}} statement was not true, then the code block would not be executed.

The \sphinxcode{\sphinxupquote{print(\textquotesingle{}Light\_left: \textquotesingle{} + str(colorLeft.reflected\_light\_intensity))}} command prints the current value of the left light sensor, which is reading the “reflected light intensity” to the output display window. As you will see later, this value can also be viewed via a dynamically updated chart, as well as analysed “offline” in the Python notebook when the simulation run has finished.

The next line in the code block, \sphinxcode{\sphinxupquote{if colorLeft.reflected\_light\_intensity \textless{} 40:}}, compares a specific sensor reading, interpreted in a particular way, to a particular value (100). If the value is below that threshold, as it is when the robot is over the black like, the programme moves on to a new code block defined by lines of code that are further indented.

On the first line of code in that new code block, the robot drives \sphinxstyleemphasis{backwards} at half speed for 2 rotations of the wheels (\sphinxcode{\sphinxupquote{tank\_drive.on\_for\_rotations(SpeedPercent(\sphinxhyphen{}50), SpeedPercent(\sphinxhyphen{}50), 2)}}). (According to the \sphinxhref{https://python-ev3dev.readthedocs.io/en/ev3dev-stretch/motors.html\#ev3dev2.motor.MoveTank.on\_for\_rotations}{documentation}, \sphinxstyleemphasis{if the left speed is not equal to the right speed (i.e., the robot will turn), the motor on the outside of the turn will rotate for the full rotations
while the motor on the inside will have its requested distance calculated according to the expected turn}).

After the robot moves backwards, there is a comment line suggesting what the next executed line of code does (\sphinxcode{\sphinxupquote{\# drive in a turn for 2 rotations of the outer motor}}) and then the robot turns on the spot (\sphinxcode{\sphinxupquote{tank\_turn.on\_for\_rotations(\sphinxhyphen{}100, SpeedPercent(75), 2)}}).

Finally, the robot is set to drive forwards again (\sphinxcode{\sphinxupquote{tank\_drive.on(SpeedPercent(50), SpeedPercent(50))}}) and the sequence is repeated, with the programme control flow looping back to the while statement and then working through each step in turn again. While the sensor reading is above 100, the robot keeps going. Every time it “sees” the black contour it reverses the direction of the motors, and then turns ebfore driving forwards again. In this way the simulated robot shuttles backwards and
forwards, staying inside the area defined by the contour.

How do you think the simulated robot in this activity compares with a real robot?


\paragraph{Viewing the stay inside test on a real robot}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Viewing-the-stay-inside-test-on-a-real-robot}}


TO DO: the programmes should work on an EV3 running \sphinxcode{\sphinxupquote{\textasciigrave{}python\sphinxhyphen{}ev3dev}} \textless{}\sphinxurl{https://python-ev3dev.readthedocs.io/}\textgreater{}\textasciigrave{}\_\_. A \sphinxhref{https://github.com/ev3dev/vscode-ev3dev-browser}{Visual Studio Code extension for browsing ev3dev devices} seems to provide an environment for running the \sphinxcode{\sphinxupquote{python\sphinxhyphen{}ev3dev}} code on a real robot which is perhaps something worth exploring. \sphinxstyleemphasis{Note that VS Code can also run notebooks, although I’m not sure if the simulation widget will run in that environment.}



The following video clip shows a simple Lego robot executing the \sphinxcode{\sphinxupquote{Stay\_inside}} program discussed above. You will notice that the real robot does not shuttle backwards and forwards as precisely as the simulated robot. Real robots are ‘noisy’, but not just in terms of the sound they make. There is also ‘noise’ in their mechanical gearing and control: the motors don’t go at precisely the expected speed, the gears may not mesh perfectly, the wheels may slip or skid, and the sensors do not give
instantaneous or perfect readings.

In other words, real robots may have sloppy and relatively unpredictable mechanisms so that the same control commands from the same initial position may result in a variety of outcomes. For this reason, the RobotLab simulator has a noise feature that allows you to set random variations to the motor speeds and sensor readings. This ‘noise’ makes the simulated robot behave more realistically. It will be used in later Robot Lab sessions.


\subsubsection{Using Less Magic…}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Using-Less-Magic_u2026}}
In the previous program, the \sphinxcode{\sphinxupquote{tank\_drive}} and \sphinxcode{\sphinxupquote{tank\_turn}} elements are predefined by our use of the \sphinxcode{\sphinxupquote{\%\%sim\_magic\_preloaded}} magic. This really is a bit like magic, because it allows us to write Python code that would not ordinarliy be valid code. The magic itself defines some essential Python code that is \sphinxstyleemphasis{prepended} (that is, added to the start of) out programme code before it is downloaded to the simulated robot.

The following code cell uses a slightly less powerful magic, \sphinxcode{\sphinxupquote{\%\%sim\_magic\_imports}}, that still masks some of the complexity in creating a valid Python programme although in this case it does require you to define the \sphinxcode{\sphinxupquote{tank\_turn}} and \sphinxcode{\sphinxupquote{tank\_move}} statements in turns of slightly lower level building blocks.

As with the \sphinxcode{\sphinxupquote{Move\_a\_robot}} programme, the \sphinxcode{\sphinxupquote{MoveSteering}} and \sphinxcode{\sphinxupquote{MoveTank}} commands are commands provided the \sphinxcode{\sphinxupquote{ev3dev}} Python package and then configured to use particular outputs on the (simulated) robot (\sphinxcode{\sphinxupquote{OUTPUT\_B}} and \sphinxcode{\sphinxupquote{OUTPUT\_C}}).

In addition, the light sensor is defined using the \sphinxcode{\sphinxupquote{ColorSensor}} command to confgure the sensor attached to \sphinxcode{\sphinxupquote{INPUT\_2}} as a colour sensor. The light sensor is shown as small white circle contained within a grey square on the simulated robot.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}imports

\PYGZsh{} Stay inside
tank\PYGZus{}turn = MoveSteering(OUTPUT\PYGZus{}B, OUTPUT\PYGZus{}C)
tank\PYGZus{}drive = MoveTank(OUTPUT\PYGZus{}B, OUTPUT\PYGZus{}C)

colorLeft = ColorSensor(INPUT\PYGZus{}2)

tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

while True:
    print(\PYGZsq{}Light\PYGZus{}left: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity))
    if colorLeft.reflected\PYGZus{}light\PYGZus{}intensity \PYGZlt{} 40:
        tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(\PYGZhy{}50), SpeedPercent(\PYGZhy{}50), 2)
        \PYGZsh{} drive in a turn for 2 rotations of the outer motor
        tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 2)
        tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))
\end{sphinxVerbatim}
}


\subsubsection{A Complete Python Programme}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:A-Complete-Python-Programme}}
The following code cell shows a fully defined Pyhton program. In this case, a series of “package import” statements appear at the start of the programme. Python packages are code libraries written to support particular activities.

The core Python language includes a variety of packages that are distributed as part of the Python language, but additional packages can be written using core Python langauge elements, \sphinxstyleemphasis{or} Python commands imported from other additional packages, to build every moe powerful commands.

In particular, the Python \sphinxcode{\sphinxupquote{ev3dev}} package provides a range of language constructs that allow us to write a Python programme that can work with a Lego EV3 brick running the \sphinxcode{\sphinxupquote{ev3dev}} operating system, or our \sphinxcode{\sphinxupquote{nbev3devsim}} simulated robot.

As you can see from the code cell below, which uses the minimal \sphinxcode{\sphinxupquote{\%\%sim\_magic}} magic to download just the contents of the cell to the simulator, in this case we \sphinxcode{\sphinxupquote{import}} the custom elements we need \sphinxcode{\sphinxupquote{from}} the \sphinxcode{\sphinxupquote{ev3dev}} Python package that we then make use of in our programme.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic

\PYGZsh{} Stay inside
from ev3dev2.motor import MoveTank, MoveSteering, SpeedPercent, OUTPUT\PYGZus{}B, OUTPUT\PYGZus{}C
from ev3dev2.sensor import INPUT\PYGZus{}1, INPUT\PYGZus{}2, INPUT\PYGZus{}3, INPUT\PYGZus{}4
from ev3dev2.sensor.lego import ColorSensor

tank\PYGZus{}turn = MoveSteering(OUTPUT\PYGZus{}B, OUTPUT\PYGZus{}C)
tank\PYGZus{}drive = MoveTank(OUTPUT\PYGZus{}B, OUTPUT\PYGZus{}C)
colorLeft = ColorSensor(INPUT\PYGZus{}2)

tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

while True:
    print(\PYGZsq{}Light\PYGZus{}left: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity))
    if colorLeft.reflected\PYGZus{}light\PYGZus{}intensity \PYGZlt{} 40:
        tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(\PYGZhy{}50), SpeedPercent(\PYGZhy{}50), 2)
        \PYGZsh{} drive in a turn for 2 rotations of the outer motor
        tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 2)
        tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))
\end{sphinxVerbatim}
}


\subsubsection{3.2 Activity: Investigating sensors}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:3.2-Activity:-Investigating-sensors}}
In this activity you will experiment with a light sensor.



To make it easier to see what’s going on, click on the code cell that is used to display the simulator and use the notebook toolbar up/down arrows to move the cell down to this part of the notebook, closer to the code cells we will be using to download new programmes into the simulator.





We need to think about making a more workable UI, within the constraints of limited time and skill available to spend on that issue right now… Which is to say, suggestions are welcome, but without PRs, they may may well \sphinxcode{\sphinxupquote{\textgreater{} /dev/null}}…



This is similar to the Lego light sensor:

TO DO image: \sphinxstyleemphasis{A Lego light sensor. This is a blue Lego brick, 4 x 2 studs in size with a wire emerging from one end. At the other end, two small lenses are visible. One is clear \textendash{} this is the light sensor itself. Next to it is a red LED which can be used as a light source to illuminate a surface so that the sensor measures light reflected from the surface rather than ambient light levels.}

In the simulator, load in the \sphinxstyleemphasis{Grey bands} backgorund, which displays a white background overlaid by four grey bars of different in intensity, ranging from a pale grey to black.

The simulated robot drives over the background, logging the light sensor data as it does so.

Here’s the complete programme:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic
\PYGZsh{} Sensor\PYGZus{}sim
from ev3dev2.motor import MoveTank, SpeedPercent, OUTPUT\PYGZus{}B, OUTPUT\PYGZus{}C
from ev3dev2.sensor import INPUT\PYGZus{}1, INPUT\PYGZus{}2, INPUT\PYGZus{}3, INPUT\PYGZus{}4
from ev3dev2.sensor.lego import ColorSensor


tank\PYGZus{}drive = MoveTank(OUTPUT\PYGZus{}B, OUTPUT\PYGZus{}C)
colorLeft = ColorSensor(INPUT\PYGZus{}2)

tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

while True:
    print(\PYGZsq{}Colour: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity ))
\end{sphinxVerbatim}
}

We can also use the \sphinxcode{\sphinxupquote{\%\%sim\_magic\_preloaded SIMULATOR}} magic to preload the drive and sensor configurations and references to minimise the clutter in \sphinxstyleemphasis{our} code, whilst remembering that it is still required for the programme to run, and will be loaded in automatically by the magic:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
\PYGZsh{} Sensor\PYGZus{}sim preloaded

tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

while True:
    print(\PYGZsq{}Colour: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity ))
\end{sphinxVerbatim}
}

Download either variant of the program to the simulator and run it, stopping the programme when the robot has gone passed the final black line.

As the programme runs, you should notice that that a sequence of logged data values from the sensor are displayed in the output window. If you scroll up through the display in that window you should notice that the sensor values changed as the robot crossed over each grey line.


\paragraph{SAQ TO DO}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:SAQ-TO-DO}}
What value does the sensor give when the robot is placed on the white background? What sensor values are returned for when the light sensor is over the light grey, medium grey, dark grey and black bands?

Do you notice anything strange about the sensor values, particularly when the robot encounters or leaves a particular band?


\subparagraph{Answer}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Answer}}
\sphinxstyleemphasis{Click the arrow in the sidebar to reveal the answer.}

I get the following readings for the reflected light intensity readings from the light sensor:
\begin{itemize}
\item {} 
white background: \sphinxcode{\sphinxupquote{100}}

\item {} 
light grey band: \sphinxcode{\sphinxupquote{\textasciitilde{}86}}

\item {} 
medium grey band: \sphinxcode{\sphinxupquote{\textasciitilde{}82}}

\item {} 
dark grey band: \sphinxcode{\sphinxupquote{\textasciitilde{}50}}

\item {} 
black band: \sphinxcode{\sphinxupquote{0}}

\end{itemize}

There is some “noise” in the form of intermediate values as the robot goes into and leaves the band. This is because the sensor has a “width” so it may be averaging readings where part of the sensor is over the white background and part of it is over the coloured band.


\subsubsection{Activity \sphinxhyphen{} Viewing the Logged Data \sphinxhyphen{} The Simulator Datalog Chart Display}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Activity---Viewing-the-Logged-Data---The-Simulator-Datalog-Chart-Display}}
As well as displaying the logged data values using the output display, the print messages are parsed and used to extract data values so that they can be displayed on a dynamically updated line chart.

Enable the data charter by clicking the \sphinxstyleemphasis{Show chart} check box in the simulator and then check the \sphinxstyleemphasis{Colour} trace checkbox.

\sphinxstyleemphasis{TO DO \sphinxhyphen{} need a better way to set and handle traces?}

Reset the start location of the robot either by dragging it back to the start or clicking the \sphinxstyleemphasis{Move} button to reset the original location for the current simulator setup.

Run the simulator programme again until the robot has crossed over all the lines, observing how the chart is updated with the live sensor values. Can you see where the robot encounters the different coloured bands? What values are recorded for each band?

From the chart, can you read off the values for each band?


\paragraph{Answer}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:id1}}
\sphinxstyleemphasis{Click the arrow in the sidebar to reveal the answer.}

The following diagram shows the result of showing the real time data logging chart:

As the robot progresses across the bands, the bars that it encounters get progressively darker, so the sensor readings reduce. Between the bands, as the robot crosses the white background, the sensor reading go back up to their initial, maximum reading.

If you hover your cursor over the chart, all the recorded trace values at that x\sphinxhyphen{}position on the chart are displayed. These are the values that were recorded and displayed, taken from the midpoint of the chart, when I ran the experiment.
\begin{itemize}
\item {} 
white background: \sphinxcode{\sphinxupquote{100}}

\item {} 
light grey band: \sphinxcode{\sphinxupquote{86.27451}}

\item {} 
medium grey band: \sphinxcode{\sphinxupquote{82.7451}}

\item {} 
dark grey band: \sphinxcode{\sphinxupquote{50.19608}}

\item {} 
black band: \sphinxcode{\sphinxupquote{0}}

\end{itemize}

\sphinxstyleemphasis{(You may have noticed that the simulation running in a slightly more “stuttery” way than when the chart is not displayed as your computer has to do more work in terms of dynamically updating the chart.)}

\sphinxstyleemphasis{TO DO \sphinxhyphen{} I think the chart may also be checking all the sensor values and perhaps forcing them to be calculated? Need to optimise this to only calculate and plot values that are actually being logged.}

\sphinxstyleemphasis{TO DO \sphinxhyphen{} should we experiment with generating text descriptions of charts, eg as per}\sphinxhref{https://blog.ouseful.info/2016/04/29/first-thoughts-on-automatically-generating-accessible-text-descriptions-of-ggplot-charts-in-r/}{Automatically Generating Accessible Text Descriptions of Charts}\sphinxstyleemphasis{?}


\subsubsection{Viewing the Logged Data \sphinxhyphen{} Uploading the Logged Data to the Notebook}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Viewing-the-Logged-Data---Uploading-the-Logged-Data-to-the-Notebook}}
As well as inspecting the data log values in the simulator output window and via the embedded datalog chart, we can also export the logged data from the simulator into the Python enviornment used by the notebook. This then allows us to analyse and chart the data within a complete Python environment.

\sphinxstyleemphasis{TO DO \sphinxhyphen{} should we have some magic to get data out of the datalog?}

The following code cell shows how to access the datalog from the simulator in the notebook’s Python environment. The \sphinxstyleemphasis{pandas} package is a very powerful package for working with tabular data.

\sphinxstyleemphasis{You can learn more about using pandas from the OpenLearn unit}\sphinxhref{https://www.open.edu/openlearn/science-maths-technology/learn-code-data-analysis/content-section-overview-0?active-tab=description-tab}{“Learn To Code For Data Analysis”}\sphinxstyleemphasis{or as part of the Open University module}\sphinxhref{http://www.open.ac.uk/courses/modules/tm351}{Data management and analysis (TM351)}\sphinxstyleemphasis{.}

Run the following code cell to grab the data from the datalog as a tabular dataset and preview the first few rows from it:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}roboSim.results\PYGZus{}log
import pandas as pd

def get\PYGZus{}dataframe\PYGZus{}from\PYGZus{}datalog(datalog):
    \PYGZdq{}\PYGZdq{}\PYGZdq{}Generate a datafrome from simulator datalog.\PYGZdq{}\PYGZdq{}\PYGZdq{}
    df = pd.DataFrame(datalog)
    if not df.empty:
        df = df.melt(id\PYGZus{}vars=\PYGZsq{}index\PYGZsq{}).dropna()
        df[\PYGZsq{}index\PYGZsq{}] = pd.to\PYGZus{}timedelta(df[\PYGZsq{}index\PYGZsq{}]\PYGZhy{}df[\PYGZsq{}index\PYGZsq{}].min())
    return df

\PYGZsh{}Grab the logged data into a pandas dataframe
df = get\PYGZus{}dataframe\PYGZus{}from\PYGZus{}datalog(roboSim.results\PYGZus{}log)

\PYGZsh{}Preview the first few rows of the dataset
df.head()
\end{sphinxVerbatim}
}

With the data in a \sphinxstyleemphasis{pandas} dataframe, we can then use a variety of tools to generate our own charts from it.

One approach is to use the \sphinxstyleemphasis{seaborn} Python package to create a line chart directly from the dataframe.

By convention, \sphinxstyleemphasis{seaborn} is loaded in and referred to as \sphinxcode{\sphinxupquote{sns}}. The line plot charting function is selected (\sphinxcode{\sphinxupquote{sns.lineplot()}}) and passed the dataframe (\sphinxcode{\sphinxupquote{data=df}}). The \sphinxstyleemphasis{index} column values in the dataframe are assigned to the \sphinxstyleemphasis{x}\sphinxhyphen{}axis (\sphinxcode{\sphinxupquote{x="index"}}) and the \sphinxstyleemphasis{value} column values to the \sphinxstyleemphasis{y}\sphinxhyphen{}axis (\sphinxcode{\sphinxupquote{y="value"}}). The line colour is generated from unique values identified in the \sphinxstyleemphasis{variable} column (\sphinxcode{\sphinxupquote{hue=\textquotesingle{}variable\textquotesingle{}}}).

If we had additional sensors identified using different \sphinxstyleemphasis{variable} values, such as \sphinxstyleemphasis{ultrasonic}, each sensor would have it’s own coloured line trace.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import seaborn as sns
ax = sns.lineplot(x=\PYGZdq{}index\PYGZdq{}, y=\PYGZdq{}value\PYGZdq{}, hue=\PYGZsq{}variable\PYGZsq{}, data=df)
\end{sphinxVerbatim}
}

Note that in passing parameter values to the \sphinxcode{\sphinxupquote{lineplot()}} function, we can use either single or double quotes to identify the column name as a string value. So for example, both \sphinxcode{\sphinxupquote{hue=\textquotesingle{}variable\textquotesingle{}}}, using single quotes (\sphinxcode{\sphinxupquote{\textquotesingle{}}}) and \sphinxcode{\sphinxupquote{hue="variable"}}, using double quotes (\sphinxcode{\sphinxupquote{"}}), are equally valid.

As well generating charts using just the \sphinxstyleemphasis{seaborn} package, we can build up charts from several layers of data display. The following chart is constructed from a seaborn \sphinxcode{\sphinxupquote{FacetGrid}} chart, which generates one line chart per sensor (as identifed from the \sphinxcode{\sphinxupquote{row="variable"}} parameter), and then overplots individual \sphinxcode{\sphinxupquote{x}} markers, one per datapoint, using the a \sphinxcode{\sphinxupquote{matplotlib}} plotting function.



matplotlib is a relatively low level charting library that gives us more control over simple items that make up a chart. The seaborn package is itself built up from simpler matplotlib components.



{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import matplotlib.pyplot as plt

g = sns.FacetGrid(df, row=\PYGZdq{}variable\PYGZdq{}, height=5, aspect=2, sharey=False)
g = g.map(plt.plot, \PYGZdq{}index\PYGZdq{}, \PYGZdq{}value\PYGZdq{}, marker=\PYGZdq{}x\PYGZdq{});
\end{sphinxVerbatim}
}

Starting from the left\sphinxhyphen{}hand side, each blue \sphinxcode{\sphinxupquote{x}} point represents a sensor reading. The white background in the grey bars environment shows as 100 and the solid black line shows as 0.

TO DO \sphinxhyphen{} how do we clear the datalog {[}\sphinxhref{https://github.com/innovationOUtside/nbev3devsim/issues/7}{related issue}{]}:
\begin{itemize}
\item {} 
just on the py side?

\item {} 
on the py side and the js side just from the py side?

\item {} 
just on the js side from the simulator?

\item {} 
on both js and py side from the simulator?

\end{itemize}


\subsubsection{Robots that speak}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Robots-that-speak}}
As well as moving about the simulated world, the robot can also affect the state of the world by making a noise it. In particular, we can get the robot to speak by using a function from the \sphinxcode{\sphinxupquote{playsound}} package (created as a custom package for use in this module in the javascript Skulpt/Pyhton environment): \sphinxcode{\sphinxupquote{playsound.say()}}.

Run the following code cell to download the programme to simulator and then run it in the simulator. Does it say hello?!

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic
\PYGZsh{} Say hello
import playsound

your\PYGZus{}name = \PYGZdq{}TM129 student\PYGZdq{}
playsound.say(\PYGZdq{}Hello there,\PYGZdq{} + your\PYGZus{}name)
\end{sphinxVerbatim}
}

See if you can modify the name string so that the robot says something that sounds more like \sphinxstyleemphasis{tee, em, one, two, nine} rather than \sphinxstyleemphasis{one hundred and twenty nine}. Run the modified code cell to download the programme to the simulator, and then run the programme there to test it.

Can you also get the robot to say hello to you using your own personal name?


\subsubsection{Robots That Count}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Robots-That-Count}}
That’s a good start to gettig the robot to speak, but can we do something more elaborate?

How about counting up from 1 to 5?

The Python \sphinxcode{\sphinxupquote{range()}} function can be used to generate a iterator over a series of integers that cover a certain range:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}range(5)
\end{sphinxVerbatim}
}

We can use a \sphinxcode{\sphinxupquote{for}} loop to iterate through the range, displaying each value within the range using a \sphinxcode{\sphinxupquote{print()}} statement:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}for i in range(5):
    print(i)
\end{sphinxVerbatim}
}

We can also inspect the values by casting the range interator to a list:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}list(range(0,5))
\end{sphinxVerbatim}
}

If we supply just a single value to the \sphinxcode{\sphinxupquote{range()}} function, as in \sphinxcode{\sphinxupquote{range(N)}}, it defines a range that spans from \(0\) to \(N-1\).

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}M = 5

list(range(M))
\end{sphinxVerbatim}
}

If we provide two arguments, \sphinxcode{\sphinxupquote{range(M, N)}}, it defines a range from \(M\) to \(N-1\):

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}M = 5
N = 10

list(range(M, N))
\end{sphinxVerbatim}
}

If we provide \sphinxstyleemphasis{three} arguments, \sphinxcode{\sphinxupquote{range(M, N, S)}}, it spans a range of integeres from \(M\) to \(N-1\) with a step value \(S\) between them:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}M = 0
N = 30
S = 10

list(range(M, N, S))
\end{sphinxVerbatim}
}

If we set \(M=0\), \(N=30\) and \(S=10\), the first value returned from the range is the intial start value, \(0\).

We then add a step of \(10\) to get the next value (\(10\)).

Adding another step of \(10\) gives us the next number in the range: \(20\).

If we now try to add another \(10\), that gives us a total of \(30\), which is \sphinxstyleemphasis{outside} the upper range of \(N-1\), and so that number os not returned as within the range.

Now let’s see if we can get our robot to count up to five in the simulator.

Note that the \sphinxcode{\sphinxupquote{playsound.say()}} function accepts a \sphinxstyleemphasis{string} value, so if we want it to speak a number aloud we must first cast it to a string; for example, \sphinxcode{\sphinxupquote{str(5)}}.

\sphinxstyleemphasis{TO DO: maybe define a “say\_number()” function? Or may say more robust and error trap / cast non\sphinxhyphen{}strings to string values?}\sphinxhref{https://github.com/innovationOUtside/nbev3devsim/issues/37}{Related issue}\sphinxstyleemphasis{.}

Run the following code cell to download the programme to the simulator and then run it in the simulator. What happens? Does the robot count up to five?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic
\PYGZsh{} I can count...
import playsound

for i in range(5):
    playsound.say(str(i))
\end{sphinxVerbatim}
}

Although we set the range value as \(5\), remember that ths means the robot will count, by default, from \(0\) in steps of \(1\) to \(N-1\). So the robot will count \(0, 1, 2, 3, 4\):

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}list(range(5))
\end{sphinxVerbatim}
}


\paragraph{Activity TO DO}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Activity-TO-DO}}
In the following code cell, create a \sphinxcode{\sphinxupquote{range()}} statement that will creates a list of numbers from \(1\) to \(5\) inclusive. Use a \sphinxcode{\sphinxupquote{list()}} statement to generate a list from the \sphinxcode{\sphinxupquote{range()}} statement.

Run the code cell to display the result so you can check your answer:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} Display a list of values [1, 2, 3, 4, 5] created from a single rannge() statement

\PYGZsh{} YOUR CODE HERE
\end{sphinxVerbatim}
}

Now create a programme that will cause the simulated robot to count from 1 to 5 inclusive.

Run the cell to download the programme to the simulator, and then run it in the simulator. Does it behave as you expected?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic
\PYGZsh{} Count from 1 to 5 inclusive

\PYGZsh{} ADD YOUR CODE HERE
\end{sphinxVerbatim}
}

Can you modify your program so that it counts from ten to one hundred, inclusive, in tens (so, \sphinxstyleemphasis{ten, twenty, …, one hundred})?


\subparagraph{Answer}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:id2}}
\sphinxstyleemphasis{Click the arrow in the sidebar to reveal the answer.}

We can display a range of values from \(1\) to \(5\) inclusibe by using a range command of the form \sphinxcode{\sphinxupquote{range(M, N)}} where \sphinxcode{\sphinxupquote{M=1}}, the initial value, and \(N=5+1\), since the the range spans to a maximum value less than or equal to \(N-1\):

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}list(range(1, 6))
\end{sphinxVerbatim}
}

We can now create a programme that counts fom one to five inclusive:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic
\PYGZsh{} I can count from one to five inclusive...
import playsound

start\PYGZus{}value = 1
\PYGZsh{} To get the desired final value, it must be within the range
\PYGZsh{} So make the range one more than the desired final value
end\PYGZus{}value = 5 + 1

for i in range(start\PYGZus{}value, end\PYGZus{}value):
    playsound.say(str(i))
\end{sphinxVerbatim}
}

To count from ten to one hundred in tens, we need to add an additional step value as well as the range limit values:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic
\PYGZsh{} I can count from ten to one hundred in tens...
import playsound

start\PYGZus{}value = 10
end\PYGZus{}value = 100 + 1
step\PYGZus{}value = 10

for i in range(start\PYGZus{}value, end\PYGZus{}value, step\PYGZus{}value):
    playsound.say(str(i))
\end{sphinxVerbatim}
}


\subsubsection{Announcing Bands As The Robot Encounters Them}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Announcing-Bands-As-The-Robot-Encounters-Them}}
One of the ways we can use the \sphinxcode{\sphinxupquote{playsound.say()}} function is to count out the bands as we come across them. To do this, we need to identify when we cross from the white background onto a band.

We can detect the edge of a band by noticing when the sensor value goes from white (a reading of \(100\)) to a lower value. The following program will detect such a transition and say that it has crossed onto a band, also displaying a print message to announce the fact too.

Reset the robot location in the simulator, run the following cell to download the program to the simulator, and then run it in the simulator. Does it behave as you expected?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
\PYGZsh{} Onto a band...
import playsound

\PYGZsh{} Drive the robot slowly
tank\PYGZus{}drive.on(SpeedPercent(10), SpeedPercent(10))

previous\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

while True:
    \PYGZsh{}Uncomment the following line if you want to see the trace of sensor values
    \PYGZsh{}print(\PYGZsq{}Colour: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity ))
    current\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    if previous\PYGZus{}value==100 and current\PYGZus{}value \PYGZlt{} 100:
        print(\PYGZsq{}Onto a band...\PYGZsq{})
        playsound.say(\PYGZdq{}New band\PYGZdq{})

    previous\PYGZus{}value = current\PYGZus{}value
\end{sphinxVerbatim}
}

The programme starts by turning the motors on to drive the robot forward (\sphinxcode{\sphinxupquote{tank\_drive.on(SpeedPercent(50), SpeedPercent(50))}}) and then taking a sample of the light sensor reading (\sphinxcode{\sphinxupquote{previous\_value = colorLeft.reflected\_light\_intensity}}).

The \sphinxcode{\sphinxupquote{while True:}} statement creates a loop that repeats until the programme in the simulator is manually stopped. Inside the loop, a new sample is taken of the light sensor reading (\sphinxcode{\sphinxupquote{current\_value = colorLeft.reflected\_light\_intensity}}). If the robot was on the white background on the previous iteration (\sphinxcode{\sphinxupquote{previous\_value==100}}) and on a band in this iteration ( and then compared to the previous value (\sphinxcode{\sphinxupquote{current\_value \textless{} 100}}) then declare that the robot has moved onto a band, via the output
display window (\sphinxcode{\sphinxupquote{print(\textquotesingle{}Onto a band...\textquotesingle{})}}) and audibly (\sphinxcode{\sphinxupquote{playsound.say("New band")}}).

The previous value variable is then updated to the current value (\sphinxcode{\sphinxupquote{previous\_value = current\_value}}) and the programme goes round the loop again.

You may notice that there is a slight delay between the robot encountering a band and saying that it has done so. This is because it takes some time to create the audio object. If we were to speed up the robot’s forward motion, it would quite possibly leave one band and encounter the next before it had finished saying it had entered the first band.

\sphinxstyleemphasis{TO DO: if we queue too many audio messges, things get painful and we need to clear the speech buffer (maybe reload the page?) See}\sphinxhref{https://github.com/innovationOUtside/nbev3devsim/issues/8}{related issue}\sphinxstyleemphasis{for how we might start to fx this.}


\paragraph{Activity \sphinxhyphen{} Announce When the Robot Has Left a Band}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Activity---Announce-When-the-Robot-Has-Left-a-Band}}
In the code cell below, the previous robot control program has been modified so that the robot says “on” when it goes onto a band. Modify the programme further so that it also says, “off” when it goes from a band and back onto the white background.

Reset the robot location, donwload the program to the simulator and run it there. Does it behave as you expect?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
\PYGZsh{} On and off band...
import playsound

\PYGZsh{} Drive the robot slowly
tank\PYGZus{}drive.on(SpeedPercent(10), SpeedPercent(10))

previous\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

while True:
    \PYGZsh{}Uncomment the following line if you want to see the trace of sensor values
    \PYGZsh{}print(\PYGZsq{}Colour: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity ))
    current\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    if previous\PYGZus{}value==100 and current\PYGZus{}value \PYGZlt{} 100:
        print(\PYGZsq{}Onto a band...\PYGZsq{})
        playsound.say(\PYGZdq{}On\PYGZdq{})

    \PYGZsh{}YOUR CODE HERE


    previous\PYGZus{}value = current\PYGZus{}value
\end{sphinxVerbatim}
}


\paragraph{Answer}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:id3}}
\sphinxstyleemphasis{Click the arrow in the sidebar to reveal the answer.}

To detect when the robot has left a band, we can check to see if it was on a band on the previous iteration of the \sphinxcode{\sphinxupquote{while True:}} loop (\sphinxcode{\sphinxupquote{previous\_value \textless{} 100}}) and back on the white background on the current iteration (\sphinxcode{\sphinxupquote{current\_value == 100}}).

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
\PYGZsh{} On and off band...
import playsound

\PYGZsh{} Drive the robot slowly
tank\PYGZus{}drive.on(SpeedPercent(10), SpeedPercent(10))

previous\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

while True:
    \PYGZsh{}Uncomment the following line if you want to see the trace of sensor values
    \PYGZsh{}print(\PYGZsq{}Colour: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity ))
    current\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    if previous\PYGZus{}value==100 and current\PYGZus{}value \PYGZlt{} 100:
        print(\PYGZsq{}Onto a band...\PYGZsq{})
        playsound.say(\PYGZdq{}On\PYGZdq{})

    if previous\PYGZus{}value \PYGZlt{} 100 and current\PYGZus{}value == 100:
        print(\PYGZsq{}Off a band...\PYGZsq{})
        playsound.say(\PYGZdq{}Off\PYGZdq{})

    previous\PYGZus{}value = current\PYGZus{}value
\end{sphinxVerbatim}
}


\paragraph{Activity \sphinxhyphen{} Count the Bands}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Activity---Count-the-Bands}}
Using the previous programmes as inspiration, see if you can write a program that counts each new line as it encounters it, displaying the count to the output window and speaking the count number aloud.

Reset the location of the robot, download your program to the simulator and run it there. Does it work as you expected?

\sphinxstyleemphasis{Hint: you may find it useful to create a counter, initially set to 0, that you increment whenever you enter a band, and then display it and speak it aloud.}

\sphinxstyleemphasis{Another hint: remember, the \textasciigrave{}\textasciigrave{}playsound()\textasciigrave{}\textasciigrave{} function must be passed a string, rather than an integer, value.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
\PYGZsh{} Count the bands aloud

\PYGZsh{} Import necessary package(s)


\PYGZsh{} Start the robot moving

\PYGZsh{} Initial count value

\PYGZsh{} Initial sensor reading

\PYGZsh{} Create a loop

    \PYGZsh{} Check current sensor reading

    \PYGZsh{} Test when the robot has entered a band

        \PYGZsh{} When on a new band:
        \PYGZsh{} \PYGZhy{} increase the count

        \PYGZsh{} \PYGZhy{} display the count in the output window

        \PYGZsh{} \PYGZhy{} say the count aloud

    \PYGZsh{} Update previous sensor reading
\end{sphinxVerbatim}
}


\paragraph{Answer}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:id4}}
\sphinxstyleemphasis{Click the arrow in the sidebar to reveal the answer.}

Using the comment skeleton as a plan for the program, we can reuse statements from the previous programmes wwith just a few additions.

In the first case, we need to add a counter (\sphinxcode{\sphinxupquote{count = 0}}). Inside the loop, when we detect we are on a new band, increase the counter (\sphinxcode{\sphinxupquote{count = count + 1}}), display it (\sphinxcode{\sphinxupquote{print(count)}}) and after casting the count to string value, speak it aloud (\sphinxcode{\sphinxupquote{playsound.say(str(count))}}).

Note that we could make out output display message a little bit more elaborate by constructing an output message string, such as \sphinxcode{\sphinxupquote{print("Band count is" + str(count))}}. \sphinxstyleemphasis{(Unfortunately, the simulator does not support the rather more elaborate Python “f\sphinxhyphen{}string” formatting method.)}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
\PYGZsh{} Count the bands aloud

\PYGZsh{} Import necessary package(s)
import playsound

\PYGZsh{} Start the robot moving
tank\PYGZus{}drive.on(SpeedPercent(10), SpeedPercent(10))

\PYGZsh{} Initial count value
count = 0

\PYGZsh{} Initial sensor reading
previous\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

\PYGZsh{} Create a loop
while True:

    \PYGZsh{} Check current sensor reading
    current\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

    \PYGZsh{} Test when the robot has entered a band
    if previous\PYGZus{}value==100 and current\PYGZus{}value \PYGZlt{} 100:
        \PYGZsh{} When on a new band:
        \PYGZsh{} \PYGZhy{} increase the count
        count = count + 1
        \PYGZsh{} \PYGZhy{} display the count in the output window
        print(count)
        \PYGZsh{} \PYGZhy{} say the count aloud
        playsound.say(str(count))

    \PYGZsh{} Update previous sensor reading
    previous\PYGZus{}value = current\PYGZus{}value
\end{sphinxVerbatim}
}


\subsubsection{Summary}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_03_quick_practical_tour:Summary}}
In this notebook, you have seen how we can use the simulator to load in a particular background and log and chart sensor values captured as the robot moves over the simulator background both within the simulator and in the notebook environment itself.

You have also seen how we can get the robot to count as we iterate through a range of values.

By keeping track of previous and current sensor values, you have seen how the robot can identify when it encounters a new feature in the simulated world, such as entering or leaving a coloured band. Using the speak functionality, the robot can also alert us to when it encounters a new object.



---
# 4 RobotLab’s simulator remote control

The original RobotLab simulator included a simple remote control for controlling a real, as well as simulated, robot in a direct, user-controlled interactive way.

The remote control activities provided a way of developing familiarity with how to control the robot prior to moving on to programmatic control.

Neither the current version of the `nbev3devsim` simulator, nor the original `ev3devsim` on which it was based, support a direct remote control interface.

Whilst future versions of the simulator may be extended to include remote control operation, the following activity descriptions from the original RobotLab activities, are retained here for historical interest only.



# NOTES BELOW OF HISTORICAL INTEREST ONLY

---


\subsection{4.1 Activity: Remote control}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_04_LEGACY_UNUSED_IGNORE:4.1-Activity:-Remote-control}}\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_04_LEGACY_UNUSED_IGNORE::doc}}
The RobotLab environment allows you to write programs that an autonomous robot will run. As you have seen, RobotLab also provides a simulated robot that appears in the \sphinxcode{\sphinxupquote{Simulator}} window so that you can test out your programs. Some (real) robots can be controlled by a human using a remote control. In a similar fashion, RobotLab also provides a remote control unit that you can use to control the (simulated) robot directly.

Start RobotLab. (If you already have a program loaded, choose \sphinxcode{\sphinxupquote{File \&gt; New}}.) In this activity, you are not going to program the robot, so you can close or minimise the \sphinxcode{\sphinxupquote{Program editor}} window. (Do you remember how to do this? If not, refer back to Section 1.6.) Open the \sphinxcode{\sphinxupquote{Controls}} window either by clicking on its restore icon or by choosing \sphinxcode{\sphinxupquote{Window \&gt; Controls}}.





Keyboard: Alt, W, 3





The \sphinxcode{\sphinxupquote{Controls}} window is shown in Figure 4.1. This control panel, also called the \sphinxstyleemphasis{simulator remote control unit}, can be repositioned on any part of the screen. Click and drag on the \sphinxcode{\sphinxupquote{Controls}} window title to move it to a convenient position beside the \sphinxcode{\sphinxupquote{Simulator}} window.

\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f040}.jpg}

Figure 4.1 The RobotLab simulator remote control unit

The RobotLab controls window. This is divided into three areas: top left are the direction controls, bottom left are the simulator clock controls, and to the right are the input and output monitors. The direction controls and output monitors will be described in following figures. The clock controls are two buttons representing a clock with ‘play’ and ‘stop’ icons superimposed. The input monitors are three boxes labelled 1, 2, 3. These can either contain numbers representing sensor readings from
0 to 100, or for touch sensors a shape that turns dark when the sensor is pressed.

To use the simulator remote control unit, you need to have the simulator clock running. You can set it running by using the \sphinxcode{\sphinxupquote{Simulator \&gt; Start clock}} menu,





Keyboard: Ctrl+Home





or more easily from the \sphinxcode{\sphinxupquote{Start clock}} \sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f041}.jpg} button on the remote control unit at the bottom left of the \sphinxcode{\sphinxupquote{Controls}} window. Click on this button now.

The clock remains running until you switch it off using the \sphinxcode{\sphinxupquote{Stop clock}} menu or \sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f042}.jpg} button.





Keyboard: Ctrl+End





Leave it on for the duration of this exercise.

At the top of the remote control are several direction buttons (Figure 4.2).





Keyboard: Shortcuts are given in Table 4.1





You click on the forward arrow to switch both motors on and drive the simulated robot forwards. You click on the backward arrow to drive it backwards, etc. And you click on the black square in the centre of the direction controls to turn both motors off and stop the robot.

\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f043}.png}

Figure 4.2 The direction of the wheels set by the controller

The direction controls. There are nine buttons laid out in a 3 x 3 grid, each with an arrow pointing in the relevant direction. The directions of each button and their keyboard shortcuts are given in the text below.

Now click on the forward arrow to drive the robot forwards, and then click on the stop button to stop the robot. Next click on the down arrow to drive the robot backwards, and then stop the robot again.

The remote control unit also displays information about the robot’s inputs and outputs. The bottom half of this display shows what is happening to the motors. Above the motor labels A, B and C are several indicators. The top indicators, solid black dots or crosses in a circle, show whether the motor is turned on or off, respectively (Figure 4.3).

The second indicators, up or down arrows, show whether the motor is switched to a forwards or backwards direction.

The sliders give the power level for each motor, which ultimately corresponds to the speed with which the motor turns. Leave these at their maximum levels for now.

\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f044}.jpg}

Figure 4.3 Controlling the simulated motor power

The output controls and monitor used to control motor power. There are three identical outputs, labelled A, B \& C. Above each label is a slider for setting the power from 0 to 8. Above this is an arrow the faces up or down for indicating forward of backward direction. Finally, at the top is an indicator indicating whether the motor is on or off.

By looking at the motor indicators, can you see how the robot is managing to turn? Try driving the robot forwards, backwards and turning in different directions.

In order to turn the robot, \sphinxstyleemphasis{differential} or \sphinxstyleemphasis{skid} steering is used.

For example, click on one of the curved arrows to rotate the robot about its centre. To turn the robot clockwise about its centre, the left motor (A) is switched on in a forwards direction, and the right motor (C) is switched on in a backwards direction.


\subsubsection{Question}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_04_LEGACY_UNUSED_IGNORE:Question}}
How would you control the motors to turn the robot anticlockwise about its centre?


\subsubsection{Answer}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_04_LEGACY_UNUSED_IGNORE:Answer}}
The right motor needs to run forwards and the left motor to run backwards. The robot can also turn clockwise or anticlockwise by switching on either motor A or motor C and leaving the other motor switched off.


\subsubsection{Question}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_04_LEGACY_UNUSED_IGNORE:id1}}
How would you control the motors to make a slow, gradual turn to one side?


\subsubsection{Answer}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_04_LEGACY_UNUSED_IGNORE:id2}}
If the motors run at different speeds, the robot will make a gradual turn. A slow turn (right forwards, left forwards, right backward or left backwards) can be obtained by switching on both motors either forwards or backwards, but running them at different power levels (i.e. at different speeds) using the slider controls. Click on the forward arrow, then experiment by reducing the power levels for motors A and C to 75\% and 50\% respectively.





Keyboard: Ctrl+NumPlus or Ctrl+NumMinus





If you lose sight of the robot in the \sphinxcode{\sphinxupquote{Simulator}} window, you can zoom the view of the \sphinxcode{\sphinxupquote{Simulator}} window in or out. Choose \sphinxcode{\sphinxupquote{Simulator \&gt; Zoom in}} or \sphinxcode{\sphinxupquote{Simulator \&gt; Zoom out}}, or click on the zoom \sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f045}.jpg} buttons on the toolbar.

If you happen to leave the robot moving for a long time and can’t find it again, you can reset the simulator by choosing \sphinxcode{\sphinxupquote{Simulator \&gt; Reset}}.





Keyboard: Shift+Ctrl+Home





If all else fails, just close RobotLab and reopen it.

To move the robot, left\sphinxhyphen{}click and hold down the cursor on the robot itself, and drag and drop it within the \sphinxcode{\sphinxupquote{Simulator}} window. You can also rotate the robot by right\sphinxhyphen{}clicking on it and dragging it with the mouse.


\subsection{4.2 Activity: More remote control}
\label{\detokenize{content/00_SOFTWARE_GUIDE/Section_00_04_LEGACY_UNUSED_IGNORE:4.2-Activity:-More-remote-control}}
In the \sphinxcode{\sphinxupquote{Controls}} window there is also a set of indicators for each sensor (1, 2, 3) (Figure 4.4). The indicators show the readings provided by sensors connected to the relevant input ports.

\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f040}.jpg}

Figure 4.4 The RobotLab simulator remote control unit

The RobotLab controls window. This is divided into three areas: top left are the direction controls, bottom left are the simulator clock controls, and to the right are the input and output monitors. The direction controls and output monitors will be described in following figures. The clock controls are two buttons representing a clock with ‘play’ and ‘stop’ icons superimposed. The input monitors are three boxes labelled 1, 2, 3. These can either contain numbers representing sensor readings from
0 to 100, or for touch sensors a shape that turns dark when the sensor is pressed.

Open the \sphinxcode{\sphinxupquote{Controller\_test}} program and run it. The robot will not move \textendash{} the program doesn’t turn the robot’s motors on. Instead, use the controller to drive the robot to go forwards over the grey areas, and note the change in light sensor value. The light sensor is shown by the small blue square on the simulated robot and is connected to input port 2.

Try driving the robot over one of the red blocks. You should find that it stops. This is because red is set to ‘solid’, simulating an obstacle in front of the robot. See what happens to the touch sensors when they touch the red area. The touch sensors are shown as small green squares on the robot and are connected to input ports 1 and 3.


\bigskip\hrule\bigskip


Rerun the \sphinxcode{\sphinxupquote{Controller\_test}} program in \sphinxcode{\sphinxupquote{show\sphinxhyphen{}trail}} mode. Choose the \sphinxcode{\sphinxupquote{Simulator \&gt; Show trail}} menu item





Keyboard: Alt, S, T





or click on the Show trail \sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p5_f014}.jpg} button in the toolbar. Run the program again to see the robot’s trail.

Drive the robot over the grey areas, and one and half times round the red blocks as shown. It’s more tricky than it looks. My attempt is shown in Figure 4.5.

\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f046}.jpg}

Figure 4.5 Negotiating the red blocks in pen\sphinxhyphen{}down mode

A screen shot of RobotLab showing the simulator window with a trace left by the robot as it was driven around the red blocks. The red blocks are arranged at the four corners of a square. In the centre between the blocks is a vertical grey strip divided into four areas of different intensity ranging from pale grey at the top to black at the bottom. The track superimposed shows a straight line up from the start position over the grey strip followed by a couple of laps around the outside of the
four red blocks. Each lap is a rough square with rounded corners, although the sides are far from straight and there are wild wobbles in a couple of places.

You may find it easier to control the robot using the keyboard rather than the mouse. RobotLab uses the keys on the numeric keypad of your computer keyboard as short\sphinxhyphen{}cuts for the direction buttons in the remote control window; they are laid out in the same pattern.





Table 4.1 Remote control short\sphinxhyphen{}cut keys









\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f11a}.gif}

Veer left

Ctrl+7





\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f12a}.gif}

Forward

Ctrl+8





\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f13a}.gif}

Veer right

Ctrl+9









\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f14a}.gif}

Spin left

Ctrl+4





\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f15a}.gif}

Stop

Ctrl+5





\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f16a}.gif}

Spin right

Ctrl+6









\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f17a}.gif}

Back left

Ctrl+1





\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f18a}.gif}

Backward

Ctrl+2





\noindent\sphinxincludegraphics{{content/00_SOFTWARE_GUIDE/../tm129-19J-images/tm129_rob_p1_f19a}.gif}

Back right

Ctrl+3









This is the end of Robot Lab Session 1.


\bigskip\hrule\bigskip



\section{Session 01 — RoboLab}
\label{\detokenize{index:session-01-robolab}}


---
# 1 An introduction to programming robots

```python
from IPython.core.display import display, HTML

display(HTML("<style>#notebook-container { width:50% !important; float:left !important;}</style>"))

```

```python
#%pip install --upgrade git+https://github.com/innovationOUtside/nbev3devsim.git@draggable-robot
```

The objective of RoboLab Session 2 is to explain the basics of robot computer programming and show you how to use some of the elementary features of the RoboLab simulator.

It is assumed that you are completely new to computer programming and robotics. We’ll try to avoid jargon and go at a pace that makes it easy for you to understand what is going on.


## 1.1 Some basics of computer programming

For beginners, computer programming can appear to be a very mysterious process. Programming a robot may seem even more daunting, but I hope to show that the basics are quite straightforward. As you saw in Robot Lab Session 1, a *computer program* is a sequence of instructions or commands, written using words, symbols and numbers.
For example, you might want the robot to go forwards for five seconds. If we control the motors separately, this involves turning each motor on separately, waiting for 5 seconds, and then terminating the program, at which point the motors in our robot simulation are automatically switched off.
<div class='alert-warning'>The "stop the motors at the end of the programme" behaviour is not guaranteed in other environments used to programme either simulated or real robots. To be safe, it's often worth making sure you turn off the motors at the end of a programme so you know for sure what state they are in when the programme terminates.</div>
In our environment, we need to:
- turn each motor on with a particular *speed*, which also sets the *direction*: positive speed values are assumed to mean "go forwards", negative ones "go backwards";
- wait for five seconds;
- (programme ends, motors turned off automatically).
This could be *coded* in RobotLab using instructions of the form:
```python
left_motor.on(SpeedPercent(50))
right_motor.on(SpeedPercent(50))
sleep(5)
```
for suitable configurations of `left_motor` and `right_motor`.
Perhaps confusingly, the `sleep()` command, rather than saying "do nothing for 5 seconds", says "continue to do what you're already doing for 5 seconds". For our current example, this means "keep your motors on and running for 5 seconds".
But how does the programme know what the `left_motor` and `right_motor` are? Our programme also requires that we have defined these items earlier in the programme using things it *does* know about. In particular, we would need to use a construction of the form:
```python
left_motor = Motor(OUTPUT_B)
right_motor = Motor(OUTPUT_C)
```
Here, the `Motor()`, `OUTPUT_B` and `OUTPUT_C` statements, as well as the previously seen `SpeedPercent`, are provided as predefined building blocks to use in our own simulated robot control programmes.
The `Motor()` element refers to programme elements elsewhere that define a `Motor` *object*. This computational object provides an abstract representation of a physical (or simulated) motor along with a set of operations or *methods* that can be enacted upon it. For example, we may turn a motor *on* in a particular *direction* and with a particular *speed* for a particular *time* or for a specified number of *rotations*.
The `Motor()` object is created with an *argument* that identifies an *output port* that the physical motor in a real robot, and the simualted motor in a simulated robot, would be connected to. Output ports are used to identify power and/or control lines that a software controller can use to control the behaviour of a physical (or simuluted) device, such as a motor, LED display, or speaker. In our simulated robot case, two output ports are defined, `OUTPUT_B` and `OUTPUT_C`. By convention, we associate `OUTPUT_B` with the motor on the left hand side of the robot as it travels in a forwards direction, and `OUTPUT_C` with the right hand motor.
To simplify matters, other "higher level" *predefined* building blocks are also provided to make writing our programmes simpler.
For example, the `MoveTank` building block allows us to create a "tank" drive comprised of a left and right motor. We can instruct the tank drive to turn each motor on with its own specified speed and direction, and for a certain amount of time, using a single command:
```python
tank_drive = MoveTank(OUTPUT_B, OUTPUT_C)
tank_drive.on_for_seconds(SpeedPercent(50), SpeedPercent(50), 5)
```
Computer code usually looks stilted like this because it has to follow very strict rules about which characters go where. Fortunately, the notebooks have some support, know as "tab completion", for helping you create programs without making typing mistakes. You will learn more about that as we go along.
The following describes what happens when you use a notebook to program our simulated robot.
First, we use some IPython "magic" (and yes, it really is called that!), at the start of a code cell to say that the following code should be passed to a particular instance of our simulator running in the same notebook.
The magic incantation takes the form:
`%%sim_magic`
and it __MUST__ appear as the first line of a code cell. In the above example, `roboSim` is the name of the variable associated with our simulator instance.
The rest of the code in the cell is the code that will be passed into the simulator and used to control the the simulated robot. (The same code should also work with a *real* Lego EV3 robot running the `ev3dev` operating system.)
When you *Run* the code cell, the code is "downloaded" to the simulator *but is not executed*.
To execute your programme, you need to click the *Run* button in the simulator. Once the code is "downloaded" from your code cell to the simulator (or — if we work out how! [This](https://github.com/ev3dev/vscode-ev3dev-browser) may provide some clues... — to a real robot), the robot is *autonomous* and runs independently of the code cell within which the program is defined.
The following diagram tries to capture the relationship between the code as seen in a notebook magic code cell and the simulator running as a Javascript programme inside the browser Javascript environment.
![A diagram showing how code wihtin a code cell can be "downloaded" to the nbev3devsim simulator or, in principle, downloaded to a real robot running Linux and the ev3dev-py environment. At one side is a box representing a jupyter notebook and the other side a box representing an EV3 robot. The notebook container contains a "magic code cell" and a separate Javascript environment. The Javascript environment contains an nbev3devsim container. An arrow is shown going from the code cell to the nbev3devsim container inside the Javascript container. Inside the EV3 robot box is a Linux container, and inside that an ev3dev container. An second arrow leads from the magic code cell inside the notebook container to the ev3dev container inside the Linux conainer inside the EV3 robot box.](../images/ev3dev-codearchitecture.png)
The diagram also shows how, in principle, the *same* programme could be used to program the simulated robot *or* a real EV3 powered robot.
In the simulated robot environment, the same physical computer is being used to do several different things:
1. to create and edit RobotLab programs in the Jupyter notebook or JupyterLab user interface; the Jupyter notebook interface runs in the browser, and the content of the code cells are executed inside a Python environment running on your computer.
2. to execute Python code contained in a notebook code cell in a Python environment, or "download" code from a code cell to the simulator;
3. to execute the program in a simulated robot in a Javascript environment running inside your browser.
Whilst they run on the same physical computer, these programmes actually run in different computational environments on the computer. For example, the simulator is actually a Javascript programme that runs in your browser: once you click on the `Run` button, it is the simulated robot’s control system that is executing the robot program inside a Javascript environment in your browser. The code is actually sent to the simulator via a Python process when the notebook code cell is run. The IPython magic tells the Python process to grab the contents of the code cell (and depending on the magic, prefix it with additional boilerplate code), and then send that code to the simulator running as Javascript code in the browser window that contains the notebook user interface.
![](../images/ev3-jupyter-arch.png)
<div class='alert-warning'>Would it make sense to use another work in the simulator? "Execute"? "SimRun"?</div>
## Getting Started With the Simulator
The simulator we will be using must be loaded into each notebook that wants to use it once per notebook. In addition, __only one instance of the simulator per notebook is allowed__. Any more than that and things don't work at all.
<div class='alert-danger'>I'm working on a minimum viable model at the moment, with as few instructions about workflow as I can get away with in the hope that I can iterate a few times, improve the UI, workflow etc, maybe even radically change things. A lot can happen in Jupyter land in 6-8 weeks!<br/><br/>
The single simulator instance is becuase atm the simulator is embedded into the notebook with a hard coded HTML element id; multiple elements w/ same id break things. It may be a quick fix, it may not; if it's quick, it may be fixable over a coffee. If it's not, it could take an afternoon, and then testing time. So that's parked for now...</div>
The following cell will load in the Python package that makes the simulator available, along with some IPython magic that allows us to interact with the simulator.
```python
from nbev3devsim import ev3devsim_nb as eds
%load_ext nbev3devsim
```
The simulator itself is created as a Jupyter widget, referenced by a variable of our choosing, in the following case, the variable `roboSim`. The `display()` command then renders the widget.
Run the notebook code cell containing the lines:
```pyhton
roboSim = eds.Ev3DevWidget()
display(roboSim)
```
to create the simulator and embed it in the notebook:
```python
roboSim = eds.Ev3DevWidget()
display(roboSim)
roboSim.element.dialog();
```
At the moment, things are a little clunky in terms of how we actually get code into the simulator and run it.
Using the `move selected cells up` and `move selected cells down` up and down arrow buttons in the notebook toolbar, I suggest you move the simulator display so that it is *above* the code cell you are currently using to programme the robot.
You can then run the notebook code cell to download the programme to the simulator, and press the simulator *Run* button to exectute the programme in the simulator and watch the result.
### Error Messages in the Simulator
If you make an error in a programme sent to the simulator, when you try to run the program in the simulator, a message will be displayed in the simulator console.
??Missing image?
<img src='../../images/Section_00_01_-_Jupyter_Notebook_error.png' width=500 alt='' />
The line number specified will be one less than the line number displayed in the associated code cell if you enable line number display within the cell.
### Passing Code into the Simulator
To write programme code that can be passed to the simulator and executed within it to control the simulated robot,
```python
%%sim_magic
print('hello world')
```
## 1.2 An introduction to sequential programming
There are various ways of programming computers to control robots. One of these is the *sequential* approach, which is the main approach used in RobotLab. This method of writing computer programs, as lists or sequences of commands, produces what are called *sequential programs*.
In the sequential program model the computer executes commands in sequence.
__TO DO: we can just do sequential here using notebook code cells, then introduce the simulator later?__
The programme is structured in a particular way that allows the programme to operate correctly (a *necessary* requirement) as well as making it "readable" (a *desirable* requirement).
In terms of correctness, the programme requires that we define things within our programme before we try to call on them and make use of them within our programme.
One way of defining things is to *import* them from a Python package. A package is essentially a collection of predefined programme elements that are useful for a particular programming task.
```python
# Import statements
from ev3dev2.motor import Motor, SpeedPercent, OUTPUT_B, OUTPUT_C
import time
# Definitions
left_motor = Motor(OUTPUT_B)
right_motor = Motor(OUTPUT_C)
# Programme actions
left_motor.on(SpeedPercent(75))
right_motor.on(SpeedPercent(75))
# Wait here for 1 second...
time.sleep(1)
# Programme ends
```
Lines prefixed by a `#` are *comments* that are not executed as programme code but are intended as notes to human readers that can be used to help make a programme more readable.
The following programme turns the left and right motors on at three quarters of their full speed, waits for a short period (1 second), then the programe ends and the motors are automatically switched off.
```python
%%sim_magic
# Import statements
from ev3dev2.motor import Motor, SpeedPercent, OUTPUT_B, OUTPUT_C
import time
# Definitions
left_motor = Motor(OUTPUT_B)
right_motor = Motor(OUTPUT_C)
# Programme actions
left_motor.on(SpeedPercent(75))
right_motor.on(SpeedPercent(75))
# Wait here for 1 second...
time.sleep(1)
# Programme ends
```
*Run the above code cell to download the code to the simulator, and then run the programme using the simulator interface.*
When you run the programme in the simulator, the robot should move forwards quickly for one second and then stop. Try increasing the "sleep" time in seconds, re-run the code code cell to download the programme to the simulator, and then re-run it in the simulator. Does the robot behave as you expect? What happens if you also change the `SpeedPercent(VALUE)`, where `VALUE` is a numerical value that can range from `-100` to `100`?
### Using Predefined Code Building Blocks
Writing programmes at such a low level is possible, but we often find it more convenient to programme at a higher level of abstraction. In the following example, we can configure and use a predefined motor drive that allows us to control both motors from a single command.
In particular, the ` MoveTank()` function from the `ev3dev3.motor` Python package allows us to define a simple tank drive composed of two motors, one on the left hand side of the robot on one on the right hand side. The configuration associates a controllable motor output with a particular motor.
```python
tank_drive = MoveTank(OUTPUT_B, OUTPUT_C)
```
The tank drive is used to power two motors simultaneously in various ways. For example, we can turn the motors on at a desired speed:
```python
tank_drive.on(LEFT_SPEED, RIGHT_SPEED)
```
We can also turn the motors on for a specified time and then automatically turn them off at the end of that period:
```python
tank_drive.on_for_seconds(LEFT_SPEED, RIGHT_SPEED, TIME)
```
The following example shows how we can drive the tank:
- *forwards* in a straight line (both motors at the same speed) for a specified time using the tank drive;
- *turn on the spot* for the same period (one motor forwards, the other backwards, at the same speed); and then
- *reverse* in a straight line for the same period of time (both motors backwards at the same speed.
*Run the following code cell to download the program to the simulator and then run the programme in the simulator:*
```python
%%sim_magic_preloaded
from ev3dev2.motor import MoveTank, SpeedPercent, OUTPUT_B, OUTPUT_C
# Sequential program
tank_drive = MoveTank(OUTPUT_B, OUTPUT_C)
time_1s = 1
# Go forwards...
# Set the left and right motors in a forward direction at the same speed
# and run for 1 second
tank_drive.on_for_seconds(SpeedPercent(50), SpeedPercent(50), time_1s)
# Turn on the spot...
# Set the left motor forwards and the right motor backwards
# and run for 1 second
tank_drive.on_for_seconds(SpeedPercent(50), SpeedPercent(-50), time_1s)
# Go backwards...
# Set the left and right motors in a backwards direction at the same speed
# and run for 1 second
tank_drive.on_for_seconds(SpeedPercent(-50), SpeedPercent(-50), time_1s)
```
### Activity - Driving the Motors at Different Speeds
What happens if the motors are turning in the same direction but at different speeds? Explore this situation by running the followng code cell, using different motorspeed values, to the simulator and running the code there.
What happens if the motors turn in *different* directions? Is the behaviour as you'd expect?
Check the *pen down* checkbox so that you can see the trace of where the robot has been.
*Note that the simulated robot may not behave as a real robot would. It all depends on how well the simulated robot and the simulator physics have been implemented.*
*Run the following code cell to download the program to the simulator and then run the programme in the simulator. Experiment using different values for the motor speeds. To compare different configurations, use the pen down control to leave a trace showing where the robot hos been and the Move position reset button to reset the starting position of the robot between each run. Remember to download updated configurations to the simulator by running the updated code cell before re-running the programme in the simulator.*
```python
%%sim_magic
from ev3dev2.motor import MoveTank, SpeedPercent, OUTPUT_B, OUTPUT_C
# Try motors with difference speeds
tank_drive = MoveTank(OUTPUT_B, OUTPUT_C)
TIME_IN_S = 5
LEFT_MOTOR_SPEED_PC = -50
RIGHT_MOTOR_SPEED_PC = -50
tank_drive.on_for_rotations(SpeedPercent(LEFT_MOTOR_SPEED_PC),
                          SpeedPercent(RIGHT_MOTOR_SPEED_PC),
                          TIME_IN_S)
```
#### Answer
*Click the arrow in the sidebar to reveal the answer.*
With both motor speeds set in the forward direction, if the left motor speed is slightly faster than the right motor speed, then the robot curves towards the right; if the right motor is slightly faster than the left motor, the robot curves to the left. The greater difference between the speeds, the tighter the curve.
If one of the motors is set at a forward speed and one is in reverse, the robot turns in a tight circle centred on the reverse turning wheel.
If both motors are are going backwards (negative speed), then wuth the `.on_for_seconds()` command, the robot does not move. This seems to be an issue with the simulator.
### Turning the Motors on for a Specified Number of Wheel Rotations
As well as turning the motors on for a specified period of time, we can also turn them on for a specified number of rotations of the wheels:
```python
tank_drive.on_for_rotations(LEFT_SPEED, RIGHT_SPEED, ROTATIONS)
```
This is easy to imagine for the case where the wheels are turning at the same speed, but if one wheel turns faster than the other, the robot will follow a curving path and the ooutside wheel will travel further than the inside wheel (assuming that the inside wheel doesnlt slip).
*TO DO -  we could have a diagram here showing a robot driving round a circle; the circumference of the locus followed by the outer wheel wheel will be shorter than that of the inner wheel making it clear that if the wheels are the same size, the outer one must rotate more than the inner one.*
From [the documentation](https://ev3dev-lang.readthedocs.io/projects/python-ev3dev/en/stable/motors.html#ev3dev2.motor.MoveTank.on_for_rotations), *'if the left speed is not equal to the right speed (i.e., the robot will turn), the motor on the outside of the turn will rotate for the full rotations while the motor on the inside will have its requested distance calculated according to the expected turn.'*
The following code cell provides code for exploring the use of the `.on_for_rotations()` command.
*Run the following code cell to download the program to the simulator and then run the programme in the simulator. Experiment using different values for the motor speeds and number of rotations. To compare different configutations, use the pen down control to leave a trace showing where the robot hos been and the Move position reset button to reset the starting position of the robot between each run. Remember to download updated configurations to the simulator by running the updated code cell before re-running the programme in the simulator.*
```python
%%sim_magic
from ev3dev2.motor import MoveTank, MoveSteering, SpeedPercent, OUTPUT_B, OUTPUT_C
tank_drive = MoveTank(OUTPUT_B, OUTPUT_C)
LEFT_MOTOR_SPEED = SpeedPercent(50)
RIGHT_MOTOR_SPEED = SpeedPercent(55)
ROTATIONS = 4
tank_drive.on_for_seconds(LEFT_MOTOR_SPEED, RIGHT_MOTOR_SPEED, ROTATIONS)
```
Compared to the `.on_for_seconds()` command, the `.on_for_rotations()` command is capable of going backwards!
*TO DO - we could make that an activity and have an example of annotated screengrab of the simulator showing different traces.*
### Steering the Robot — `MoveSteering`
As well as the `MoveTank()` configuration, a `MoveSteering()` configuration is also available that again is based on the presence of two motors connected to the same controllable outputs:
```python
tank_turn = MoveSteering(OUTPUT_B, OUTPUT_C)
```
The `MoveSteering()` configuration again drives both motors simutaneously, although this time at the same speed but in different directions.
To turn the robot, we use the command:
```python
tank_turn.on(STEERING, SPEED)
```
where `STEERING`steering is a numerical value between `-100` and `100` and where:
- `-100` means turn left on the spot (right motor at 100% forward, left motor at 100% backward);
- `0` means drive in a straight line, and
- `100` means turn right on the spot (left motor at 100% forward, right motor at 100% backward).
As well as turning the steering drive on, we can turn it on for a specified time using `.on_for_seconds(STEERING, SPEED, TIME)` as in the case of the tank drive.
The following programme gives a simple example of how to turn the robot using the `MoveSteering()` motor configuration.
*Run the following code cell to download the program to the simulator and then run the programme in the simulator. Experiment with various settings for the s*
*TO DO - it would perhaps be interesting to have a simple simulator view, cf. a [remote control](https://github.com/innovationOUtside/nbev3devsim/issues/39), where we can turn the motors on or off, select a motor group, and set the motor speeds, steering degree etc. Maybe do this with a magic that has a couple of ipywidgets that send realtime updates to a free running simulator?*
Alternatively, we can turn the steering drive on for a specified number of rotations of one of the wheels:
```python
on_for_rotations(STEERING, SPEED, ROTATIONS)
```
Running the following code cell provides a demonstration:
```python
%%sim_magic
from ev3dev2.motor import MoveTank, MoveSteering, SpeedPercent
from ev3dev2.motor import OUTPUT_B, OUTPUT_C
tank_drive = MoveTank(OUTPUT_B, OUTPUT_C)
# the first two parameters can be unit classes or percentages.
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 4)
# drive in a turn for 2 rotations of the outer motor
tank_turn = MoveSteering(OUTPUT_B, OUTPUT_C)
tank_turn.on_for_rotations(-100, SpeedPercent(75), 2)
```
#### Question
If a simulated robot starts pointing towards the top of the screen, will it turn towards the right or left while executing the sequence of commands shown in the code cell below?
*Before* you run the code, make a prediction about what you thing the robot will do when the code is executed by the simulated robot.
If a simulated robot starts pointing towards the right hand side of the screen, will it turn towards the top or bottom of the screen while executing the same sequence of commands?
__DOUBLE CLICK THIS CELL TO EDIT IT.__
*When the following code is executed by the robot simulator, I predict ...__YOUR ANSWER HERE__... .*
```python
%%sim_magic
from ev3dev2.motor import MoveTank, MoveSteering, SpeedPercent, OUTPUT_B, OUTPUT_C
tank_drive = MoveTank(OUTPUT_B, OUTPUT_C)
time_1s = 1
# Set the left and right motors in a forward direction
# and run for 1 second
tank_drive.on_for_seconds(SpeedPercent(50), SpeedPercent(50), time_1s)
# Set the left motor forwards and the right motor backwards
# and run for 1 second
tank_drive.on_for_seconds(SpeedPercent(50), SpeedPercent(-50), time_1s)
```
#### Answer
Open and run `Sequence` to see what happens.
The first two commands in `Sequence` move the robot forwards for one second (Figure 1.3a). The next two commands turn the robot towards the right (the left wheel goes forwards and the right wheel goes backwards) for one second (Figure 1.3b). The combined result is that the robot goes forwards for one second and turns for one second (Figure 1.3c).
![figure ../images/tm129_rob_p2_f007.jpg](../images/tm129_rob_p2_f007.jpg)
Figure 1.3 Movements of the simulated robot in `Sequence`
Diagrams representing different movements of a differentially steered two-wheel robot by drawing its initial and final position. (a) Forward (line 10): the robot moves straight ahead a short distance and stops without turning. (b) Turn (line 15): the robot initially points forward and then turns well short of a right angle, on the spot, clockwise. (c) Forward and turn (statements 1, 2, 3 and 4): the robot starts, drives forward a short distance and then turns on the spot through a right-angle clockwise.
When trying to understand, or write your own, robot programs, it can be helpful to ‘play robot’. This means that you put yourself in the place of the robot and act out (or at least imagine) what you or the robot would do when executing each statement of the program. If you have the help of a friend, get them to read out the program statements to you one at a time.
The trace left as the robot turns on the spot does not appear to be center simulated robot doesn't turn exactly on the spot because the robot is turning about one of the wheels.
## 1.3 Writing Programs for Use in the RoboLab Simulator
Once the simulator has been loaded and displayed in a notebook, you can start to write programmes that will run on the simulated robot.
The programmes are written __in a single code cell__ prefixed with the magic incantation `%%sim_magic roboSim` on __the first line__ of the code cell.
Running the code cell "downloads" the programme from the cell to the simulated robot. Pressing the run button in the simulated robot will then execute the downloaded robot programme within the simulator.
*TO DO - need some sort of help or lookup for simulator programme commands.*
## NN TO DO  Activity: Creating and editing your own programs
In the next few activities you are going to learn how to use RobotLab to construct a computer program that will move a simulated robot around a square course. You should try to work through the instructions carefully and slowly. It is important that you complete each step successfully before moving on to the next. We have allowed two hours for this, although you may be able to complete the exercise in less time if you have some experience of computer programming.
If you run the following programme in the simulator, you will find that it drives the robot forward a short way and then turns on the spot for more than a right angle (ninety degrees).
*TO DO - simple diagram showing angles and their names, eg ninety degrees.*
```python
%%sim_magic_preloaded
# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)
# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 1)
```
### Copying and Modifying a program
We can edit a code cell directly to add additional lines to it, or we may want to retain our original code (for reference) and create a new programme based on an earlier one.
We can grab a copy of a code cell by:
- clicking on it to select it;
- clicking the *copy selected cells* button in the toolbar;
- clicking the *paste cells below* toolbar button to place a copy of the cell in a new cell;
- select the new cell and use the arrow keys to move it to a locaiton of your choosing.
Select the code cell above by clicking on it, use the tool bar button to copy it, single click on this markdown cell to provide the current location, then click on the toolbar paste button to copy the code cell below this one.
Modify the programme in your newly created cell so that the robot turns through a right angle (or as close as you can get it without spending too much time!). Test your code by runn the code cell to download the code to the simulator, and then run it in the simulator.
You may find that using the pen trace helps you see how far the robot has turned.
```python
%%sim_magic_preloaded
# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)
# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 1)
```
#### My Attempt
*Click the arrow in the sidebar to reveal the settings I used.*
```python
%%sim_magic_preloaded
# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)
# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.846)
```
On my computer, I found I could turn the robot through about ninety degrees by setting the number of wheel rotations on the turn step to between 0.85 and 0.9.
### Copying Code Using Keyboard shortcut commands
You can also use the `ESC-C` keyboard shortcut to copy a selected cell and `ESC-V` to paste a copied cell immediately below the currently selected cell.
Alternatively, you can highlight and select code *within* a code cell and then use the keyboard copy and paste commands to copy the code from the original cell, create a new code cell, then paste the copied code into the new code cell.
### Deleting Cells
Sometimes, you may find you want to delete a code or markdown cell.
To delete a cell, click on it to select it and then click the scissors / *cut selected cells* toolbar button.
### Deleting and moving lines of code in a code cell
To delete one of more particular lines of code in a code cell, highlight just that line or lines of code and use the keyboard delete key to delete them.
To move one or more lines of code in a code cell, highlight them to select them, cut them using your normal keyboard cut command (for example, `ctrl-x` or `cmd-x`), place the cursor where you want them to go, and paste them using your normal keyboard paste command (for example, `ctrl-v` or `cmd-v`).
## 1.5 Activity: Working with comments
In a computer programme, a *comment* refers to a line of explanatory text that is not executed when the programme runs. As such, it does not have to conform to the syntax of the programming language once it has be identified as a comment.
In a Python programme, a comment is identified by prefixing a line of text or a line of code with a `#` (a "hash", or in US English, "pound") character.
```python
# A Python comment line is prefixed by a # (hash) character
```
If you run the following code cell, the contents of which should look like this:
```python
# This is a comment
print('Hello')
#print("Commented out code lines are not executed.")
```
you will see that the first commented out line is ignored, the second line prints out the word `Hello`, and the third line is also ignored.
```python
# This is a comment
print('Hello')
#print("Commented out code lines are not executed.")
```
*Uncommenting* a line refers to removing the initial character that identifies the line as a comment line.
__DO__: *un*comment the second print statement in the code cell above by deleting the `#` character in from of it, and rerun the code cell. You should see that both messages are displayed.
If a comment line would work in uncommented form as a line of code, rather than being a more general line of human readable text, it will often be referred to as being "commented out".
If you hear the phrase "comment out that line", it thus refers to leaving the line in the programme, but prefixing it with the comment character so that the line is not exectuted when the programme is run.
__DO__: comment out the first print statement in the code cell above by prefixing it with the `#` comment character and rerun the cell. This time you should only see the second print message being displayed.
__DO__: finally, uncomment the first (text comment) line in the code cell above and run the cell. This time, an error will be thrown because the first line is *not* a valid line of Python code.
### Using Comments
Comments of often used to document particular lines of code to clarify or explain their role in a program. It is good practice to keep comments as meaningful as possible.
### Block Comments
The phrase *block comment*, or the plural *comments*, is taken to refer to continous explanatory comment text that extends over several lines.
```python
# Multiple consecutive lines of comments are often referred to
# as "block comments".
#
# The syntax of some programming languages allows block comments to be defined
# simply by using special character sequences at the start and end of the comment block.
#
# In Python, one widely used convention is to delimit each line as its own comment line.
'''
Multi-line text strings can also be used as a way of "escaping" lines of text
so that it is not executed.
Such strings are identified by using three single (or double) quotes at the start of the
text string, and three matching single (or double) quotes at the end of the string.
If a text string appears as the last item in a Jupyter notebook code cell,
it will be returned and displayed as the cell output if the cell is run.
Run this code cell to see what I mean...
'''
```
### Using comments in other ways
As well as being used to annotate a program with helpful information, comments can also be used to provide visual clues to the division of lines or chunks of code. For example, you might use a comment to identify separate sections of programme from each other. This technique can be used to make your programs easier to read.
### Using Notebook Markdown Cells to Narrate a Programme Code and Programme Development
As well as commenting code within a code cell, you can also make notes in a Jupyter notebook's markdown cells. For example, you might use markdown cells:
- to describe what you aim to achieve with the code in a following code cell;
- to describe the output produced by running a prior code cell;
- to reflect on the behaviour of a code executed in a prior code cell, for example, if it does not work as expected.
Remember, the *notebooks are yours*, so use them for making your own notes as you work through them.
### Saving a RoboLab program
When writing notebooks it is good practice to save them periodically.
Notebooks are typically saved with the `.ipynb` filetype suffix. The name of the file is taken from the name set in the notebook header. (You can change the notebook name by clicking on the notebook name, which will pop up a *Rename notebook* dialogue.
<img src="../images/Section_00_01_-_Jupyter_Notebook_rename.png" width=600 />
When you make changes to a notebook, either by editing a code or markdown cell, or by running one or more code cells, you may notice that an `(unsaved changes)` message appears at the top of the notebook
<img src="../images/Section_00_01_-_unsaved changes.png" width=600 />
The notebook will be automatically saved every minute or two. When it is autosaved saved, the status will change:
<img src="../images/Section_00_01_-_autosaved.png" width=600 />
You can also do a "hard save" of your notebook by clicking on the *Save and checkpoint* notebook toolbar button or, from the *File* menu, seleting @Save and checkpoint*. You can also save the notebook to a new file name from the *File -> Save As...* menu option. The *File -> Make a Copy* option will create a copy of the current notebook.
<img src="../images/Section_00_01_-checkpointed.png" width=600 />
Checkpoints are useful because they not only autosave the notebook to the current file, but they also save a hidden copy of the notebook in a checkpoints directory. The *File -> Revert to Checkpoint* menu option allows you to reload the previously checkpointed notebook. This is handy if you have made some changes to your notebook, those changes have been autosaved, and you find you want to revert to the previous version of the notebook where you made a conscious decision to save and checkpoint it.
It's not uncommon to see that you have been working on a noebook for quite some time since consciously saving it!
<img src="../images/Section_00_01_-_checkpoint.png" width=600 />
## 1.6 Activity: Completing the square
In this activity, you need to have the program you worked with in the previous activity already open in RoboLab. If you don’t, open it now by running the code cell that contains the simulator and simulator magic import commands:
```python
from nbev3devsim import ev3devsim_nb as eds
%load_ext nbev3devsim
```
and the command to create and display the simulator widget:
```python
roboSim = eds.Ev3DevWidget()
display(roboSim)
```
*TO DO - are we going to have a simulator button in the toolbar?*
Make a copy of the earlier code cell in which you programmed the robot to draw one edge of a square and then turn through a right angle and paste it below:

In the new code cell, copy the lines of code to drive the robot forward and turn through ninety degrees, and paste the copy below the original lines.

What do you think your programme will do now?

Run the programme in the sinulator to find out.

*Note that copying and pasting code is a tried and trusted technique. Do not be averse to reusing any code your have developed previously and that behaves as you expect.*


#### My Observations


When I ran my version of the programme (see below) the robot drew two sides of a square as an L shape and had made the turn ready to start a third edge.

```python
%%sim_magic_preloaded

# Draw a square


# First edge and turn

# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)

# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.846)



# Second edge and turn

# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)


# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.846)
```

### Extending your programme further

Now extend your programme further so that the robot draws all four sides of a square.

(Either modify your programme in an earlier code cell, or make a copy of the earlier code cell, paste it here, and work in the newly copied cell: your notebook, your rules...!)

What do you notice about the programme? If you want to change the size of the square's side length, for example, or modify the angle turned by the robot, how easy is it to modifiy your programme?


Run your program several times, with the pen down and without clearing the trace between runs. Note how any errors compound as you run the programme multiple times.

You may notice that it is easier to "tune" the value of the rotation count required to turn the robot through ninety degrees when the robot turns mutliple times, becuase it is easier to see where, and by how much, the turn undershoots or overshoots the right angle.

Increasing the length of the side of the square can also help reveal when the angle is slightly off the right angle.


#### My Observations


Here is my programme. On multiple runs, it seems to overshoot the turn slightly.

```python
%%sim_magic_preloaded

# Draw a square


# First edge and turn

# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)

# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.846)



# Second edge and turn

# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)


# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.846)


# Third edge and turn

# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)

# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.846)



# Fourth edge and turn

# Set the left and right motors in a forward direction
# and run for 1 rotation
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(50), 1)


# Set the robot to turn on the spot
# and run for 1 rotation *of the wheels*
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.846)
```

In terms of the programme's design, I used comments to split out the code for each side, but there does seem to be a lot of repetition. If I want to change the side length or the angle turned, I need to make changes in lots of different places. If I had to draw a regular shape with twenty or thirty sides, things would start to get really unwieldly!

## Summary


In this notebook you have learned how to make use of the notebooks for creating your own simulated robot control programmes and running them in the robot simulator.

You have seen how sequential programmes can be used to instruct a robot to perform a series of tasks, one after the other.

For simple, rote tasks, that may already be quite useful. But in the approach we have taken so far, there does appear to be a lot of repetition in the code.

Surely there's a better way..?


## Addendum

The following might be useful as a redux later on to this activity; it uses the gyro to perform the turn with quite a nice graceful turn.

```python
%%sim_magic
from ev3dev2.motor import MoveTank, SpeedPercent, OUTPUT_B, OUTPUT_C
from ev3dev2.sensor import INPUT_4
from ev3dev2.sensor.lego import GyroSensor

# Sequential program with gyro turn

tank_drive = MoveTank(OUTPUT_B, OUTPUT_C)

time_1s = 1

# Set the left and right motors in a forward direction
# and run for 1 second
tank_drive.on_for_seconds(SpeedPercent(50), SpeedPercent(50), time_1s)


gyro = GyroSensor(INPUT_4)

target_angle = gyro.angle + 90
tank_drive.on(SpeedPercent(50), SpeedPercent(-50))
while gyro.angle < target_angle:
    pass
```
---

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} Reset the notebook style
from IPython.core.display import display, HTML

display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:50\PYGZpc{} !important; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))


\PYGZsh{}Launch the simulator
from nbev3devsim import ev3devsim\PYGZus{}nb as eds
\PYGZpc{}load\PYGZus{}ext nbev3devsim

roboSim = eds.Ev3DevWidget()
display(roboSim)
roboSim.element.dialog();
\end{sphinxVerbatim}
}


\subsection{2 Constants and variables in programs}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:2-Constants-and-variables-in-programs}}\label{\detokenize{content/01_Robot_Lab/Section_00_02::doc}}

\subsubsection{2.1 An introduction to constants in computer programs}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:2.1-An-introduction-to-constants-in-computer-programs}}
Various elements of the code in the following code cell may be familiar to you from the previous notebook: it’s code for a programme that is intended to cause the robot to traverse a square path in the simulator, and and that should allow the simulated robot to draw something approximating a square if you check the \sphinxstyleemphasis{pen down} setting when the program runs.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

\PYGZsh{} Try to draw a square

\PYGZsh{}Go straight
\PYGZsh{} Set the left and right motors in a forward direction
\PYGZsh{} and run for 1 rotation
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(40), SpeedPercent(40), 1)

\PYGZsh{}Turn
\PYGZsh{} Set the robot to turn on the spot
\PYGZsh{} and run for a certain number of rotations *of the wheels*
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(40), 0.826)

\PYGZsh{}Go straight
\PYGZsh{} Set the left and right motors in a forward direction
\PYGZsh{} and run for 1 rotation
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(40), SpeedPercent(40), 1)

\PYGZsh{}Turn
\PYGZsh{} Set the robot to turn on the spot
\PYGZsh{} and run for a certain number of rotations *of the wheels*
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(40), 0.826)

\PYGZsh{}Go straight
\PYGZsh{} Set the left and right motors in a forward direction
\PYGZsh{} and run for 1 rotation
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(40), SpeedPercent(40), 1)

\PYGZsh{}Turn
\PYGZsh{} Set the robot to turn on the spot
\PYGZsh{} and run for a certain number of rotations *of the wheels*
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(40), 0.826)

\PYGZsh{}Go straight
\PYGZsh{} Set the left and right motors in a forward direction
\PYGZsh{} and run for 1 rotation
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(40), SpeedPercent(40), 1)

\PYGZsh{}Turn
\PYGZsh{} Set the robot to turn on the spot
\PYGZsh{} and run for a certain number of rotations *of the wheels*
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(40), 0.826)
\end{sphinxVerbatim}
}

The number \sphinxcode{\sphinxupquote{0.826}} given for the number of rotations used when turning the robot, the steering setting (\sphinxcode{\sphinxupquote{\sphinxhyphen{}100}}) and the various speeds (\sphinxcode{\sphinxupquote{40}}) are all examples of a \sphinxstyleemphasis{literal value}, a number that is given explicitly in the program.

When writing computer programs it is bad practice to litter them with literal numbers like these. One reason is that the programmer may easily forget what the numbers mean, and if another programmer has to maintain the program, they will find it very hard to do so. Another reason is that using literal values can be inflexible, particularly if you need to use the same number at several points in the programme, as we have done in the above example.

You will see a better approach to referring to numbers in the next section.


\paragraph{Question}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Question}}
In the program above, there are multiple occurrences of the number \sphinxcode{\sphinxupquote{40}}. Do they all mean the same thing?


\paragraph{Answer}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Answer}}
In one sense, yes, they are all motor speed percentage values; but in another sense, no: four of them refer to the speed of the left motor when driving forwards, four to the right motor speed for the same command, and four of them relate to the speed of both motors during the turn.


\subparagraph{Literals can make life difficult}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Literals-can-make-life-difficult}}
Suppose you want the robot to turn more slowly than it currently does to see if this affects the rotation count value you need to set to turn the robot through a right angle.

To do this, you would have to change the motor speed in each of the four turn instructions. You might then have to modify each of the four turn rotation count values so the robot itself continues to turn through roughly ninety degrees.

And then suppose you wanted to see if doing the turn \sphinxstyleemphasis{faster} rather than slower made the robot more or less accurate when trying to set the turn rotation value.

It could be a lot of work, couldn’t it? And possibly prone to error, making all those changes.

You have already seen how you could use a loop to simplify the square drawing programme, but you would still be having to delve into the depths of the programme to change the values? And the values would still be \sphinxstyleemphasis{literal} values. So how can we improve things?


\subparagraph{Optional Activity}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Optional-Activity}}
Try changing the turn speed in the programme to see if it makes any difference to the precision with which the robot turns through ninety degrees. If it does, try setting the turn rotation count so that the robot draws something close to a square, if not an exact square, once again.


\subsubsection{2.2 Activity: Working with constants and variables}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:2.2-Activity:-Working-with-constants-and-variables}}
If you tried changing the motor speeds, you possibly found that you also had to change the turn roations value too. And you probably also discovered that changing each numerical constant individually can be quite time\sphinxhyphen{}consuming. How much better it would be if they could all be changed at the same time. This can be achieved by \sphinxstyleemphasis{declaring} a constant in your programme.

In some programming languages, \sphinxstyleemphasis{constants} are named items that are assigned a particular value once and once only in a programme, and this value remains unchanged as the programme executes. \sphinxstyleemphasis{Variables}, on the other hand, are named items whose value may be set at the start of a programme, but whose value may also change as the programme executes.

\sphinxstyleemphasis{By convention}, in many Python programmes, if we want to refer to an item with a value that is intended to be a fixed, \sphinxstyleemphasis{constant} value as the programme runs, we create a \sphinxstyleemphasis{variable} but with an UPPERCASE name.

In the following code cell, I have replaced the literal values “inside” the programme with “constants” that are defined are the start of the programme.

If you download and run the programme, it should behave as before.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

\PYGZsh{} Try to draw a square
STEERING = \PYGZhy{}100
TURN\PYGZus{}ROTATIONS = 0.826
TURN\PYGZus{}SPEED = 40

STRAIGHT\PYGZus{}SPEED\PYGZus{}PC = SpeedPercent(40)
STRAIGHT\PYGZus{}ROTATIONS = 1

\PYGZsh{}Go straight
\PYGZsh{} Set the left and right motors in a forward direction
\PYGZsh{} and run for 1 rotation
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}ROTATIONS)

\PYGZsh{}Turn
\PYGZsh{} Set the robot to turn on the spot
\PYGZsh{} and run for a certain number of rotations *of the wheels*
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(STEERING, SpeedPercent(TURN\PYGZus{}SPEED), TURN\PYGZus{}ROTATIONS)

\PYGZsh{}Go straight
\PYGZsh{} Set the left and right motors in a forward direction
\PYGZsh{} and run for 1 rotation
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}ROTATIONS)

\PYGZsh{}Turn
\PYGZsh{} Set the robot to turn on the spot
\PYGZsh{} and run for a certain number of rotations *of the wheels*
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(STEERING, SpeedPercent(TURN\PYGZus{}SPEED), TURN\PYGZus{}ROTATIONS)

\PYGZsh{}Go straight
\PYGZsh{} Set the left and right motors in a forward direction
\PYGZsh{} and run for 1 rotation
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}ROTATIONS)

\PYGZsh{}Turn
\PYGZsh{} Set the robot to turn on the spot
\PYGZsh{} and run for a certain number of rotations *of the wheels*
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(STEERING, SpeedPercent(TURN\PYGZus{}SPEED), TURN\PYGZus{}ROTATIONS)

\PYGZsh{}Go straight
\PYGZsh{} Set the left and right motors in a forward direction
\PYGZsh{} and run for 1 rotation
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}ROTATIONS)

\PYGZsh{}Turn
\PYGZsh{} Set the robot to turn on the spot
\PYGZsh{} and run for a certain number of rotations *of the wheels*
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(STEERING, SpeedPercent(TURN\PYGZus{}SPEED), TURN\PYGZus{}ROTATIONS)
\end{sphinxVerbatim}
}

Note that I have used two slightly different approach to define the turn speed and the straight speed. In the case of the turn speed, I have defined \sphinxcode{\sphinxupquote{TURN\_SPEED = 40}}, setting the constant to a value that is passed to the \sphinxcode{\sphinxupquote{SpeedPercent()}} function. For the straight speed, \sphinxcode{\sphinxupquote{STRAIGHT\_SPEED\_PC = SpeedPercent(40)}}, I used a slightly different naming convention and defined the “constant” as a \sphinxcode{\sphinxupquote{SpeedPercent()}} value directly.

When the programme is executed in the simulator, the value of the “constant” into the code is used in the same way as the literal value.

However, if we want to try running the programme using different robot speeds or turn rotation values, we can now do so very straightforwardly, simply by changing the requierd values in a single place, once for each “constant” value, at the top of the programme.

Modify the above programme using different values for the constants, then download and run the programme in the simulator. How much easier is it to explore different values now?


\subsubsection{Activity: Robo Lab challenge}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Activity:-Robo-Lab-challenge}}
In the simulator, load the \sphinxstyleemphasis{Square} background.

The challenge is to get the robot to go round the outside of the solid grey square and stay within the outer square boundary, without the robot touching either the inner square or the outside square border loop, in the shortest time possible.

\sphinxstyleemphasis{Hint: you may find it useful to use the previous programme for traversing a square, or create your own programme using a for loop and sone or more “constants”.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

\PYGZsh{} YOUR CODE HERE
\end{sphinxVerbatim}
}


\paragraph{Answer}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:id1}}
\sphinxstyleemphasis{Click on the arrow in the sidebar to reveal my answer.}

I tried to simplify the programme by using a \sphinxcode{\sphinxupquote{for}} loop to generate each side and turn. I used “constants” to define the motor speeds and the number of wheel rotations required when driving in a straight line for the edges, and durig the turns.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

SIDES = 4

\PYGZsh{} Try to draw a square
STEERING = \PYGZhy{}100
TURN\PYGZus{}ROTATIONS = 0.826
TURN\PYGZus{}SPEED = 40

STRAIGHT\PYGZus{}SPEED\PYGZus{}PC = SpeedPercent(40)
STRAIGHT\PYGZus{}ROTATIONS = 6

for side in range(SIDES):
    \PYGZsh{}Go straight
    \PYGZsh{} Set the left and right motors in a forward direction
    \PYGZsh{} and run for 1 rotation
    tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}SPEED\PYGZus{}PC, STRAIGHT\PYGZus{}ROTATIONS)

    \PYGZsh{}Turn
    \PYGZsh{} Set the robot to turn on the spot
    \PYGZsh{} and run for a certain number of rotations *of the wheels*
    tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(STEERING, SpeedPercent(TURN\PYGZus{}SPEED), TURN\PYGZus{}ROTATIONS)

\end{sphinxVerbatim}
}


\subparagraph{Optimising}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Optimising}}
If you have not already done so, try adjusting the values of \sphinxcode{\sphinxupquote{forwardTime}} so that the robot goes as close as possible to the grey square without touching it. Don’t spend too long on this.

Save your modified program with the name \sphinxcode{\sphinxupquote{my\_square\_challenge}}. Then take a look at \sphinxcode{\sphinxupquote{Square\_challenge\_solution}} to compare your version with mine.


\bigskip\hrule\bigskip



\subsubsection{2.4 Activity: Working with variables}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:2.4-Activity:-Working-with-variables}}
How many coins have you got on you? At the moment I have 12 coins in my pocket. (You might say: I have four tappable cards / phone devices!)

I could write:

\sphinxcode{\sphinxupquote{number\_of\_coins\_in\_my\_pocket = 12}}

If I buy lunch using five of these coins, there are only seven left. So I could write:

\sphinxcode{\sphinxupquote{number\_of\_coins\_in\_my\_pocket = 7}}

At any time the number of coins in my pocket varies, and the name \sphinxcode{\sphinxupquote{number\_of\_coins\_in\_my\_pocket}} is an example of what is called a \sphinxstyleemphasis{variable} when used in computer programs.

The value of a variable can change as the program executes. Contrast this with a constant which is intended to remain unchanged while the program executes.


\paragraph{SAQ — Question}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:SAQ-_u2014-Question}}
Which of the following are intended as constants (that is, things that arenlt intended to change and which are variables (that is, they are quite likely to change)? Stylistically, how might we represent constants ad variables in a Pyhton programme so that we can distinguish between them?

\sphinxcode{\sphinxupquote{number\_of\_coins\_in\_my\_pocket}}

\sphinxcode{\sphinxupquote{the\_number\_of\_pennies\_in\_a\_pound}}

\sphinxcode{\sphinxupquote{the\_diameter\_of\_robots\_wheels}}

\sphinxcode{\sphinxupquote{the\_distance\_robot\_travels\_in\_a\_second}}.


\paragraph{Answer}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:id2}}
\sphinxstyleemphasis{Click the arrow in the sidebar to reveal the answer.}

The amount of money in my pocket varies all the time, so if this were used in a computer program it would be a variable.

The number of pennies in a pound is always a hundred, so this would be a constant.

A robot’s wheels might be 50 mm in diameter and this would be a constant. (A different robot might have different size wheels, but their size will not vary while the program executes.)

You may have wondered whether the distance a robot travels in a second is best represented as a constant or a variable. For a robot that could speed or slow its drive motors or change gear, and where this value may be used to report the speed of the robot, this would certainly be a variable. But for a simple robot (like the simulated one) with a fixed gear drive travelling at a constant speed we might used the value to \sphinxstyleemphasis{define} a fixed property of the robot in which case it would make more sense
to treat it as a constant, albeit one that we might wish to “tweak” or modify as we did in the programmes above.

Stylistically, by convention, we use upper case characters to identify constants and lower case characters to represent variables. So for example, we might define the constant values \sphinxcode{\sphinxupquote{PENNIES\_IN\_A\_POUND}} or \sphinxcode{\sphinxupquote{WHEEL\_DIAMETER}}.


\subparagraph{Using Variables}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Using-Variables}}
Anything that will not change during the execution of the program should be defined as a constant, and anything that may change should be viewed as a variable.

Variables are an essential ingredient of computer programs. They allow the computer to store the value of things at a given instant of time.

You have already seen how variables can change their value as a programme executes using the \sphinxcode{\sphinxupquote{nbtutor}} extension.

Let’s look again at how that works.

First, load in the \sphinxcode{\sphinxupquote{nbtutor}} extension by running the following code cell:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}load\PYGZus{}ext nbtutor
\end{sphinxVerbatim}
}

Now let’s use the \sphinxcode{\sphinxupquote{nbtutor}} visualisation to follow what happens to the values of the \sphinxcode{\sphinxupquote{counter}} and \sphinxcode{\sphinxupquote{previous}} variables as the following programme executes.

Run the code cell, then step through each line of code a line at a time using the \sphinxcode{\sphinxupquote{nbtutor}} \sphinxstyleemphasis{Next \textgreater{}} button.

Observe how the previously executed line, identified by the green arrow, modifies the value of the variables. Also note how the program flow progresses by comparing the location of the previously executed line with the next line (red arrow).

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force
counter = 0

while counter \PYGZlt{} 5:
    print(counter)
    previous = counter
    counter += 1

counter, previous
\end{sphinxVerbatim}
}


\subsubsection{Updating Variables from Sensor Values}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Updating-Variables-from-Sensor-Values}}
Load the \sphinxstyleemphasis{Grey bands} background in to the simulator, and download and run the following programme, which you may recall from the previous notebook. Observe the values of that are displayed in the simulator output window.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
from ev3dev2.sensor import INPUT\PYGZus{}2

tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

colorLeft = ColorSensor(INPUT\PYGZus{}2)

sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

while sensor\PYGZus{}value \PYGZgt{} 99:
    print(sensor\PYGZus{}value)
    sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

print(\PYGZdq{}I now see \PYGZob{}\PYGZcb{}\PYGZdq{}.format( colorLeft.reflected\PYGZus{}light\PYGZus{}intensity))
tank\PYGZus{}drive.off()
\end{sphinxVerbatim}
}

In the programme, the \sphinxcode{\sphinxupquote{colorLeft.reflected\_light\_intensity}} element represents a variable that describes the current value of a particulalry configured robot sensor. We then set another variable, \sphinxcode{\sphinxupquote{sensor\_value}}equal to the value of that sensor variable.

From the simululator output display, we see that the \sphinxcode{\sphinxupquote{sensor\_value}} changes as the robot crosses the grey lines. But there is nothing explicitly stated in the program where \sphinxstyleemphasis{we} update the \sphinxcode{\sphinxupquote{colorLeft.reflected\_light\_intensity}} value. Rather, it’s value is updated “live” from a regular poll of the sensor within the simulator.

\sphinxstyleemphasis{By polling a sensor, we mean that a reading is taken from the sensor, somehow(!) and used to set the value of a variable associated with that sensor so we can make decisions based on the sensor value from within our robot control program.}


\subsubsection{Summary}
\label{\detokenize{content/01_Robot_Lab/Section_00_02:Summary}}
In this notebook, you have seen how we can use constants and variables in a programme to take literal values out of the body of a programme and replace them by meaningfully named terms defined at the top of the programme. This can improve readability of a programme, as well as making it easier to maintain and update.

Although Python doesn’t really do constants, by convention we can refer to terms we want to treat as constant valus by using upper cases characters when naming them.

When a programme executes, the value of variables may be updated by programme statements.

In a robot context, variables may also be associated with things like particular sensors, in which case we think of the sensor itself updating the value of the variable.


\section{Session 02 — RoboLab}
\label{\detokenize{index:session-02-robolab}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} Run this cell to set up the robot simulator environment

\PYGZsh{}Reset the notebook style
from IPython.core.display import display, HTML

display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:50\PYGZpc{} !important; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))


\PYGZsh{}Launch the simulator
from nbev3devsim import ev3devsim\PYGZus{}nb as eds
\PYGZpc{}load\PYGZus{}ext nbev3devsim

roboSim = eds.Ev3DevWidget()
display(roboSim)
roboSim.element.dialog();
\end{sphinxVerbatim}
}


\subsection{1 Introduction to loops and branches}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:1-Introduction-to-loops-and-branches}}\label{\detokenize{content/02_Robot_Lab/Section_00_01::doc}}
Loops and branches are powerful constructs in programming, and they are used extensively in almost all computer programs. In this lab session, I will introduce the different loop and branch statements provided by RoboLab. You will have an opportunity to see how they are used by working through the activities. We end the session with a number of challenges for you to attempt. These will give you practice in selecting and using different RobotLab statements.


\subsection{2 Loops}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:2-Loops}}

\subsubsection{2.1 An introduction to loops in computer programs}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:2.1-An-introduction-to-loops-in-computer-programs}}
To illustrate the idea of a loop it is helpful to use a swimming analogy. Suppose you want to swim 20 lengths of a swimming pool. The chances are you will want to monitor your progress by keeping count of the number of lengths you complete. So, at the start, your personal counter (you) will be set to ‘0’. After one length of the pool you add 1 to your counter. You also ask yourself ‘have I done 20 lengths yet?’ If the answer is ‘no’, you ‘loop back’ to swim another length. On completion of the
second length you add 1 to your counter and ask yourself the question again. If the answer is ‘no’ you loop back and repeat the process once more. You keep going like this until the answer to the question is ‘yes’, at which point you will have completed 20 lengths of the pool and the loop will end:

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen,height=165\sphinxpxdimen]{{c388562b622a14a53d5f64193c02b536f7a91f88}.jpg}



Mermaid code https://mermaid-js.github.io/mermaid-live-editor/
The mermaid editor is supposed to encode/decode base 64 strings
but I can't get my own encoder/decoder to work to encode/decode things the same way?

graph LR
    A(Start) --> B[Set the count to 0]
    B --> C[Swim a length]
    C --> D[Add 1 to the count]
    D --> E{Is the<br/>count less<br/>than 20?}
    E --> |Yes| C
    E --> |No| F(End)

Long description:

A flow chart for a person swimming 20 lengths of a pool. The flow chart starts with n oval shape labelled ‘Start’. From here there are sequences of boxes connected by arrows: first ‘set the count to zero’, then ‘swim a length’ and last ‘add 1 to the count’. From this box an arrow leads to a decision diamond labelled ‘is the count less than 20?’ Two arrows lead from this, one labelled ‘yes’, the other ‘no’. The ‘yes’ branch leads back to rejoin the box ‘swim a length’. The ‘no’ branch leads directly to an oval shape labelled ‘end’. There is thus a loop in the chart which includes the steps ‘swim a length’ and ‘add 1 to the count’ and ends with the decision ‘is the count less than 20?’

As another example, consider a person ironing clothes. The loop starts with the person looking in the basket. Then a decision has to be made: are there any clothes left? If there are, the person must go round the loop: take out an item and iron it, put it on the pile of ironed clothes, and look in the basket again. When there are no clothes left in the basket the loop ends.

\sphinxhref{https://mermaid-js.github.io/mermaid-live-editor/\#/edit/eyJjb2RlIjoiZ3JhcGggVERcbiAgICBBKFN0YXJ0KSAtLT4gQltTZXQgY291bnRlciB0byAwXVxuICAgIEIgLS0-IENbIyBEcmF3IHNpZGU8YnIvPi4uLmNvZGUuLi5dXG4gICAgQyAtLT4gRFsjIFR1cm4gbmluZXR5IGRlZ3JlZXM8YnIvPi4uLmNvZGUuLi5dXG4gICAgRCAtLT4gRVtBZGQgMSB0byBjb3VudGVyXVxuICAgIEUgLS0-IEZ7SXMgdGhlIGNvdW50ZXIgPCA0fVxuICAgIEYgLS0-IHxZZXN8IENcbiAgICBGIC0tPiB8Tm98IEcoRW5kKSIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9}{\sphinxincludegraphics[width=245\sphinxpxdimen,height=777\sphinxpxdimen]{{3a0334d3b1eca3f922a412053ef5c495be85b6d6}.jpg}}



Mermaid drawing (this is far from ideal...Maybe better to use draw.io?)

graph LR
    A(Start) --> B{Any clothes<br>left in<br/>basket?}
    B --> |Yes| C[Take out<br/>item and<br/>iron]
    C --> D[Put it on pile<br/>of ironed<br/>clothes]
    D --> B
    B --> |No| E(End)

Long desc:

A flow chart for a person ironing clothes. This starts with an oval ‘start’. An arrow leads to a decision diamond ‘any clothes left in the basket?’ Two arrows lead from this, one labelled ‘yes’, the other ‘no’. The ‘yes’ branch continues in turn to two boxes ‘take out item and iron it’ and ‘put it on the ironed pile of clothes’; an arrow leads back from this box to rejoin the decision ‘any clothes left in the basket?’ The ‘no’ branch leads directly to an oval ‘end’. There is thus a loop in the chart which begins with the decision ‘any clothes left in the basket?’ and includes the steps ‘take out item and iron it’ and ‘put it on the ironed pile of clothes’.

As you have seen, a sequential computer program is a sequence of lines of encoded commands, to be executed one after the other.

For example, the program to move a robot around a square course consisted of the following sequence of instructions repeated four times:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Draw side}
\PYG{n}{tank\PYGZus{}drive}\PYG{o}{.}\PYG{n}{on\PYGZus{}for\PYGZus{}seconds}\PYG{p}{(}\PYG{n}{SIDE\PYGZus{}SPEED}\PYG{p}{,} \PYG{n}{SIDE\PYGZus{}SPEED}\PYG{p}{,} \PYG{n}{SIDE\PYGZus{}TIME}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Turn ninety degrees}
\PYG{n}{tank\PYGZus{}turn}\PYG{o}{.}\PYG{n}{on\PYGZus{}for\PYGZus{}rotations}\PYG{p}{(}\PYG{n}{STEERING}\PYG{p}{,} \PYG{n}{TURN\PYGZus{}SPEED}\PYG{p}{,} \PYG{n}{TURN\PYGZus{}ROTATIONS}\PYG{p}{)}
\end{sphinxVerbatim}

How much easier it would be just to give these commands once, and tell the computer to loop back to the start, repeating until the instructions have been executed four times?

\sphinxhref{https://mermaid-js.github.io/mermaid-live-editor/\#/edit/eyJjb2RlIjoiZ3JhcGggVERcbiAgICBBKFN0YXJ0KSAtLT4gQltTZXQgY291bnRlciB0byAwXVxuICAgIEIgLS0-IENbIyBEcmF3IHNpZGU8YnIvPi4uLmNvZGUuLi5dXG4gICAgQyAtLT4gRFsjIFR1cm4gbmluZXR5IGRlZ3JlZXM8YnIvPi4uLmNvZGUuLi5dXG4gICAgRCAtLT4gRVtBZGQgMSB0byBjb3VudGVyXVxuICAgIEUgLS0-IEZ7SXMgdGhlIGNvdW50ZXIgPCA0fVxuICAgIEYgLS0-IHxZZXN8IENcbiAgICBGIC0tPiB8Tm98IEcoRW5kKSIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9}{\sphinxincludegraphics[width=245\sphinxpxdimen,height=777\sphinxpxdimen]{{3a0334d3b1eca3f922a412053ef5c495be85b6d6}.jpg}}



graph TD
    A(Start) --> B[Set counter to 0]
    B --> C[# Draw side<br/>...code...]
    C --> D[# Turn ninety degrees<br/>...code...]
    D --> E[Add 1 to counter]
    E --> F{Is the counter < 4}
    F --> |Yes| C
    F --> |No| G(End)

Long desc:

A flow chart for a robot program with a loop. This starts with an oval ‘start’. An arrow leads first to a box ‘set a counter to 0’ and then to a sequence of further boxes: ‘# Draw side’ with an implication of the code associated with that, ‘# Turn ninety degrees’, agin with a hint regarding the presnce of code associated with that activity, and lastly ‘add 1 to the counter’. The arrow from this box leads to a decision diamond ‘is the counter < 4?’ Two arrows lead from this, one labelled ‘yes’, the other ‘no’. The ‘yes’ branch loops back to rejoin the sequence at ‘# Draw side code’. The ‘no’ branch leads directly to an oval ‘end’. There is thus a loop in the chart which includes the sequence of motor control commands, incrementing the counter and ends with the decision ‘is the counter &lt; 4?’.

Python gives you two main ways of implementing loops:
\begin{itemize}
\item {} 
a \sphinxcode{\sphinxupquote{for...in...}} loop;

\item {} 
a \sphinxcode{\sphinxupquote{while ...}} loop.

\end{itemize}

The \sphinxcode{\sphinxupquote{for...in...}} loop checks the status of an \sphinxstyleemphasis{iterator}, which is capable of returning items from a list of values, one at a time. If the list is empty, the looping ends. If the iterator is not empty, the programme flow passes to the first instruction inside the \sphinxcode{\sphinxupquote{for...in...}} code block, otherwise it passes to the next instruction at the same block (indentation) level as the \sphinxcode{\sphinxupquote{for...in...}} statement.

The \sphinxcode{\sphinxupquote{while...}} loop tests the truth value of a statement. If the statement evaulates as \sphinxcode{\sphinxupquote{True}}, the programme flow passes into the body of the loop, otherwise it proceeds to the next statement at the same block (indentation) level as the \sphinxcode{\sphinxupquote{while...}} statement.

Let’s see how each of these constructs works in turn, first using a simple, pure Python example, then in the context of our simulated robot.


\subsubsection{Using a \sphinxstyleliteralintitle{\sphinxupquote{for...in...}} loop}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Using-a-for...in...-loop}}
A \sphinxcode{\sphinxupquote{for...in...}} loop takes each item from a list of items (or a more general Python \sphinxstyleemphasis{iterator} object), one at a time, then enters the loop, until the list (or iterator) is empty.

In “pseudo\sphinxhyphen{}code” (that is, a human readable set of instructions that look like a form of stylised code), the \sphinxcode{\sphinxupquote{for...in...}} loop behaves as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{each} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{turn} \PYG{o+ow}{in} \PYG{n}{a} \PYG{n+nb}{list} \PYG{n}{of} \PYG{n}{items}\PYG{p}{,} \PYG{n}{do} \PYG{n}{the} \PYG{n}{following} \PYG{n}{sequence} \PYG{n}{of} \PYG{n}{instructions}

  \PYG{p}{\PYGZob{}}

  \PYG{n}{instruction} \PYG{l+m+mi}{1}

  \PYG{n}{instruction} \PYG{l+m+mi}{2}

  \PYG{n}{instruction} \PYG{l+m+mi}{3}

  \PYG{n}{etc}\PYG{o}{.}
  \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Note that any of the instructions inside the loop may make use of the current value of the item that has just been retrieved from the list.

When the loop has finished, the value of the last item retrieved from the list will continue to be available.

Run the following code cell to see how the \sphinxcode{\sphinxupquote{for...in...}} loop retrieves one item at a time from a list of items (line 1), enters the code block within the loop starting at line 2, executes each line 2\sphinxhyphen{}3 in turn, then returns to line 1 to get the next item from the list.

When all the items have been retrieved from the list, the programme flow moves on to next item at the same indentation as the \sphinxcode{\sphinxupquote{for...in...}} loop, which is to say line 4:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}for item in [\PYGZsq{}one\PYGZsq{}, \PYGZsq{}two\PYGZsq{}, \PYGZsq{}three\PYGZsq{}, \PYGZsq{}fish\PYGZsq{}]:
    print(item)
    print(\PYGZsq{} and \PYGZsq{})

print(\PYGZsq{}All done...\PYGZsq{})
\end{sphinxVerbatim}
}

It is also worth noting that the value of the \sphinxcode{\sphinxupquote{item}} variable is the value of the last item to be retrieved from the list, as you can see if you display the value by running the following code cell:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}item
\end{sphinxVerbatim}
}

We can use the \sphinxcode{\sphinxupquote{nbtutor}} extension to step thrhough the programme exectution to see what exactly is going on.

Run the following code cell to load in the \sphinxcode{\sphinxupquote{nbtutor}} magic:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}load\PYGZus{}ext nbtutor
\end{sphinxVerbatim}
}

The \sphinxcode{\sphinxupquote{\%\%nbtutor}} cell block magic can be used to prefix Python code (but \sphinxstyleemphasis{not} code intended for the simulator) we want to step through.

\sphinxstylestrong{TO DO: the \textasciigrave{}\textasciigrave{}nbtutor\textasciigrave{}\textasciigrave{} display is low contrast and perhaps inaccessible. I started a}\sphinxhref{https://github.com/lgpage/nbtutor/issues/37}{related issue}\sphinxstylestrong{but this needs addressing somewhere.}

One thing to note about the notebook environment is that if we have already created any Python variables in the current notebook, they will be displayed by default in the \sphinxcode{\sphinxupquote{\%\%nbtutor}} visualisation.

We can limit the variables that are displayed by \sphinxcode{\sphinxupquote{nbtutor}} by calling the magic using the command \sphinxcode{\sphinxupquote{\%\%nbtutor \sphinxhyphen{}\sphinxhyphen{}reset \sphinxhyphen{}\sphinxhyphen{}force}}.

Run the following code cell to invoke the \sphinxcode{\sphinxupquote{nbtutor}} widget, and then use the \sphinxcode{\sphinxupquote{Next}} button in the \sphinxstyleemphasis{cell toolbar} that is created to step through each line of code in turn.

Observe the progress of the control flow through the code via the two differently coloured arrows that show the next line to be executed (red line) and the previous line to be executed (green arrow). Also notice how the statement previously executed may update the value of \sphinxcode{\sphinxupquote{item}} variable as a consequence of its execution.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force
for item in [\PYGZsq{}one\PYGZsq{}, \PYGZsq{}two\PYGZsq{}, \PYGZsq{}three\PYGZsq{}, \PYGZsq{}fish\PYGZsq{}]:
    print(item)
    print(\PYGZsq{} and \PYGZsq{})

print(\PYGZsq{}All done...\PYGZsq{})
\end{sphinxVerbatim}
}

Did you notice how the program flow repeatedly went from the last line of the code inside the \sphinxcode{\sphinxupquote{for..in..}} block back up to the \sphinxcode{\sphinxupquote{for..in..}} statement, before going from the \sphinxcode{\sphinxupquote{for..in..}} statement to the final \sphinxcode{\sphinxupquote{print(\textquotesingle{}All done..\textquotesingle{})}} statement when the loop had iterated through all the items in the list?

Close the \sphinxcode{\sphinxupquote{nbtutor}} cell toolbar view by clicking on the notebook toolbar \sphinxcode{\sphinxupquote{View}} menu option, selecting \sphinxcode{\sphinxupquote{Cell Toolbar}} and then \sphinxcode{\sphinxupquote{None}}.


\paragraph{Activity}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Activity}}
See if you can write a simple programme that loops through a list of days of the week, print out a message of the form ‘day 1 is Monday’ followed by “day 2 is Tuesday’, and so on.

\sphinxstyleemphasis{Hint: Python f\sphinxhyphen{}strings (“formatted strings” or “formatted string literals”) provide a convenient way of getting the value of a variable into a string. For example, if you have a variable \textasciigrave{}\textasciigrave{}day\_of\_week = “Monday”\textasciigrave{}\textasciigrave{}, we can display a message using the construction \textasciigrave{}\textasciigrave{}print(f”Today is \{day\_of\_week\}”)\textasciigrave{}\textasciigrave{}. The \textasciigrave{}\textasciigrave{}f”…”\textasciigrave{}\textasciigrave{} construction denotes the f\sphinxhyphen{}string. The curly brace brackets (\textasciigrave{}\textasciigrave{}\{..\}\textasciigrave{}\textasciigrave{}) contain the name of a variable whose value you want to substitute into the string. Note that f\sphinxhyphen{}strings are not
available in the simulator’s Python implementation.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} YOUR CODE HERE
\end{sphinxVerbatim}
}


\subparagraph{Answer}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Answer}}
\sphinxstyleemphasis{Click on the arrow in the sidebar to reveal my answer}

First I created a counter value, then I created a list containing the days of the week. Using a \sphinxcode{\sphinxupquote{for..in..}} loop, I iterated through the list. Inside the loop, I incremented a counter, then displayed the required message.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}counter = 0

for day in [\PYGZsq{}Monday\PYGZsq{}, \PYGZsq{}Tuesday\PYGZsq{}, \PYGZsq{}Wednesday\PYGZsq{},
            \PYGZsq{}Thursday\PYGZsq{}, \PYGZsq{}Friday\PYGZsq{}, \PYGZsq{}Saturday\PYGZsq{}, \PYGZsq{}Sunday\PYGZsq{}]:

    counter += 1
    print(f\PYGZdq{}Day \PYGZob{}counter\PYGZcb{} is \PYGZob{}day\PYGZcb{}\PYGZdq{})
\end{sphinxVerbatim}
}


\paragraph{Using a \sphinxstyleliteralintitle{\sphinxupquote{for..in..}} Loop in a Robot Control Program}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Using-a-for..in..-Loop-in-a-Robot-Control-Program}}
Loops are very useful when it comes to executing repetitive tasks.

You may remember from the programme we use to draw a square that there was a lot of repeated code, with the same code used to draw a single side and then turn through a right angle repeated four times each. At the time, you may have tought “there must be a better way than this?” and the use of a loop provides just such a better way.

Look through the code in the code cell below and predict what you think the robot will do when it runs that programme.

\sphinxstyleemphasis{DOUBLE CLICK this cell to edit it and enter your prediction of what the robot will do as it runs through the programme.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

\PYGZsh{} Draw something...
for count in range(3):

    \PYGZsh{}Go straight
    \PYGZsh{} Set the left and right motors in a forward direction
    \PYGZsh{} and run for 1 rotation
    tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(50), SpeedPercent(50), 1)

    \PYGZsh{}Turn
    \PYGZsh{} Set the robot to turn on the spot
    \PYGZsh{} and run for a certain number of rotations *of the wheels*
    tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 0.846)

\end{sphinxVerbatim}
}

Now run the code cell to download the programme to the robot. With the pen trace enabled, run the programme in the simulator and observe what happens. Was your predcition correct?

Modify the programme (if necessary…) so that the robot will trace out something close to a square (don’t spend too much time trying to make it perfect: that may not be possible!). Clear the trace in the simulator, reset the robot location, and download and run the programme again to check your programme modification worked.


\paragraph{Returning to the top of a loop early}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Returning-to-the-top-of-a-loop-early}}
Sometimes we may want to to return to the top of a loop from within a loop code block \sphinxstyleemphasis{before} we have executed all the lines in the looped block. We can do this using the \sphinxcode{\sphinxupquote{continue}} instruction.

Run the following code cell and step through each line of code a line at a time using the \sphinxcode{\sphinxupquote{nbtutor}} \sphinxstyleemphasis{Next} button. Watch the programme flow particularly closely when the \sphinxcode{\sphinxupquote{item}} variable takes the value \sphinxcode{\sphinxupquote{three}}.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force
for item in [\PYGZsq{}one\PYGZsq{}, \PYGZsq{}two\PYGZsq{}, \PYGZsq{}three\PYGZsq{}, \PYGZsq{}fish\PYGZsq{}]:
    print(item)
    if item==\PYGZsq{}three\PYGZsq{}:
        continue
    print(\PYGZsq{} and \PYGZsq{})

print(\PYGZsq{}All done...\PYGZsq{})
\end{sphinxVerbatim}
}


\paragraph{Conditional Tests Using the Conditional Construct, \sphinxstyleliteralintitle{\sphinxupquote{if}}…}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Conditional-Tests-Using-the-Conditional-Construct,-if_u2026}}
In the previous programme, you may have noticed another new statement, an \sphinxcode{\sphinxupquote{if}} statement. This is another sort of conditional statement. The \sphinxcode{\sphinxupquote{if}} statement will test a logical condition and if it evaluates as \sphinxcode{\sphinxupquote{True}} programme flow will pass to any statements contained within the \sphinxcode{\sphinxupquote{if}} statement block.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{LOGICAL\PYGZus{}TEST\PYGZus{}STATEMENT}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}if the LOGICAL\PYGZus{}TEST\PYGZus{}STATEMENT evaluates as True}
    \PYG{c+c1}{\PYGZsh{} run the following command}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The statement was True...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This will always be printed...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

In and of itself, the \sphinxcode{\sphinxupquote{if}} statement is tested once and once only. \sphinxstyleemphasis{If} the conditional test pass, control flows into the body of the \sphinxstyleemphasis{if} statement and then on to the next statement after the \sphinxstyleemphasis{if} construct. If the conditional test evaluates as false, control passes immediately to the next statement \sphinxstyleemphasis{after} the if block.

In the \sphinxcode{\sphinxupquote{if}} statement, the \sphinxcode{\sphinxupquote{==}} sign is used to test whether the value of the thing on the left is the same as the value of the thing on the right.

So the following is \sphinxcode{\sphinxupquote{True}}:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}1 == 1
\end{sphinxVerbatim}
}

because numeric \sphinxcode{\sphinxupquote{1}} does indeed equal numeric \sphinxcode{\sphinxupquote{1}}; but the following evaluates as \sphinxcode{\sphinxupquote{False}} because numeric \sphinxcode{\sphinxupquote{1}} \sphinxstyleemphasis{does not} equal the string \sphinxcode{\sphinxupquote{one}}:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}1 == \PYGZsq{}one\PYGZsq{}
\end{sphinxVerbatim}
}

The following is also \sphinxcode{\sphinxupquote{False}} because the \sphinxstyleemphasis{numeric} value \sphinxcode{\sphinxupquote{1}} is \sphinxstyleemphasis{not} the same as the \sphinxstyleemphasis{string} value \sphinxcode{\sphinxupquote{\textquotesingle{}1\textquotesingle{}}}:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}1 == \PYGZsq{}1\PYGZsq{}
\end{sphinxVerbatim}
}

However, the following string values \sphinxstyleemphasis{are} equivalent even though we used different string delimiters (single quotes in the first case, double quotes in the second) to create them:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsq{}1\PYGZsq{} == \PYGZdq{}1\PYGZdq{}
\end{sphinxVerbatim}
}

Try experimenting with you own equivalent, or unequivalent, statements in the code cell below.

\sphinxstyleemphasis{Feel free to create more code cells if you want to keep a record of things you have tried. Or comment out each line after you have tried it if you want to try mutliple statements in the same code cell.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} TRY SOME EQUIVALENT AND UNEQUIVALENT STATEMENTS OF YOUR OWN HERE


\end{sphinxVerbatim}
}


\paragraph{Activity}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:id1}}
Suppose Wednesday is early closing day. Building on elements from your earlier programme that displays the days of the week, modify the programme to use a \sphinxcode{\sphinxupquote{continue}} statement so that it prints out the message \sphinxstyleemphasis{I could go shopping on DAY afternoon} for every day except Wednesday.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} YOUR ANSWER HERE
\end{sphinxVerbatim}
}


\subparagraph{Answer}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:id2}}
\sphinxstyleemphasis{Click on the arrow in the sidebar to reveal my answer.}

I used a simple \sphinxcode{\sphinxupquote{if}} statement to check if it was Wednesday, and if it was, the \sphinxcode{\sphinxupquote{continue}} statement passed the programme control flow back to the top of the loop \sphinxstyleemphasis{before} the programme had a chance to print out that day of the week.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}for day in [\PYGZsq{}Monday\PYGZsq{}, \PYGZsq{}Tuesday\PYGZsq{}, \PYGZsq{}Wednesday\PYGZsq{},
            \PYGZsq{}Thursday\PYGZsq{}, \PYGZsq{}Friday\PYGZsq{}, \PYGZsq{}Saturday\PYGZsq{}, \PYGZsq{}Sunday\PYGZsq{}]:

    if day==\PYGZsq{}Wednesday\PYGZsq{}:
        continue
    print(f\PYGZdq{}I could go shopping on \PYGZob{}day\PYGZcb{} afternoon.\PYGZdq{})
\end{sphinxVerbatim}
}


\paragraph{Escaping from a Loop Early}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Escaping-from-a-Loop-Early}}
As well as returning back to the top of a loop early using a \sphinxcode{\sphinxupquote{continue}} statement, we may sometimes want to escape from a loop altogether before the loop would normally finish. We can achieve this using the \sphinxcode{\sphinxupquote{break}} statement, which breaks the control flow oout of a loop when it is encountered.

Run the following code cell, stepping through it a line at a time, again paying particulalry close attention when the \sphinxcode{\sphinxupquote{item}} variable has the value \sphinxcode{\sphinxupquote{three}}:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}nbtutor
for item in [\PYGZsq{}one\PYGZsq{}, \PYGZsq{}two\PYGZsq{}, \PYGZsq{}three\PYGZsq{}, \PYGZsq{}fish\PYGZsq{}]:
    print(item)
    if item==\PYGZsq{}three\PYGZsq{}:
        break
    print(\PYGZsq{} and \PYGZsq{})

print(\PYGZsq{}All done...\PYGZsq{})
\end{sphinxVerbatim}
}


\paragraph{Activity \sphinxhyphen{} Escape from a \sphinxstyleliteralintitle{\sphinxupquote{for...in...}} loop}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Activity---Escape-from-a-for...in...-loop}}
Suppose we get weekends off. Using a \sphinxcode{\sphinxupquote{break}} construct inside a \sphinxcode{\sphinxupquote{for..in...}} loop, create a simple programme that takes a list containing the days of the week in order \sphinxstyleemphasis{Monday}…\sphinxstyleemphasis{Sunday} and displays the message \sphinxstyleemphasis{DAY is a workday…} for days Monday to Friday, but then breaks out of the loop when it realises it is Friday.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} YOUR CODE HERE
\end{sphinxVerbatim}
}


\subparagraph{Answer}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:id3}}
\sphinxstyleemphasis{Click on the arrow in the sidebar to reveal my answer.}

In this case, I display the print message before I break out of the loop using the \sphinxcode{\sphinxupquote{break}} statement:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}for day in [\PYGZsq{}Monday\PYGZsq{}, \PYGZsq{}Tuesday\PYGZsq{}, \PYGZsq{}Wednesday\PYGZsq{},
            \PYGZsq{}Thursday\PYGZsq{}, \PYGZsq{}Friday\PYGZsq{}, \PYGZsq{}Saturday\PYGZsq{}, \PYGZsq{}Sunday\PYGZsq{}]:
    print(f\PYGZdq{}\PYGZob{}day\PYGZcb{} is a workday.\PYGZdq{})
    if day==\PYGZsq{}Friday\PYGZsq{}:
        break
\end{sphinxVerbatim}
}


\subsubsection{Using a \sphinxstyleliteralintitle{\sphinxupquote{while...}} loop}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Using-a-while...-loop}}
A \sphinxcode{\sphinxupquote{while...}} loop tests the truth of a statement on each iteration of the loop. In “pseudo code”, the bevaiour can be described as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{do} \PYG{n}{the} \PYG{n}{following} \PYG{n}{sequence} \PYG{n}{of} \PYG{n}{instructions} \PYG{k}{while} \PYG{n}{a} \PYG{n}{condition} \PYG{n}{holds}

 \PYG{p}{\PYGZob{}}

 \PYG{n}{instruction} \PYG{l+m+mi}{1}

 \PYG{n}{instruction} \PYG{l+m+mi}{2}

 \PYG{n}{instruction} \PYG{l+m+mi}{3}

 \PYG{n}{instruction} \PYG{l+m+mi}{4}

 \PYG{n}{instruction} \PYG{l+m+mi}{5}

 \PYG{n}{etc}

 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In some respects the \sphinxcode{\sphinxupquote{while}} resembles an \sphinxcode{\sphinxupquote{if}} statement in that if (while) the tested condition is true, control passes into the body of the while statment block, and if it evaluates false, control passes immediately to the next statement after the while block. However, \sphinxstyleemphasis{unlike} the \sphinxcode{\sphinxupquote{if}} statement, when all the statements inside the \sphinxcode{\sphinxupquote{while}} block have been executed, in sequential order, control does not then flow to the next statement after the while block, it passes back to the top of
the while loop and the condition is re\sphinxhyphen{}evaluated.

In this way, the programme can keep repeating the lines of code inside the while block until some condition is met, or some condition fails.

Note that if the conditionally tested value changes to a value that would cause the condition to evaluate as false whilst the programme flow is inside the while block, the statements insde the while block will continue to execute in sequential order. Control only passes from the while statement to the statement after the while block at the point when control passes to the while statement and its condition is tested and found to evaluate as false.

Let’s see an example of how to use a \sphinxcode{\sphinxupquote{while}} loop to help us keep track of whether we have counted up to a particular number yet as you will see if you run the programme in the following code cell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force}
\PYG{n}{counter} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{k}{while} \PYG{n}{counter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{counter}\PYG{p}{)}
    \PYG{n}{counter} \PYG{o}{=} \PYG{n}{counter} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{}Display the final value of counter}
\PYG{n}{counter}
\end{sphinxVerbatim}

Uncomment the \sphinxcode{\sphinxupquote{\%\%nbtutor}}cell magic by deleting the \sphinxcode{\sphinxupquote{\#}} symbol at the start of the first line and run the previous cell again to step through the code as it executes a line at a time.

Observe how the program flow repeatedly moves from the last line of the code inside the \sphinxcode{\sphinxupquote{while}} block back up to the \sphinxcode{\sphinxupquote{while}} statement, before going from the \sphinxcode{\sphinxupquote{while}} statement to the final \sphinxcode{\sphinxupquote{counter}} statement when the conditional tests eventually evaluate as false.


\paragraph{Activity \sphinxhyphen{} Use a \sphinxstyleliteralintitle{\sphinxupquote{while}} Loop}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Activity---Use-a-while-Loop}}
The Python \sphinxcode{\sphinxupquote{random}} functon from the \sphinxcode{\sphinxupquote{random}} package is capabale of generating a random number between 0 and 1, as you will see if you run the following cell repeatedly. (The package is only imported once despite multiple calls to it.)

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import random

random.random()
\end{sphinxVerbatim}
}

We can think of this as a coin toss, where we toss “heads” for values greater than or equal to 0.5, or tails for a random value between 0 and 1 that is less than 0.5.

Write a simple while loop that tests a simulated coin toss for as long as it tosses the equivalent of “heads”, printing “heads” for each successful toss.

Run the code cell several times to see what happens.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} Add your code here
\end{sphinxVerbatim}
}


\subparagraph{Answer}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:id4}}
\sphinxstyleemphasis{Click on the arrow in the sidebar to reveal my answer.}

To test the coin toss, we are looking for a random value of greater than or equal to 0.5, which is to say, a value of \sphinxcode{\sphinxupquote{random.random() \textgreater{}= 0.5}}.

We can use this as a conditional test in a \sphinxcode{\sphinxupquote{while}} loop. In the body of the loop, we print “heads” to show we are in the loop.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}while random.random() \PYGZgt{}= 0.5:
    print(\PYGZdq{}heads\PYGZdq{})
\end{sphinxVerbatim}
}

Running the cell multiple times, sometimes nothing is printed (if the “coin” flips as “tails”, that is, the first random value is \sphinxstyleemphasis{less than} 0.5); at other times, we may get one or more “heads” displayed. (The most I saw in several attempts was eight heads in a row!)


\paragraph{Infinite Loops}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Infinite-Loops}}
We can create a special sort loop known as an \sphinxstyleemphasis{infinite loop} using the \sphinxcode{\sphinxupquote{while True:}} construction, where the statement \sphinxcode{\sphinxupquote{True}} \sphinxstyleemphasis{always} evaluates as \sphinxcode{\sphinxupquote{True}} and so the loop repeats until the program is forced to stop or the flow is forced out of the loop and onto the next instruction using a \sphinxcode{\sphinxupquote{break}} statement.

The following code cell demonstrates how to escape an otherwise infinite loop by using a \sphinxcode{\sphinxupquote{break}} statement. Run the cell to see how it works. (Uncomment the \sphinxcode{\sphinxupquote{nbtutor}} magic to step through it a line at a time as it executes.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force
counter = 0

while True:
    counter = counter + 1
    print(counter)
    if counter == 5:
        break

print(f\PYGZdq{}We escaped at counter==\PYGZob{}counter\PYGZcb{}\PYGZdq{})
\end{sphinxVerbatim}
}


\paragraph{Using a \sphinxstyleliteralintitle{\sphinxupquote{while}} loop in the simulator}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Using-a-while-loop-in-the-simulator}}
Being able to loop \sphinxstyleemphasis{whilst} a particular condition is holds allows us to perform actions \sphinxstyleemphasis{until} that condition no londer holds.

This may be particularly useful in a robot programming context, as the following simple example demonstrates.

In the simulator, load in the \sphinxstyleemphasis{Grey bands} background and reset the trace. (You can also disable the \sphinxstyleemphasis{pen down} control: we don’t need to keep track of where the robot has travelled for this activity.)

Run the following code cell to download the programme to the simulator and then run it in the simulator, observing the behaviour of the robot.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
from ev3dev2.sensor import INPUT\PYGZus{}2

tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

colorLeft = ColorSensor(INPUT\PYGZus{}2)

sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

while sensor\PYGZus{}value \PYGZgt{} 99:
    print(sensor\PYGZus{}value)
    sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

print(\PYGZdq{}I now see \PYGZob{}\PYGZcb{}\PYGZdq{}.format( colorLeft.reflected\PYGZus{}light\PYGZus{}intensity))
tank\PYGZus{}drive.off()
\end{sphinxVerbatim}
}

When you run the programme in the simulator, the robot should drive forwards until it encounters the first, light grey line, and then it should stop.

\sphinxstyleemphasis{Although the robot will stop, by default, when the programme ends, becuase the simulator run stops at the end of the programme, it is often good practice to explicitly turn the motors off yourself. By doing this, you know for sure what state the motors are in at the end of the programme. In the above example, what would happen if, for some reason, the motor off command was omitted and the simulator carried on running even as the programme execution had completed?}

The programme works by checking the value from one of the robot’s sensors, a downward facing light sensor, which you will meet in more detail in a later notebook. The sensor returns a “reflected light” sensor, a percentage value which relates to the colour of the background canvas over which the robot is travelling. The simulator output display window shows the sensor value, starting at \sphinxcode{\sphinxupquote{100}} when the robot is on the plain white background. This value is above the conditionally tested
threshold value of \sphinxcode{\sphinxupquote{99}} used in the original programme’s \sphinxcode{\sphinxupquote{while}} statement, and so the programme continues looping round the while loop. When the robot encounters the first grey line, the sensor returns a lower value of just over 87 when I ran the programme.

\sphinxstyleemphasis{Rather than testing and reporting the \textasciigrave{}\textasciigrave{}colorLeft.reflected\_light\_intensity\textasciigrave{}\textasciigrave{} value directly, the programme is constructed as it is because the sensor value may change in going from the \textasciigrave{}\textasciigrave{}while\textasciigrave{}\textasciigrave{} programme step to the \textasciigrave{}\textasciigrave{}print()\textasciigrave{}\textasciigrave{} step. Even though computers may step between lines of code very quickly, they still take a finite time to do so.}

Try modifying the numerical value used in the \sphinxcode{\sphinxupquote{while}} conditional test and downloading and running the modified programme. Can you get the robot to stop as soomn as it encounters the second medium grey band? On the third, dark grey line? On the final, black line?


\subsubsection{Activity: Changing a loop variable count up to 10}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Activity:-Changing-a-loop-variable-count-up-to-10}}
As well as programming the siunulated robot to respond to a sensor value, we can also get it to count aloud.

The following programme, for example, when downloaded to the simulator, will cause the robot (?!) to count aloud.

Can you get the robot to count to 10, rather than 5?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic

\PYGZsh{}Counting robot...
import playsound

count = 1

while count \PYGZlt{} 5:
    \PYGZsh{} The playsound.say() function expects a string...
    playsound.say(str(count))
    count = count + 1
\end{sphinxVerbatim}
}


\subsubsection{Summary}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Summary}}
In this notebook, you have seen how we can control the way in which programme statements are executed in a programme by using various programme flow control constructs and how we can use the \sphinxcode{\sphinxupquote{nbtutor}} extension to step through and monitor the flow of simple Python programmes executing in the notebook’s Python environment (unfortunately, it does not allow us to step through code we download into the simulator).

Regarding the programme control flow, you have seen how:
\begin{itemize}
\item {} 
the \sphinxcode{\sphinxupquote{for..in..}} loop allows a the programme to work through a set of statements in the loop body once for each item in a list of values or “iterator” construct;

\item {} 
the \sphinxcode{\sphinxupquote{if...}} conditional command checks a logical condition once and once only; if the tested condition evaluates true, control passes inside the block, and then continues after the if block. If the condition evaluates as false, control passes immediately to the statement after the if block;

\item {} 
the \sphinxcode{\sphinxupquote{while...}} loop allows us to repeatedly test a condition, and if it is found to be true, pass control to a sequnece of instructions inside the while block. Once those instructions have been executed, control is passed back the top of the while loop and the test condition is evaluated again. If the while condition evaluates as false, control passes to the first statement after the while block.

\end{itemize}

Control flow in \sphinxcode{\sphinxupquote{for}} and \sphinxcode{\sphinxupquote{while}} loops can also be interrupted using \sphinxcode{\sphinxupquote{continue}} and \sphinxcode{\sphinxupquote{break}} statements.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{continue}} prematurely forces the flow of control back to the top of the loop, rather than requiring all the instructions in the loop to execute and then passing control back to the top of the loop;

\item {} 
\sphinxcode{\sphinxupquote{break}} prematurely forces the flow of control out of the loop to the next statement after the loop block, rather than requiring control to be passed following the failure of the conditional test at the top of the loop.

\end{itemize}

Control flow instructions are part of the core Python language and are used in a similar way inside in the simulator and the “native” notebook Python environment.


\subsubsection{Addendum}
\label{\detokenize{content/02_Robot_Lab/Section_00_01:Addendum}}
The robot simulator speech action is built up from a Javascript function that builds on a built\sphinxhyphen{}in browser function for creating speech utterances. We can force the Jupyter notebook to run Javascript code in the browser from a code cell using the \sphinxcode{\sphinxupquote{\%\%javascript}} cell magic. This means we can get the browser to “speak” by callng the browser speech functions via Javascript directly.

\sphinxstyleemphasis{Note that there may be a brief delay between running the code cell and hearing the speech utterance.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{o}{\PYGZpc{}}\PYG{o}{\PYGZpc{}}\PYG{n+nx}{javascript}
\PYG{n+nx}{speechSynthesis}\PYG{p}{.}\PYG{n+nx}{speak}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{SpeechSynthesisUtterance}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}hello\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
}

We can also create a simple wrapper around a Javascript call that we can use in a Jupyter notebook context to speak, via the browser, from a Python statement:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from IPython.display import Javascript

class Speech():
    def say(self, txt):
        display(Javascript(f\PYGZsq{}speechSynthesis.speak(new SpeechSynthesisUtterance(\PYGZdq{}\PYGZob{}txt\PYGZcb{}\PYGZdq{}))\PYGZsq{}))

speaker = Speech()
speaker.say(\PYGZsq{}hello\PYGZsq{})
\end{sphinxVerbatim}
}

The Python \sphinxcode{\sphinxupquote{pyttxsx}} package is capable of creating speech utterances which can be called directly from a notebook code cell, although access to audio drivers is not directly available in this virtual environment, so the package as it currently stands is mute.

However, as a guide, if we create a building block around the package:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import pyttsx3

class NativeSpeech():
    def \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}(self):
        self.engine = pyttsx3.init()
    def say(self, txt):
        if isinstance(txt, int) or isinstance(txt, float):
            txt = str(txt)
        self.engine.say(txt)
        self.engine.runAndWait()
\end{sphinxVerbatim}
}

we could then trigger utterances with calls of the form \sphinxcode{\sphinxupquote{NativeSpeech().say(\textquotesingle{}hello\textquotesingle{})}}.

As before, there may be a brief delay between running the code cell and hearing the speech utterance.

Run the following code cell to hear Python speak to you:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}speaker = NativeSpeech()
speaker.say(\PYGZsq{}hello\PYGZsq{})
speaker.say(1)
speaker.say(\PYGZdq{}2.5\PYGZdq{})
speaker.say(2.5)
speaker.say(\PYGZsq{}goodbye\PYGZsq{})
\end{sphinxVerbatim}
}

We can also create a simple Python programm to count aloud up to 10, for example by using a \sphinxcode{\sphinxupquote{while}} loop:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}n = 1

while n \PYGZlt{}= 10:
    speaker.say(n)
    n = n + 1
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from nbev3devsim import ev3devsim\PYGZus{}nb as eds
import jp\PYGZus{}proxy\PYGZus{}widget

\PYGZsh{}Load the nbtutor extension
\PYGZpc{}load\PYGZus{}ext nbtutor

\PYGZsh{}https://github.com/AaronWatters/jp\PYGZus{}doodle/blob/master/notebooks/misc/JQueryUI\PYGZpc{}20dialogextend\PYGZpc{}20plugin\PYGZpc{}20demo.ipynb
\PYGZsh{}Load and initialise the jquery.dialogextend package

cdn\PYGZus{}url = \PYGZdq{}https://cdn.jsdelivr.net/npm/binary\PYGZhy{}com\PYGZhy{}jquery\PYGZhy{}dialogextended@1.0.0/jquery.dialogextend.js\PYGZdq{}
cdn\PYGZus{}url = eds.get\PYGZus{}file\PYGZus{}path(\PYGZsq{}js/jquery.dialogextend.js\PYGZsq{})
module\PYGZus{}id = \PYGZdq{}dialogExtend\PYGZdq{}

\PYGZsh{} Load the module using a widget (any widget \PYGZhy{}\PYGZhy{} the module loads to the global jQuery object).
loader = jp\PYGZus{}proxy\PYGZus{}widget.JSProxyWidget()

\PYGZsh{} Configure the module to be loaded.
loader.require\PYGZus{}js(module\PYGZus{}id, cdn\PYGZus{}url)

\PYGZsh{} Load the module
loader.js\PYGZus{}init(\PYGZdq{}\PYGZdq{}\PYGZdq{}
    element.requirejs([module\PYGZus{}identifier], function(module\PYGZus{}value) \PYGZob{}
        //element.html(\PYGZdq{}loaded \PYGZdq{} + module\PYGZus{}identifier + \PYGZdq{} : \PYGZdq{} + module\PYGZus{}value);
    \PYGZcb{});
\PYGZdq{}\PYGZdq{}\PYGZdq{}, module\PYGZus{}identifier=module\PYGZus{}id)
loader
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from nbev3devsim import ev3devsim\PYGZus{}nb as eds

\PYGZsh{}Reset the notebook style
from IPython.core.display import display, HTML, Javascript

\PYGZsh{}display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} resize:vertical; border: 5px solid;  width: 300px; resize: horizontal; overflow: auto; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))
display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:50\PYGZpc{}; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))

\PYGZsh{}Launch the simulator
from nbev3devsim import ev3devsim\PYGZus{}nb as eds
\PYGZpc{}reload\PYGZus{}ext nbev3devsim

roboSim = eds.Ev3DevWidget()

roboSim.element.dialog();


roboSim.js\PYGZus{}init(\PYGZdq{}\PYGZdq{}\PYGZdq{}
element.dialog(\PYGZob{} \PYGZdq{}title\PYGZdq{} : \PYGZdq{}Robot Simulator\PYGZdq{} \PYGZcb{}).dialogExtend(\PYGZob{}
        \PYGZdq{}maximizable\PYGZdq{} : true,
        \PYGZdq{}dblclick\PYGZdq{} : \PYGZdq{}maximize\PYGZdq{},
        \PYGZdq{}icons\PYGZdq{} : \PYGZob{} \PYGZdq{}maximize\PYGZdq{} : \PYGZdq{}ui\PYGZhy{}icon\PYGZhy{}arrow\PYGZhy{}4\PYGZhy{}diag\PYGZdq{} \PYGZcb{}\PYGZcb{});
\PYGZdq{}\PYGZdq{}\PYGZdq{})

display(roboSim)
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{o}{\PYGZpc{}}\PYG{o}{\PYGZpc{}}\PYG{n+nx}{javascript}
\PYG{c+c1}{//This allows us to resize this view}
\PYG{c+c1}{//Click on the right hand edge to drag}
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}notebook\PYGZhy{}container\PYGZdq{}} \PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{resizable}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n+nx}{ghost}\PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}load\PYGZus{}ext nbtutor
\PYGZpc{}load\PYGZus{}ext nbev3devsim
\end{sphinxVerbatim}
}


\subsection{3 Branches}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:3-Branches}}\label{\detokenize{content/02_Robot_Lab/Section_00_02::doc}}
So far we have concentrated mainly on sequential programs, where the flow of control proceeds through the program statements in linear sequence, except when it encounters loop element where the control flow is redirected back “up” the program to the start of a loop block.

In the previous notebook, you saw how the conditional \sphinxcode{\sphinxupquote{if..}} statement could be used to optionally pass control to a set of instructions in the sequential programme \sphinxstyleemphasis{if} a particular condition was met.

The \sphinxcode{\sphinxupquote{if...}} statement fits the the sequential program model by redirecting control flow, albeit briefly, to a set of “extra” commands if the conditional test evaluates true.

A sequential program will always follow the same sequentially order path. But to be useful, a robot program will often need to make decisions and behave differently in different circumstances. To do this, the program has to have alternative \sphinxstyleemphasis{branches} in the programme flow where we can follow different courses of actions depending on some conditional test.

Python provides an \sphinxcode{\sphinxupquote{if..else..}} statement to do just that, and you will see how it is used in the following activities.

\sphinxstyleemphasis{In other programming languages, this may often be referred to as an \textasciigrave{}\textasciigrave{}if…then…else…\textasciigrave{}\textasciigrave{} construct. In Python, the “then” is assumed.}


\subsubsection{3.1 Activity: Detecting black and grey}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:3.1-Activity:-Detecting-black-and-grey}}
Load the \sphinxstyleemphasis{Grey and black} background into the simulator.

Download the programme to the simulator and then run it several times with the robot moved to different starting positions.

What does the programme cause the robot to do?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

import playsound

\PYGZsh{} Configure a light sensor
colorLeft = ColorSensor(INPUT\PYGZus{}2)

\PYGZsh{} Start the robot driving forwards
tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

\PYGZsh{}Sample the light sensor reading
sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

\PYGZsh{}Check the light sensor reading
while sensor\PYGZus{}value == 100:
    \PYGZsh{} Whilst we are on the white background
    \PYGZsh{} update the reading
    sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    \PYGZsh{} and display it
    print(sensor\PYGZus{}value)

\PYGZsh{} When the reading is below 100
\PYGZsh{} we have started to see something.
\PYGZsh{} Drive a little way onto the band to get a good reading
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(50), SpeedPercent(50), 0.2)

\PYGZsh{}Check the sensor reading
sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
\PYGZsh{} and display it
print(sensor\PYGZus{}value)

\PYGZsh{} Now make a decision about what we see
if sensor\PYGZus{}value \PYGZlt{} 50:
    playsound.say(\PYGZdq{}I see black\PYGZdq{})
else:
    playsound.say(\PYGZdq{}I see grey\PYGZdq{})
\end{sphinxVerbatim}
}


\paragraph{Question}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Question}}
What does the robot do?


\paragraph{Answer}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Answer}}
\sphinxstyleemphasis{Click the arrow in the sidebar to reveal the answer.}

The robot moves forward over the white background until it reaches the grey or black area. If the background is black, the robot says \sphinxstyleemphasis{black}; otherwise, it says \sphinxstyleemphasis{grey}.

The programme works by driving the robot forwards and continues in that direction while it is over the white background (a reflected light sensor reading of 100). When the light sensor reading goes below the white background value of 100, control passes out of the while loop and on to the statement that drives the robot forwards a short distance further (0.2 wheel rotations) to ensure the sensor is fully over the band. The robot then checks its sensor reading, and makes a decision about what to
say based on the value of the sensor reading.


\subparagraph{Working through the programme flow}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Working-through-the-programme-flow}}
The following flow chart shows how the flow of control passes through the programme.

\noindent\sphinxincludegraphics[width=371\sphinxpxdimen,height=823\sphinxpxdimen]{{03803416f197f52b725c20fbe4d65ae9fac8eb55}.jpg}

Although the \sphinxcode{\sphinxupquote{while}} command does appear to offer some sort of branch like behaviour, will still think of it as a sequential style operator becuase the flow of control keeps trying to move in the same forwards direction.

In the branching \sphinxcode{\sphinxupquote{if..else..}} operator, the program control flow takes one of two different “forward flowing” paths depending on whether the conditional statement evaluated as part of the \sphinxcode{\sphinxupquote{if..}} statement evaluates true or false.

If it evaluates \sphinxcode{\sphinxupquote{True}}, then the statements in the first “if” block of code are evaluate; if the condition evaluates \sphinxcode{\sphinxupquote{False}}, then the statements in the \sphinxcode{\sphinxupquote{else}} block are evaluated. In both cases, contorl then flows forwards to the next statement after the \sphinxcode{\sphinxupquote{if..else..}} block.



# Mermaid.js code

graph TD
    A(Start) --> B[Move forwards]
    B --> C{Light == 100}
    C --> |Yes| D[Display reading]
    D --> C
    C --> |No| E[Drive forward<br/>a short way]
    E --> F{Light < 50?}
    F --> |Yes| G[Say 'black']
    F --> |No| H[Say 'grey']
    G --> I(End)
    H --> I


\subsubsection{Activity: Stepping Through An \sphinxstyleliteralintitle{\sphinxupquote{if..else...}} Statement}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Activity:-Stepping-Through-An-if..else...-Statement}}
In this activity we will look at another program to explore how \sphinxcode{\sphinxupquote{if...else..}} works in more detail.

Inspect the code in the following cell? If you run the code cell, what do you think will happen?

\sphinxstyleemphasis{Double click this cell to edit it and make your prediction here.}

Once you have made your prediction, run the following cell, and in the markdown cell beneath it, record what happened and how it compared to your prediction.

\sphinxstyleemphasis{You may find it informative to use \textasciigrave{}\textasciigrave{}nbtutor\textasciigrave{}\textasciigrave{} to step through each line of code in turn to see how the programme flow progresses. To do this, uncomment the \textasciigrave{}\textasciigrave{}\%\%nbtutor\textasciigrave{}\textasciigrave{} magic in the first line of the code cell by deleting the \textasciigrave{}\textasciigrave{}\#\textasciigrave{}\textasciigrave{} at the start of the line before running the code cell.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force
x = 1

if x == 1:
    print(\PYGZdq{}x equals 1\PYGZdq{})
else:
    print(\PYGZdq{}x does not equal 1\PYGZdq{})

print(\PYGZdq{}All done...\PYGZdq{})
\end{sphinxVerbatim}
}

\sphinxstyleemphasis{Double click this cell to edit it and record here what happened when you ran the code in the above cell. Did its behaviour match your prediction?}

What do you think will happen when you run the following code cell?

Run the cell and use \sphinxstyleemphasis{nbtutor} to step through the programme. How does the programme flow differ from the case where \sphinxcode{\sphinxupquote{x}} had the value \sphinxcode{\sphinxupquote{1}}?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force
x = 2

if x == 1:
    print(\PYGZdq{}x equals 1\PYGZdq{})
else:
    print(\PYGZdq{}x does not equal 1\PYGZdq{})

print(\PYGZdq{}All done...\PYGZdq{})
\end{sphinxVerbatim}
}

Click the arrow in the sidebar to reveal my observations.

In the cell where \sphinxcode{\sphinxupquote{x=1}}, I predicted that the program would print the message \sphinxstyleemphasis{‘x equals 1’} and then the messge \sphinxstyleemphasis{‘All done…’}.

Viewing the trace, I could see how the programme started by initialising the \sphinxcode{\sphinxupquote{x}} variable to the value \sphinxcode{\sphinxupquote{1}}, then checked whether \sphinxcode{\sphinxupquote{x==1}} (that is, whether \sphinxcode{\sphinxupquote{x}} was equal to \sphinxcode{\sphinxupquote{1}}); becuase it was, the programme then moved onto the \sphinxcode{\sphinxupquote{print("x equals 1")}} statement and printed the first message, then programme flow continued to the first instruction after the \sphinxcode{\sphinxupquote{if...else...}} block, which was the statement that printed the \sphinxstyleemphasis{‘All done…’} message.

When I ran the programme with a value of \sphinxcode{\sphinxupquote{x}} other then \sphinxcode{\sphinxupquote{1}}, the control passed from the \sphinxcode{\sphinxupquote{if...}} statement, where the conditional test evaluated as \sphinxcode{\sphinxupquote{False}}, to the first line in the \sphinxcode{\sphinxupquote{else..}} block, which printed the message \sphinxstyleemphasis{‘x does not equal’}, before moving on to the first line after the \sphinxcode{\sphinxupquote{if..else..}} block as before.


\subsubsection{An \sphinxstyleliteralintitle{\sphinxupquote{if..}} without an \sphinxstyleliteralintitle{\sphinxupquote{else...}}}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:An-if..-without-an-else...}}
It is sometimes useful to have just a single branch to the \sphinxcode{\sphinxupquote{if}} statement. Python provides a simple \sphinxcode{\sphinxupquote{if...}} statement for this purpose.

Run the following code cell as it stands, with the \sphinxcode{\sphinxupquote{x}} variable taking the intial value \sphinxcode{\sphinxupquote{1}} (\sphinxcode{\sphinxupquote{x=1}}). Can you predict what will happen?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force
x = 1

print(\PYGZdq{}Are you ready?\PYGZdq{})

if x == 1:
    print(\PYGZdq{}x equals 1\PYGZdq{})

print(\PYGZdq{}All done...\PYGZdq{})
\end{sphinxVerbatim}
}

Try to predict what will happen if you change the initial value and run the cell again. Was your prediction correct?

Uncomment the \sphinxstyleemphasis{\%\%nbtutor} magic and run the code cell using different values of \sphinxcode{\sphinxupquote{x}}, observing how the program flow progresses in each case.

\sphinxstyleemphasis{Click on the arrow in the sidebar to reveal my observations.}

With the initial value of the variable \sphinxcode{\sphinxupquote{x}} set to \sphinxcode{\sphinxupquote{1}} (\sphinxcode{\sphinxupquote{x = 1}}) the program displayed the messages \sphinxstyleemphasis{Are you ready?}, \sphinxstyleemphasis{x equals 1} and \sphinxstyleemphasis{All done} as the \sphinxcode{\sphinxupquote{if ...}} statement evaluated the \sphinxcode{\sphinxupquote{x == 1}} test condition as \sphinxcode{\sphinxupquote{True}} and passed control \sphinxstyleemphasis{into} the \sphinxcode{\sphinxupquote{if..}} block.

When \sphinxcode{\sphinxupquote{x}} was initialised to a different value, for example as \sphinxcode{\sphinxupquote{x = 2}}, only the messages \sphinxstyleemphasis{Are you ready?} and \sphinxstyleemphasis{All done} were displayed as the \sphinxcode{\sphinxupquote{if..}} conditional test failed and redirected control flow to the first statement \sphinxstyleemphasis{after} the \sphinxcode{\sphinxupquote{if..}} block.


\subsubsection{3.4 Activity: Combining loops and branching statements}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:3.4-Activity:-Combining-loops-and-branching-statements}}
It is important to be clear that the condition in a branching statement (\sphinxcode{\sphinxupquote{if...}} or \sphinxcode{\sphinxupquote{if...else...}}) is checked only when execution reaches that part of the program.

In the examples above, you stepped through the programs and saw that execution passed through the \sphinxcode{\sphinxupquote{if}} statement only once. When creating useful robot programs, we often want conditions to be checked repeatedly. For example the robot may need to repeatedly check that it has not bumped into an obstacle, or whether it has found a bright or dark area.

You have already seen how the \sphinxcode{\sphinxupquote{while...}} loop tests a condition at the start of a loop and and then passes control to the statements inside the loop before looping back to test the \sphinxcode{\sphinxupquote{while...}} condition again.

You may also recall from an earlier notebook that we also used an \sphinxcode{\sphinxupquote{if...}} statment to return the control flow back to the top of a loop before all the statements in the loop body had been executed, or break out of a loop early and pass control to the first statement after the loop block.

This ability to combine loop and branching statements is very powerful and even a very simple programme can produce quite a complex robot behaviour.

For example, can you predict what the following programme will cause the robot to do when it is downloaded and run in the simulator?

\sphinxstylestrong{Before you run the programme, load in the Loop background to the simulator.}

\sphinxstyleemphasis{Double click this cell to edit it and record your prediction.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

tank\PYGZus{}drive.on(SpeedPercent(30), SpeedPercent(30))

while True:
    if colorLeft.reflected\PYGZus{}light\PYGZus{}intensity \PYGZlt{} 100:
        tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(\PYGZhy{}30),
                                    SpeedPercent(\PYGZhy{}30), 2)

        tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 2)
        tank\PYGZus{}drive.on(SpeedPercent(30), SpeedPercent(30))

\end{sphinxVerbatim}
}

Download the program to the simulator and run it there to check your prediction. After a minute or two, stop the programme from executing.

How does the behaviour of the programme lead to the robot’s emergent behaviour in the simulator?


\paragraph{Discussion}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Discussion}}
\sphinxstyleemphasis{Click on the arrow in the sidebar to reveal my observations}

When the program runs, the robot will explore the inside of the black oval, remaining inside it and reversing direction each time it encounters the black line.

The program is constructed from an \sphinxcode{\sphinxupquote{if}} statement inside a \sphinxcode{\sphinxupquote{forever}} loop. The \sphinxcode{\sphinxupquote{if}} statement checks the light sensor reading; when this is low (which it will be when the black line is reached) the motor direction is reversed.

The \sphinxcode{\sphinxupquote{while True:}} loop is a so\sphinxhyphen{}called \sphinxstyleemphasis{infinite loop} that will run indefinitely. In this case it is useful because we want the robot to continue to keep on behaving in the same way as the prigramme runs.

In other circumstances, we might want the loop to continue only while some condition holds true. In such cases, using the \sphinxcode{\sphinxupquote{while}} statement to test the truth of a conitional statement is more useful.


\subsubsection{Multiple Conditions Using \sphinxstyleliteralintitle{\sphinxupquote{if..elif..else..}}}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Multiple-Conditions-Using-if..elif..else..}}
The \sphinxcode{\sphinxupquote{if...else..}} statement allows us to creating a branching control flow statement that performs on conditional test and then chooses between two alternative outcomes depending on the result of the test.

Python also supports a yet more complex branch construction in the form of an \sphinxcode{\sphinxupquote{if..elif..else..}} statement that allows us to make multiple conditional tests. Run the following code cell and then use \sphinxcode{\sphinxupquote{nbtutor}} to explore the flow through the programme.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force

days\PYGZus{}of\PYGZus{}week = [\PYGZsq{}Monday\PYGZsq{}, \PYGZsq{}Tuesday\PYGZsq{}, \PYGZsq{}Wednesday\PYGZsq{}, \PYGZsq{}Thursday\PYGZsq{},
                \PYGZsq{}Friday\PYGZsq{}, \PYGZsq{}Saturday\PYGZsq{}, \PYGZsq{}Sunday\PYGZsq{}]

for day in days\PYGZus{}of\PYGZus{}week:
    print(f\PYGZsq{}Today is \PYGZob{}day\PYGZcb{}...\PYGZsq{})

    if day == \PYGZsq{}Wednesday\PYGZsq{}:
        print(\PYGZsq{}...half day closing\PYGZsq{})
    elif day in [\PYGZsq{}Saturday\PYGZsq{}, \PYGZsq{}Sunday\PYGZsq{}]:
        print(\PYGZsq{}...the weekend\PYGZsq{})
    else:
        print(\PYGZsq{}...a weekday\PYGZsq{})

print(\PYGZdq{}And that\PYGZsq{}s all the days of the week.\PYGZdq{}\PYGZdq{})
\end{sphinxVerbatim}
}

We can also have multiple \sphinxcode{\sphinxupquote{elif}} statements between the opening \sphinxcode{\sphinxupquote{if..}} and the closing \sphinxcode{\sphinxupquote{else}}.

Read through the code in the following and try to work out what the program will do and how the control flow will pass though the program as it executes.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} TO DO
\PYGZsh{} need a simple toolbar buttom to toggle the notebook display?
from IPython.display import HTML
display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:100\PYGZpc{} !important; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))
display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:50\PYGZpc{} !important; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))

\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}nbtutor \PYGZhy{}\PYGZhy{}reset \PYGZhy{}\PYGZhy{}force

days\PYGZus{}of\PYGZus{}week = [\PYGZsq{}Monday\PYGZsq{}, \PYGZsq{}Tuesday\PYGZsq{}, \PYGZsq{}Wednesday\PYGZsq{}, \PYGZsq{}Thursday\PYGZsq{},
                \PYGZsq{}Friday\PYGZsq{}, \PYGZsq{}Saturday\PYGZsq{}, \PYGZsq{}Sunday\PYGZsq{}]

for day in days\PYGZus{}of\PYGZus{}week:
    print(f\PYGZsq{}Today is \PYGZob{}day\PYGZcb{}...\PYGZsq{})

    if day == \PYGZsq{}Monday\PYGZsq{}:
        print(\PYGZdq{}...I don\PYGZsq{}t like Mondays...\PYGZdq{})
    elif day == \PYGZsq{}Tuesday\PYGZsq{}:
        print(\PYGZsq{}...Ruby Tuesday\PYGZsq{})
    elif day == \PYGZsq{}Friday\PYGZsq{}:
        print(\PYGZdq{}...Friday I\PYGZsq{}m In Love\PYGZdq{})
    else:
        print(\PYGZdq{}...I don\PYGZsq{}t know a song title for that day\PYGZdq{})
\end{sphinxVerbatim}
}

Now run the previous code cell and step through its execution using \sphinxstyleemphasis{nbtutor}; observe how the control flow steps increasing through the stack of \sphinxcode{\sphinxupquote{..elif..}} tests as the \sphinxcode{\sphinxupquote{for..}} loop iterates through the items in the \sphinxcode{\sphinxupquote{days\_of\_week}} list.

Note that there is no requirement that you test the same variable in each step. The different steps could test a different variable or range of variables.

For example, in the following programme, we might decide what to take out with us on a walk based on a variety of conditions:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}raining = False
temperature = \PYGZsq{}warm\PYGZsq{}

if raining:
    print(\PYGZdq{}Wear boots\PYGZdq{})
elif temperature == \PYGZsq{}warm\PYGZsq{}:
    print(\PYGZdq{}Wear sandals\PYGZdq{})
else:
    print(\PYGZdq{}Wear shoes\PYGZdq{})
\end{sphinxVerbatim}
}

Also note that there is an \sphinxstyleemphasis{order} in which we test the various conditions as the control passes through the \sphinxcode{\sphinxupquote{if..elif..}} conditional tests. We can use this as an informal way of prioritising one behaviout over another:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{this\PYGZus{}really\PYGZus{}important\PYGZus{}thing}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{k}{elif} \PYG{n}{this\PYGZus{}less\PYGZus{}important\PYGZus{}thing}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{k}{elif} \PYG{n}{this} \PYG{n}{minor\PYGZus{}thing}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{k}{else}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\subsubsection{3.5 Challenge: Three shades of grey}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:3.5-Challenge:-Three-shades-of-grey}}
The program at the start of this notebook (in Section 3.1) showed how an \sphinxcode{\sphinxupquote{if...else...}} statement could be used to decide between black and grey areas. The background (loaded into the simulator as the \sphinxstyleemphasis{Grey and black} background) actually contains three different shades: black, dark grey, and light grey. Can you construct a program that will report which the robot encounters?

A copy of the original program is provided below as a starting point. You will need to extend the code so that it can decide between three grey alternatives as well as the black band and say which band it saw.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

\PYGZsh{} Use this programme with the \PYGZdq{}Grey and black\PYGZdq{} background

import playsound

\PYGZsh{} Configure a light sensor
colorLeft = ColorSensor(INPUT\PYGZus{}2)

\PYGZsh{} Start the robot driving forwards
tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

\PYGZsh{}Sample the light sensor reading
sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

\PYGZsh{}Check the light sensor reading
while sensor\PYGZus{}value == 100:
    \PYGZsh{} Whilst we are on the white background
    \PYGZsh{} update the reading
    sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    \PYGZsh{} and display it
    print(sensor\PYGZus{}value)

\PYGZsh{} When the reading is below 100
\PYGZsh{} we have started to see something.
\PYGZsh{} Drive a little way onto the band to get a good reading
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(50), SpeedPercent(50), 0.2)

\PYGZsh{}Check the sensor reading
sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
\PYGZsh{} and display it
print(sensor\PYGZus{}value)

\PYGZsh{} Now make a decision about what we see
if sensor\PYGZus{}value \PYGZlt{} 50:
    playsound.say(\PYGZdq{}I see black\PYGZdq{})
else:
    playsound.say(\PYGZdq{}I see grey\PYGZdq{})
\end{sphinxVerbatim}
}

When you have modified the code, run the cell to download it to the simulator, ensure the \sphinxstyleemphasis{Grey and black} background is loaded, and then run the programme in the simulator for various starting positions of the robot. Does it behave as you intended?


\paragraph{Hint: click the arrow in the sidebar to reveal a hint}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Hint:-click-the-arrow-in-the-sidebar-to-reveal-a-hint}}
The original program uses an \sphinxcode{\sphinxupquote{if..else..}} condition to distinguish between black and grey reflected light readings. An \sphinxcode{\sphinxupquote{..elif..}} statement lets you test alternative values within the same \sphinxcode{\sphinxupquote{if..else..}} block.

To identify the values to use in the condition statements, inspect the simulator output window messages to see what sensor values are reported when the robot goes over different bands.


\paragraph{Worked Answer}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Worked-Answer}}
Click the arrow in the sidebar to display a worked answer.

The robot sees the following values over each of the grey bands:
\begin{itemize}
\item {} 
light grey: \textasciitilde{}86

\item {} 
medium grey: \textasciitilde{}82

\item {} 
dark grey: \textasciitilde{}50

\item {} 
black: 0

\end{itemize}

Generally, when we see lots of decimal places, we assume that the chances of ever seeing exactly the same sequence of numbers may be unlikely, so rather than testing for an exact match, we use one or more threshold tests to see if the number lies within a particular \sphinxstyleemphasis{range} of values, or is above a certain minimum value.

If we assume those sensor readings are reliable, and the same value is alsway reported for each of those bands, we can make the make the following decisions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{sensor\PYGZus{}value} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{86}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{light grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{sensor\PYGZus{}value} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{82}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{medium grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{sensor\PYGZus{}value} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{50}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dark grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

We can make the test even more reliable by setting the threshold test values to values that are halfway between the expected values for a particular band. For example, 84, rather than 82, for distinguishing between light and medium grey; 66 rather than 82 for distinguishing between dark and medium grey; and 25 rather than 50 for distinguising between black and dark grey.

\_\_TO DO: an activity with noise values around the sensor would be useful here.\_

This means that if there is a slight error in the reading, our thresholded test is like to make the right decision about which side of the threshold value the (noisy) reading actually falls on.

\_\_ TO DO \sphinxhyphen{} a diagram to illustrate this would be useful. \_\_

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

\PYGZsh{} Use this programme with the \PYGZdq{}Grey and black\PYGZdq{} background

import playsound

\PYGZsh{} Configure a light sensor
colorLeft = ColorSensor(INPUT\PYGZus{}2)

\PYGZsh{} Start the robot driving forwards
tank\PYGZus{}drive.on(SpeedPercent(50), SpeedPercent(50))

\PYGZsh{}Sample the light sensor reading
sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity

\PYGZsh{}Check the light sensor reading
while sensor\PYGZus{}value == 100:
    \PYGZsh{} Whilst we are on the white background
    \PYGZsh{} update the reading
    sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    \PYGZsh{} and display it
    print(sensor\PYGZus{}value)

\PYGZsh{} When the reading is below 100
\PYGZsh{} we have started to see something.
\PYGZsh{} Drive onto the band to get a good reading
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(50), SpeedPercent(50), 0.2)

\PYGZsh{}Check the sensor reading
sensor\PYGZus{}value = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
\PYGZsh{} and display it
print(sensor\PYGZus{}value)

\PYGZsh{} Now make a decision about what we see
if sensor\PYGZus{}value \PYGZgt{}  86:
    playsound.say(\PYGZdq{}I see light grey\PYGZdq{})
elif sensor\PYGZus{}value \PYGZgt{} 82:
    playsound.say(\PYGZdq{}I see medium grey\PYGZdq{})
elif sensor\PYGZus{}value \PYGZgt{} 50:
    playsound.say(\PYGZdq{}I see dark grey\PYGZdq{})
else:
    playsound.say(\PYGZdq{}I see black\PYGZdq{})
\end{sphinxVerbatim}
}

Other solutions are possible.

One thing you might notice is that sometimes the robot gives the wrong answer, for example if the sensor is not completely over the band and gives a reading that does not exactly match a value you used in your conditional tests.

You will see how to address this sensitivity in the next notebook.


\subsubsection{Summary}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Summary}}
In this notebook, you have seen how \sphinxcode{\sphinxupquote{if..}} statements can be used to make a variety of decisions and trigger a range of different actions based on one or more tested conditions. In particular:
\begin{itemize}
\item {} 
a simple \sphinxcode{\sphinxupquote{if..}} statement lets a perform one or more actions once and once only if a single conditional test evaluates true;

\item {} 
an \sphinxcode{\sphinxupquote{if..else..}} statement allows us to \sphinxstyleemphasis{branch} between two possible futures based on the whether a single conditional test evaluates as true; if it is true, do one action, if not, do the other;

\item {} 
an \sphinxcode{\sphinxupquote{if..elif..else..}} construction lets us run mutliple different conditional tests. If the first test is true, do one thing, otherwise test the next thing, and if that is true, do something, otherwise, do another test, and so on. If all the other \sphinxcode{\sphinxupquote{elif..}} tests evaluate false, do the final \sphinxcode{\sphinxupquote{else}} condition.

\end{itemize}


\subsubsection{Addendum}
\label{\detokenize{content/02_Robot_Lab/Section_00_02:Addendum}}
The IPython interpreter that underpins code execution in Jupyter notebooks has a range of display functions that are capable of embedding and playing a wide variety of media, include audio and video files.

For example, if you run the following code cell, you can embed a Youtube video given the unique video identifier which you will find in every Youtube video URL / web address:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from IPython.lib.display import YouTubeVideo
YouTubeVideo(\PYGZsq{}mGgMZpGYiy8\PYGZsq{})
\end{sphinxVerbatim}
}

What, me, dodgy goth? Goth hippy groover, more like…;\sphinxhyphen{})



---
# 3 Robot Lab challenges


Here you are given a number of challenges to do. These challenges are a bit different from the activities you did earlier in RoboLab sessions. We leave you to work out the challenges for yourself, although you are encouraged to use the forums if you need help or if you want to share or discuss any of your ideas with other students.

The purpose of the challenges is to allow you to try your hand at writing your own RoboLab programs. Don’t spend too much time on this work. If you get stuck, take a break: it's surprising how often a solution to a programming problem comes to mind if you take a few minutes away from the screen and the keyboard and do something completely different instead.

The challenges in the next notebook are more difficult and are completely optional. They generally require you to have had some computer programming experience before you started this module.

In the meantime, once you have finished RoboLab Session 3 I suggest you take a well-earned break before going back to the website to complete Study week 3.


### Challenge: Moving Simon forwards

Write a RobotLab program to make the Simon robot move forwards for two seconds.


### Challenge: Traversing a triangle
<div xmlns:str="http://exslt.org/strings" style="background:lightgreen">

![figure ../tm129-19J-images/tm129_portfolio_activity_32.png](../images/tm129_portfolio_activity_32.png) Please note that you must complete and submit the 'Traversing a triangle' activity as part of your ePortfolio.
</div>

Write a program to make the simulated program trace out a triangular path. Run the program in pen-down mode by checking the pen down checkbox in the simulator and grab a screenshot of the code + simulator output.

__TO DO: need some guidance on taking screenshots etc__


![An outline triangle.](../images/tm129_rob_p3_f021.gif)


---


\subsection{Challenge: Making a countdown program}
\label{\detokenize{content/02_Robot_Lab/Section_00_03:Challenge:-Making-a-countdown-program}}\label{\detokenize{content/02_Robot_Lab/Section_00_03::doc}}
Write a RoboLab program that counts down from 10 to 0 and finishes by saying ‘OK’.


\subsubsection{Question}
\label{\detokenize{content/02_Robot_Lab/Section_00_03:Question}}
Would you like a hint?


\subsubsection{Answer}
\label{\detokenize{content/02_Robot_Lab/Section_00_03:Answer}}
The simulator speech engine can only speak “strings” not digits. So you need to pass in numbers as a string, such as \sphinxcode{\sphinxupquote{\textquotesingle{}2\textquotesingle{}}}, \sphinxstyleemphasis{not} as a literal numeric value, such as \sphinxcode{\sphinxupquote{3}}.


\bigskip\hrule\bigskip



\subsection{Challenge: Traversing a hook}
\label{\detokenize{content/02_Robot_Lab/Section_00_03:Challenge:-Traversing-a-hook}}
Write a RoboLab program to make the simulated robot trace out the following path: going up the screen, making three turns to the right and ending up crossing its original path, as shown below.

\sphinxincludegraphics[width=104\sphinxpxdimen,height=105\sphinxpxdimen]{{tm129_rob_p3_f022}.jpg}


\subsubsection{Question}
\label{\detokenize{content/02_Robot_Lab/Section_00_03:id1}}
Would you like a hint?


\subsubsection{Answer}
\label{\detokenize{content/02_Robot_Lab/Section_00_03:id2}}
It will help to create three constants, \sphinxcode{\sphinxupquote{longTime}}, \sphinxcode{\sphinxupquote{shortTime}} and \sphinxcode{\sphinxupquote{turnTime}}. You could make \sphinxcode{\sphinxupquote{longTime}} about twice as long as \sphinxcode{\sphinxupquote{shortTime}}. Use the \sphinxcode{\sphinxupquote{tank\_drive()}} construct for the movement up the screen. Since this is long, use the constant \sphinxcode{\sphinxupquote{longTime}}. I used the \sphinxcode{\sphinxupquote{tank\_turn()}} command to make the robot turn for a specified number of wheel rotations.


\bigskip\hrule\bigskip



\subsection{4 Optional challenges}
\label{\detokenize{content/02_Robot_Lab/Section_00_04:4-Optional-challenges}}\label{\detokenize{content/02_Robot_Lab/Section_00_04::doc}}
These challenges are more difficult, so we’ve made them optional. If you want more programming experience before tackling these challenges you can always come back to this section later in the block.


\bigskip\hrule\bigskip



\subsubsection{Challenge: Traversing a multi\sphinxhyphen{}square}
\label{\detokenize{content/02_Robot_Lab/Section_00_04:Challenge:-Traversing-a-multi-square}}
Write a RoboLab program to make the simulated robot trace out the following path:

\noindent\sphinxincludegraphics[width=105\sphinxpxdimen,height=106\sphinxpxdimen]{{tm129_rob_p3_f023}.gif}

A geometric shape. This is a complex path traced out by repeatedly moving forward and turning to the right. The path crosses over itself, forming a square loop at one end; this is then repeated until the path joins up with the beginning again. Overall the net effect is to produce a pattern that can be seen as five identical squares; one is placed centrally and the other four placed at each corner, diagonally outside so only the corner of each surrounding square meets a corner of the central
square.


\paragraph{HINT: click the arrow in the sidebar to reveal a hint}
\label{\detokenize{content/02_Robot_Lab/Section_00_04:HINT:-click-the-arrow-in-the-sidebar-to-reveal-a-hint}}
You can repeat the path of the ‘Traversing a hook’ challenge in notebook ??.


\subparagraph{Challenge: Making a Spirograph drawing}
\label{\detokenize{content/02_Robot_Lab/Section_00_04:Challenge:-Making-a-Spirograph-drawing}}
When you were a child you might have played with Spirograph, in which case you might recognise the pattern below which is constructed from multiple rotated triangles overlaid on top of each other: \sphinxstyleemphasis{did RobotLab have pen up/pen down commands?}

\noindent\sphinxincludegraphics[width=97\sphinxpxdimen,height=97\sphinxpxdimen]{{tm129_rob_p3_f024}.gif}

A Spirograph pattern. This is a series of about 30 lines, inscribed across a circle but not through the centre; the overall pattern is of a rosette with many triangular petals surrounding an inner circle.

Write a RoboLab program to make the simulated robot leave this trail.


\paragraph{HINT: click the arrow in the sidebar to reveal a hint}
\label{\detokenize{content/02_Robot_Lab/Section_00_04:id1}}
A \sphinxcode{\sphinxupquote{for..in..}} or \sphinxcode{\sphinxupquote{while..}} loops is the key here…


\subparagraph{Challenge: Writing a script ‘A’ character}
\label{\detokenize{content/02_Robot_Lab/Section_00_04:Challenge:-Writing-a-script-_u2018A_u2019-character}}
Make the simulated robot trace out the letter A in script form as illustrated below, and to say ‘A’:

\noindent\sphinxincludegraphics[width=98\sphinxpxdimen,height=125\sphinxpxdimen]{{tm129_rob_p3_f025}.gif}

A pattern that looks like a capital letter A, hand drawn without lifting pen from paper. This could be done by starting at the base of the left limb, drawing up to the point, down the right limb, and then in a sweeping curve up and left to a point to the left of the letter, and finally straight across to form the cross bar.


\paragraph{HINT: click the arrow in the sidebar to reveal a hint}
\label{\detokenize{content/02_Robot_Lab/Section_00_04:id2}}
You should be able to do the straight lines easily enough. For the turn, explore various \sphinxcode{\sphinxupquote{tank\_turn}} settings…


\section{Session 03 — RoboLab}
\label{\detokenize{index:session-03-robolab}}

\subsection{1 Introduction}
\label{\detokenize{content/03_Robot_Lab/Section_00_01:1-Introduction}}\label{\detokenize{content/03_Robot_Lab/Section_00_01::doc}}
Sensors are at the heart of robotics. A machine without sensors cannot be a robot in our terms. The human body is replete with sensors. Our five external senses \textendash{} sight, hearing, touch, smell and taste \textendash{} and internal sensing such as balance and proprioception (body awareness) are all marvellously sophisticated.

In Robot Lab Session 4 we are concerned with how a robot can use this sensory information to control its actuators. We will investigate a progression of control strategies:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
dead reckoning \textendash{} no sensor input

\item {} 
reflex behaviour \textendash{} sensors \sphinxstyleemphasis{linked directly} to motors according to the sense\textendash{}act model

\item {} 
deliberative behaviour \textendash{} actuation depends on \sphinxstyleemphasis{reasoning} about sensor information and other knowledge, according to the sense\textendash{}think\textendash{}act model.

\end{enumerate}

The first control strategy, dead reckoning, is “open loop”, since it does not use sensor input.

The second is the sense\textendash{}act control strategy that you encountered in Study week 2, and we will illustrate it using versions of Braitenberg’s vehicles (also introduced in Study week 2).

Finally, there is the most complex control strategy, in which the robot deliberates on the sensor inputs in the context of other knowledge. This involves \sphinxstyleemphasis{reasoning}, as discussed in Study week 3. This corresponds to the way humans solve complex problems and plan actions in the long and short term.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} Run this cell to set up the robot simulator environment

\PYGZsh{}Load the nbtutor extension
\PYGZpc{}load\PYGZus{}ext nbtutor

\PYGZsh{}Reset the notebook style
from IPython.core.display import display, HTML

display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:50\PYGZpc{} !important; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))


\PYGZsh{}Launch the simulator
from nbev3devsim import ev3devsim\PYGZus{}nb as eds
\PYGZpc{}load\PYGZus{}ext nbev3devsim

roboSim = eds.Ev3DevWidget()
display(roboSim)
roboSim.element.dialog();
\end{sphinxVerbatim}
}


\subsection{2 Dead reckoning}
\label{\detokenize{content/03_Robot_Lab/Section_00_02:2-Dead-reckoning}}\label{\detokenize{content/03_Robot_Lab/Section_00_02::doc}}
\sphinxstyleemphasis{Dead reckoning} is a means of navigation that does not rely on external observations. Instead, a robot’s position is estimated by summing its incremental movements relative to a known starting point.

Estimates of the distance traversed are usually obtained from measuring how many times the wheels have turned, and how many times they have turned in relation to each other. For example, the wheels of the robot could be attached to an odometer, similar to the device that records the mileage of a car.

In RoboLab we will calculate the position of a robot from how long it moves in a straight line or rotates about its centre. We will assume that the length of time for which the motors are switched on is directly related to the distance travelled by the wheels.


\subsubsection{2.1 Activity: Dead reckoning}
\label{\detokenize{content/03_Robot_Lab/Section_00_02:2.1-Activity:-Dead-reckoning}}
An environment for the simulated robot to navigate is shown below, based on the 2018 First Lego League “Into Orbit” challenge.

The idea is that the robot must get to the target satellite from its original starting point by avoiding the obstacles in its direct path.

\noindent\sphinxincludegraphics[width=1714\sphinxpxdimen,height=1020\sphinxpxdimen]{{Section_00_02_-_Jupyter_Notebook}.png}

The following programme should drive the robot from its starting point, to the target, whilst avoiding the obstacles. We define the obstacle as being avoided if it is not crossed by the robot’s \sphinxstyleemphasis{pen down} trail.

Load the \sphinxstyleemphasis{FLL 2018 \sphinxhyphen{} Into Orbit} background into the simulator. Run the code cell to download the program to the simulator and then, with the \sphinxstyleemphasis{Pen Down} checkbox enabled, run the programme in the simulator.

\sphinxstyleemphasis{Remember that you can reset the original location and orientation of the robot by clicking the simularo \textasciigrave{}\textasciigrave{}Reset\textasciigrave{}\textasciigrave{} button. You can clear the pen trace by clicking the simulator \textasciigrave{}\textasciigrave{}Clear Trace\textasciigrave{}\textasciigrave{} button.}

Does the robot reach the target satellite without encountering any obstacles?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

import playsound

\PYGZsh{} Turn on the spot to the right
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(100, SpeedPercent(75), 0.8 )

\PYGZsh{} Go forwards
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(30), SpeedPercent(30), 4)

\PYGZsh{} Slight graceful turn to right
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(50), SpeedPercent(30), 2.5)

\PYGZsh{} Turn on the spot to the left
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 0.8 )

\PYGZsh{} Forwards a bit
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(30), SpeedPercent(30), 0.8)

\PYGZsh{}Turn on the spot a bit more to the left
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 0.6 )

\PYGZsh{} Go forwards a bit more and dock on the satellite
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(30), SpeedPercent(30), 1.5)

playsound.say(\PYGZdq{}Hopefully I have docked with the satellite...\PYGZdq{})
\end{sphinxVerbatim}
}

To set the speeds and times, I used a bit of trial and error.

If the route had been much more complex, I would have been tempted to comment out the steps up I had already run an add new steps that would be applied from wherever the robot was currently located.

Note that the robot could have taken other routes to get to the satellite \sphinxhyphen{} I just thought I should avoid the asteroid!


\subsubsection{2.2 Challenge: Reaching the moon base}
\label{\detokenize{content/03_Robot_Lab/Section_00_02:2.2-Challenge:-Reaching-the-moon-base}}
In the following code cell, write a program to move the simulated robot from its location servicing the satellite to the moon base identified as the circlular area marked on the moon in the top right hand corner of the simulated world.

In the simulator, set the robot’s X location to \sphinxcode{\sphinxupquote{1250}} and Y location \sphinxcode{\sphinxupquote{450}} and use the \sphinxstyleemphasis{Move} button to loate the robot there.

Use the following code cell to write your own dead reckoning programme to drive the robot to the moon base at location \sphinxcode{\sphinxupquote{(2150, 950)}}.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

\PYGZsh{} YOUR CODE HERE

\end{sphinxVerbatim}
}


\subsubsection{2.3 Activity: Dead reckoning with noise}
\label{\detokenize{content/03_Robot_Lab/Section_00_02:2.3-Activity:-Dead-reckoning-with-noise}}
The robot traverses its path using timing information for dead reckoning. In principle, if the simulated robot had a map, it could calculate all the distances and directions for itself, convert these to times, and dead reckon its way to the target. However, there is a problem with dead reckoning: \sphinxstyleemphasis{noise}.

In many physical systems, a perfect intended behaviour is subject to \sphinxstyleemphasis{noise}, random perturbations that arise within the system as time goes on as a side\sphinxhyphen{}effect of its operation. In a robot, noise might arise in the behaviour of the motors, the transmission or the wheels. The result is that the robot does not execute its motion without error. We can model noise effects in the mobility system of out robot by adding a small amount of noise to the motor speeds as the simulator runs. This noise
componenent may speed up, or slow down, the speed of each motor, in a random way. As with real systems, the noise represents are slight random deviations from the theoretical, ideal behaviour.

Run the following code cell to download the programme to the simulator. Select an empty background (select the \sphinxstyleemphasis{Empty Map}) and tick the \sphinxstyleemphasis{Pen Down} checkbox. Also reset the initial location of the robot to an X value of \sphinxcode{\sphinxupquote{50}} and Y value of \sphinxcode{\sphinxupquote{400}}; use the simulator \sphinxstyleemphasis{Move} button to move the robot to that location.

Run the program in the simulator and observe what happens.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(30), SpeedPercent(30), 3)
\end{sphinxVerbatim}
}

When you run the programme, you should see the robot drive forwards a short way in a straight line, leaving a staight line trail behind it.

Reset the location of the robot by clicking the simulator \sphinxstyleemphasis{Move} button. Also within the simulator, increase the \sphinxstyleemphasis{Wheel noise} value from zero by dragging the slider to the right a little way.

Run the programme in the simulator again.

You should notice this time that the robot does not travel in a straight line. Instead, it drifts from side to slide although possible to one side of the line.

Move the robot back to the start poistion (click the \sphinxstyleemphasis{Move} button) and run the programme in the simulator again. This time, you should see it follows yet another different path.

Depending on how severe the noise setting is, the robot will travel closer (low noise) the original straight libe, or follow an ever more erratic path (high noise).

Now run the original satellite finding dead reckoning programme again, using the \sphinxstyleemphasis{FLL 2018 \sphinxhyphen{} Into Orbit} background, but in the presence of \sphinxstyleemphasis{Wheel noise}. Does it:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

import playsound

\PYGZsh{} Turn on the spot to the right
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(100, SpeedPercent(75), 0.8 )

\PYGZsh{} Go forwards
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(30), SpeedPercent(30), 4)

\PYGZsh{} Slight graceful turn to right
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(50), SpeedPercent(30), 2.5)

\PYGZsh{} Turn on the spot to the left
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 0.8 )

\PYGZsh{} Forwards a bit
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(30), SpeedPercent(30), 0.8)

\PYGZsh{}Turn on the spot a bit more to the left
tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(\PYGZhy{}100, SpeedPercent(75), 0.6 )

\PYGZsh{} Go forwards a bit more and dock on the satellite
tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(SpeedPercent(30), SpeedPercent(30), 1.5)

playsound.say(\PYGZdq{}Hopefully I have docked with the satellite...\PYGZdq{})
\end{sphinxVerbatim}
}


\subsubsection{Summary}
\label{\detokenize{content/03_Robot_Lab/Section_00_02:Summary}}
In this notebook you have seen how we can use dead reckoning to move the robot along a specified path. However, in the presence of noise, this is very unreliable: whilst the robot may think it is following one path, it may in fact be following another. And whilst in some cases it may reach the target safely, in others it may end somewhere completely different, or encounter an obstacle along the way.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}Testing  \PYGZhy{} can we load from a package?
\PYGZsh{}import \PYGZus{}load\PYGZus{}nbev3devwidget\PYGZus{}requirements
\PYGZsh{}\PYGZsh{}import \PYGZus{}load\PYGZus{}nbev3devwidget
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}import \PYGZus{}load\PYGZus{}nbev3devwidget
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}from IPython.display import Javascript
\PYGZsh{}Javascript(\PYGZsq{}\PYGZdl{}( \PYGZdq{}\PYGZsh{}notebook\PYGZhy{}container\PYGZdq{} ).resizable(\PYGZob{}ghost: false\PYGZcb{})\PYGZsq{})
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} If the above doesn\PYGZsq{}t work, old skool is below...
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from nbev3devsim import ev3devsim\PYGZus{}nb as eds
import jp\PYGZus{}proxy\PYGZus{}widget

\PYGZsh{}Load the nbtutor extension
\PYGZpc{}load\PYGZus{}ext nbtutor

\PYGZsh{}https://github.com/AaronWatters/jp\PYGZus{}doodle/blob/master/notebooks/misc/JQueryUI\PYGZpc{}20dialogextend\PYGZpc{}20plugin\PYGZpc{}20demo.ipynb
\PYGZsh{}Load and initialise the jquery.dialogextend package

cdn\PYGZus{}url = \PYGZdq{}https://cdn.jsdelivr.net/npm/binary\PYGZhy{}com\PYGZhy{}jquery\PYGZhy{}dialogextended@1.0.0/jquery.dialogextend.js\PYGZdq{}
cdn\PYGZus{}url = eds.get\PYGZus{}file\PYGZus{}path(\PYGZsq{}js/jquery.dialogextend.js\PYGZsq{})
module\PYGZus{}id = \PYGZdq{}dialogExtend\PYGZdq{}

\PYGZsh{} Load the module using a widget (any widget \PYGZhy{}\PYGZhy{} the module loads to the global jQuery object).
loader = jp\PYGZus{}proxy\PYGZus{}widget.JSProxyWidget()

\PYGZsh{} Configure the module to be loaded.
loader.require\PYGZus{}js(module\PYGZus{}id, cdn\PYGZus{}url)

\PYGZsh{} Load the module
loader.js\PYGZus{}init(\PYGZdq{}\PYGZdq{}\PYGZdq{}
    element.requirejs([module\PYGZus{}identifier], function(module\PYGZus{}value) \PYGZob{}
        //element.html(\PYGZdq{}loaded \PYGZdq{} + module\PYGZus{}identifier + \PYGZdq{} : \PYGZdq{} + module\PYGZus{}value);
    \PYGZcb{});
\PYGZdq{}\PYGZdq{}\PYGZdq{}, module\PYGZus{}identifier=module\PYGZus{}id)
loader

\PYGZsh{} I think we need to wait for this to load
\PYGZsh{} else we may get an error in next cell from dialogExtend not being available?
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from nbev3devsim import ev3devsim\PYGZus{}nb as eds

\PYGZsh{}Reset the notebook style
from IPython.core.display import display, HTML, Javascript

\PYGZsh{}display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} resize:vertical; border: 5px solid;  width: 300px; resize: horizontal; overflow: auto; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))
display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:50\PYGZpc{}; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))

\PYGZsh{}Launch the simulator
from nbev3devsim import ev3devsim\PYGZus{}nb as eds
\PYGZpc{}reload\PYGZus{}ext nbev3devsim

roboSim = eds.Ev3DevWidget()

roboSim.element.dialog();


roboSim.js\PYGZus{}init(\PYGZdq{}\PYGZdq{}\PYGZdq{}
element.dialog(\PYGZob{} \PYGZdq{}title\PYGZdq{} : \PYGZdq{}Robot Simulator\PYGZdq{} \PYGZcb{}).dialogExtend(\PYGZob{}
        \PYGZdq{}maximizable\PYGZdq{} : true,
        \PYGZdq{}dblclick\PYGZdq{} : \PYGZdq{}maximize\PYGZdq{},
        \PYGZdq{}icons\PYGZdq{} : \PYGZob{} \PYGZdq{}maximize\PYGZdq{} : \PYGZdq{}ui\PYGZhy{}icon\PYGZhy{}arrow\PYGZhy{}4\PYGZhy{}diag\PYGZdq{} \PYGZcb{}\PYGZcb{});
\PYGZdq{}\PYGZdq{}\PYGZdq{})

display(roboSim)
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{o}{\PYGZpc{}}\PYG{o}{\PYGZpc{}}\PYG{n+nx}{javascript}
\PYG{c+c1}{//This allows us to resize this view}
\PYG{c+c1}{//Click on the right hand edge to drag}
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}notebook\PYGZhy{}container\PYGZdq{}} \PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{resizable}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n+nx}{ghost}\PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}load\PYGZus{}ext nbtutor
\PYGZpc{}load\PYGZus{}ext nbev3devsim
\end{sphinxVerbatim}
}


\subsection{4 Emergent behaviour: Braitenberg’s vehicles}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:4-Emergent-behaviour:-Braitenberg_u2019s-vehicles}}\label{\detokenize{content/03_Robot_Lab/Section_00_03::doc}}
In Study week 2 you came across Valentino Braitenberg’s ideas on the behaviour of robots \sphinxstyleemphasis{emerging} from the way they are wired up. The figure belows shows two ways of connecting sensors to motors. In (a), the left sensor is connected to the left motor and the right sensor is connected to the right motor. In (b) these connections are reversed.


\subsubsection{4.1 Activity: Testing Braitenberg’s vehicles}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:4.1-Activity:-Testing-Braitenberg_u2019s-vehicles}}
A ‘thought experiment’ suggests that the vehicle in figure (a) will move away from a light source. Similarly, another thought experiment suggests that the vehicle in figure (b) will move towards a light source. In the following activities you will test these predictions using an enivironment that models this set up, but uses downward facing light sensors that take measurements from a “light gradient” background, rather than forward facing light sensors that look for a light source at “eye\sphinxhyphen{}level”
(that is, sensor\sphinxhyphen{}level!).


\paragraph{Reconfiguring the robot}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:Reconfiguring-the-robot}}
In order to detect different values from the light sensors on the right and left hand side of the robot, we need to reconfigure the robot so that the sensors are placed further apart than they are in the default robot configuration.

In the simulator, select the \sphinxstyleemphasis{Radial grey} background and check the \sphinxstyleemphasis{Pen down} checkbox.

You may notice that the simulator’s left and right light sensors appear to be further apart than they have been previously.

This has been done via a change to the robot configuration setting update that is applied automatically when the \sphinxstyleemphasis{Radial grey} background is loaded.


\subparagraph{Manually Changing the Robot Configuration Settings}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:Manually-Changing-the-Robot-Configuration-Settings}}
You can increase the spacing between the sensors by:
\begin{itemize}
\item {} 
clicking the \sphinxstyleemphasis{Configure Robot} button in the simulator to pop=up a window containing the robot configuration settings;

\item {} 
in the robot configuration settings window, scroll down to the \sphinxcode{\sphinxupquote{"sensor1"}} parameters and change the \sphinxcode{\sphinxupquote{"x"}} value from the default value of \sphinxcode{\sphinxupquote{\sphinxhyphen{}20}} to the new value \sphinxcode{\sphinxupquote{\sphinxhyphen{}60}};

\item {} 
for \sphinxcode{\sphinxupquote{"sensor2"}}, change the \sphinxcode{\sphinxupquote{"x"}} value from its default value of \sphinxcode{\sphinxupquote{20}} the new value \sphinxcode{\sphinxupquote{60}};

\item {} 
click the \sphinxstyleemphasis{Apply} button.

\end{itemize}

If you look at the robot in the simulator, you should notice that the two light sensors are now located nearer the sides of the robot and are no longer located close to the centreline.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} Linting is all a bit broken at the moment
\PYGZsh{} May or may not be ready in time...

\PYGZsh{}\PYGZpc{}load\PYGZus{}ext pycodestyle\PYGZus{}magic
\PYGZsh{}\PYGZpc{}pycodestyle\PYGZus{}on
\PYGZsh{}\PYGZpc{}flake8\PYGZus{}off \PYGZhy{}\PYGZhy{}ignore D100
\end{sphinxVerbatim}
}


\subparagraph{Exploring the \sphinxstyleemphasis{Radial Grey} World}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:Exploring-the-Radial-Grey-World}}
Run the following code cell to download the programme to the simulator and then run it in the simulator. For now, don’t pay too much atttention to the code; our initial focus is purely on what we can observe about the behaviour of the robot.

Observe what happens paying particularly close attention to the trajectory the robot follows.

Enter a new starting location in the simulator, changing the original \sphinxstyleemphasis{Y} value from \sphinxcode{\sphinxupquote{400}} to the new value \sphinxcode{\sphinxupquote{600}}. Click the \sphinxstyleemphasis{Move} button to move the robot to that location and run the simulator again. How does the robot move this time?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

colorLeft = ColorSensor(INPUT\PYGZus{}2)
colorRight = ColorSensor(INPUT\PYGZus{}3)

while ((colorLeft.reflected\PYGZus{}light\PYGZus{}intensity\PYGZgt{}0.05)
       and (colorRight.reflected\PYGZus{}light\PYGZus{}intensity)\PYGZgt{}5):

    intensity\PYGZus{}left = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    intensity\PYGZus{}right = colorRight.reflected\PYGZus{}light\PYGZus{}intensity

    print(intensity\PYGZus{}left, intensity\PYGZus{}right)

    left\PYGZus{}motor\PYGZus{}speed = SpeedPercent(intensity\PYGZus{}left)
    right\PYGZus{}motor\PYGZus{}speed = SpeedPercent(intensity\PYGZus{}right)

    tank\PYGZus{}drive.on(left\PYGZus{}motor\PYGZus{}speed, right\PYGZus{}motor\PYGZus{}speed)
\end{sphinxVerbatim}
}

With the robot starting just \sphinxstyleemphasis{below} the centreline on the radial grey background, you shoul notice that as it moves across the background it veers away from the light on a path that curves towards the bottom right of the simulator, steering to the right from the robot’s perspective.

When the robot starts \sphinxstyleemphasis{above} the centreline, it veers away on the left hand side of the central bright point (that is, the robot steers to its left).

If the robot starts on the centreline, it continues on a straight path.

So how does the programme work?

If you inspect it closely, you will see it is split into several parts.

The first part just clarifies the sensor configuration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{colorLeft} \PYG{o}{=} \PYG{n}{ColorSensor}\PYG{p}{(}\PYG{n}{INPUT\PYGZus{}2}\PYG{p}{)}
\PYG{n}{colorRight} \PYG{o}{=} \PYG{n}{ColorSensor}\PYG{p}{(}\PYG{n}{INPUT\PYGZus{}3}\PYG{p}{)}
\end{sphinxVerbatim}

Then we have a \sphinxcode{\sphinxupquote{while..}} loop that ensures the programme keeps running unitl either the left or the right sensor value sees a particularly dark value:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{p}{(}\PYG{p}{(}\PYG{n}{colorLeft}\PYG{o}{.}\PYG{n}{reflected\PYGZus{}light\PYGZus{}intensity}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{p}{)}
       \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{colorLeft}\PYG{o}{.}\PYG{n}{reflected\PYGZus{}light\PYGZus{}intensity}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
\end{sphinxVerbatim}

Inside the \sphinxcode{\sphinxupquote{while..}} block is the “intelligence” of the programme.

The values are displayed in the simulator output window using a \sphinxcode{\sphinxupquote{print()}} statement, and are then used to set the motor speeds:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{left\PYGZus{}motor\PYGZus{}speed} \PYG{o}{=} \PYG{n}{SpeedPercent}\PYG{p}{(}\PYG{n}{intensity\PYGZus{}left}\PYG{p}{)}
\PYG{n}{right\PYGZus{}motor\PYGZus{}speed} \PYG{o}{=} \PYG{n}{SpeedPercent}\PYG{p}{(}\PYG{n}{intensity\PYGZus{}right}\PYG{p}{)}

\PYG{n}{tank\PYGZus{}drive}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{left\PYGZus{}motor\PYGZus{}speed}\PYG{p}{,} \PYG{n}{right\PYGZus{}motor\PYGZus{}speed}\PYG{p}{)}
\end{sphinxVerbatim}

In this configuration:
\begin{itemize}
\item {} 
the percentage scaled \sphinxstyleemphasis{left} sensor value determines the speed value applied to the \sphinxstyleemphasis{left} motor, and

\item {} 
the percentage scaled \sphinxstyleemphasis{right} sensor value sets the \sphinxstyleemphasis{right} motor speed.

\end{itemize}

The sensor value reports a higher reading the brighter the background. As the robot approaches the light source from below the centreline, the left sensor reads a higher value than the right sensor. As described by the programme, the left motor thus turns more quickly than the right motor, and so the robot turns toward its right hand side and veers away from the light source.

\#\#\# Crossing the Wires…

Now let’s see what happens if we run the following program which uses:
\begin{itemize}
\item {} 
the \sphinxstyleemphasis{left} light sensor to control the speed of the \sphinxstyleemphasis{right} motor; and

\item {} 
the \sphinxstyleemphasis{right} light sensor to control the speed of the \sphinxstyleemphasis{left} motor.

\end{itemize}

Still using the \sphinxstyleemphasis{Radial grey} background, clear the traces in the simulator.

Run the following code cell to download the programme to the simulator and then run it in the simulator.

Move the robot to the starting location \sphinxcode{\sphinxupquote{X=100, Y=700}} and run the program again.

How does the robot’s behaviour with the “cross\sphinxhyphen{}wired” sensors and motors compare with the “direct”, same\sphinxhyphen{}side wiring?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

colorLeft = ColorSensor(INPUT\PYGZus{}2)
colorRight = ColorSensor(INPUT\PYGZus{}3)

while ((colorLeft.reflected\PYGZus{}light\PYGZus{}intensity\PYGZgt{}5)
       and (colorRight.reflected\PYGZus{}light\PYGZus{}intensity)\PYGZgt{}5):

    intensity\PYGZus{}left = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    intensity\PYGZus{}right = colorRight.reflected\PYGZus{}light\PYGZus{}intensity

    print(intensity\PYGZus{}left, intensity\PYGZus{}right)

    left\PYGZus{}motor\PYGZus{}speed = SpeedPercent(intensity\PYGZus{}right)
    right\PYGZus{}motor\PYGZus{}speed = SpeedPercent(intensity\PYGZus{}left)

    tank\PYGZus{}drive.on(left\PYGZus{}motor\PYGZus{}speed, right\PYGZus{}motor\PYGZus{}speed)
\end{sphinxVerbatim}
}

When the programme runs this time, the robot arcs \sphinxstyleemphasis{towards} the light: if it starts below the centre line, the robot turns to its left and up towards the light; if it starts above the light, the robot turns to its right, and curves down towards the light.


\subparagraph{Question}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:Question}}
How is the robot’s behaviour explained by the programme this time?

\sphinxstyleemphasis{Double click this cell to edit it and enter your explanation of why the robot behaves as it does.}


\subparagraph{Answer}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:Answer}}
\sphinxstyleemphasis{Click the arrow in the sidebar to reveal my answer.}

The sensor values are mapped onto motor speeds with the following lines of code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{left\PYGZus{}motor\PYGZus{}speed} \PYG{o}{=} \PYG{n}{SpeedPercent}\PYG{p}{(}\PYG{n}{intensity\PYGZus{}right}\PYG{p}{)}
\PYG{n}{right\PYGZus{}motor\PYGZus{}speed} \PYG{o}{=} \PYG{n}{SpeedPercent}\PYG{p}{(}\PYG{n}{intensity\PYGZus{}left}\PYG{p}{)}

\PYG{n}{tank\PYGZus{}drive}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{left\PYGZus{}motor\PYGZus{}speed}\PYG{p}{,} \PYG{n}{right\PYGZus{}motor\PYGZus{}speed}\PYG{p}{)}
\end{sphinxVerbatim}

In this configuration, the percentage scaled \sphinxstyleemphasis{right sensor} value determines the speed value applied to the \sphinxstyleemphasis{left motor}, and the percentage scaled left sensor* value sets the \sphinxstyleemphasis{right motor} speed.

As before, the sensor value reports a higher reading the brighter the background. As the robot approaches the light source from below the centreline, the left sensor reads a higher value than the right sensor. This results in the right motor turning more quickly than the left motor. As a result, the robot turns toward its left hand side and turns towards the light source.


\paragraph{Looking at the Data}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:Looking-at-the-Data}}
To understand a little more closely what the sensors are seeing, click the \sphinxstyleemphasis{Show chart} checkbox in the simulator and select the \sphinxstyleemphasis{Left light} and \sphinxstyleemphasis{Right light} traces. The following programme streams the necessary data elements to the simulator output window.

Run the program and observe the behvavior of the traces.

How do the traces differ in value?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

colorLeft = ColorSensor(INPUT\PYGZus{}2)
colorRight = ColorSensor(INPUT\PYGZus{}3)

while ((colorLeft.reflected\PYGZus{}light\PYGZus{}intensity\PYGZgt{}5)
       and (colorLeft.reflected\PYGZus{}light\PYGZus{}intensity)\PYGZgt{}5):

    intensity\PYGZus{}left = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    intensity\PYGZus{}right = colorRight.reflected\PYGZus{}light\PYGZus{}intensity

    left\PYGZus{}motor\PYGZus{}speed = SpeedPercent(intensity\PYGZus{}right)
    right\PYGZus{}motor\PYGZus{}speed = SpeedPercent(intensity\PYGZus{}left)

    tank\PYGZus{}drive.on(left\PYGZus{}motor\PYGZus{}speed, right\PYGZus{}motor\PYGZus{}speed)
    print(\PYGZsq{}Light\PYGZus{}left: \PYGZsq{} + str(intensity\PYGZus{}left ))
    print(\PYGZsq{}Light\PYGZus{}right: \PYGZsq{} + str(intensity\PYGZus{}right))
\end{sphinxVerbatim}
}

By inspection of the traces, you should notice that one of them is always slightly higher than the other.

We can also inspect the data in the notebook directly by looking at the data returned in the notebook synchroised datalog.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}Grab the logged data into a pandas dataframe
df = eds.get\PYGZus{}dataframe\PYGZus{}from\PYGZus{}datalog(roboSim.results\PYGZus{}log)

\PYGZsh{}Preview the first few rows of the dataset
df.head()
\end{sphinxVerbatim}
}

Plot the data from the dataframe using the \sphinxcode{\sphinxupquote{seaborn}} scientific charting package:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import seaborn as sns

\PYGZsh{} A line plot is a sensible chart type to use
\PYGZsh{} to plot the time series data
ax = sns.lineplot(x=\PYGZdq{}index\PYGZdq{},
                  y=\PYGZdq{}value\PYGZdq{},
                  hue=\PYGZsq{}variable\PYGZsq{},
                  data=df)
\end{sphinxVerbatim}
}


\subsection{Using Ultrasound}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:Using-Ultrasound}}
We can also create a Braitenberg vehicle that uses a single distance sensor to moderate its behaviour, for example to try to avoid obstacles.

Load in the \sphinxstyleemphasis{Obstacles Test} background, run the following code cell to download the programme to the simulator, and then run it in the simulator.

Record your observations of the the behaviour of the robot when the programme is run in the simulator with the robot starting in different positions. Based on your observations, what do sort of behaviour does the robot appear to be performing?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
import time
ultrasonic = UltrasonicSensor(INPUT\PYGZus{}1)

u = ultrasonic.distance\PYGZus{}centimeters
print(\PYGZsq{}Ultrasonic: \PYGZsq{} + str(u))
time.sleep(1)
while  u \PYGZgt{} 1:
    u = ultrasonic.distance\PYGZus{}centimeters
    print(\PYGZsq{}Ultrasonic: \PYGZsq{} + str(u))
    u = min(100, u)
    left\PYGZus{}motor\PYGZus{}speed = SpeedPercent(u)
    right\PYGZus{}motor\PYGZus{}speed = SpeedPercent(u)
    tank\PYGZus{}drive.on(left\PYGZus{}motor\PYGZus{}speed, right\PYGZus{}motor\PYGZus{}speed)

\end{sphinxVerbatim}
}

\sphinxstyleemphasis{Record your observations here about what the robot appears to be doing when the program is run in the simulator with the rovot starting in different positions.}

\sphinxstyleemphasis{Based solely on your observations, what sort of behaviour does the robot appear to be performing?}

\sphinxstyleemphasis{With reference to the programme, what actions is the robot actually performing?}

\sphinxstyleemphasis{Click the arrow in the sidebar to reveal my answer.}

\sphinxstylestrong{TO DO}


\subsubsection{Summary}
\label{\detokenize{content/03_Robot_Lab/Section_00_03:Summary}}
In this notebook you have experimented with some simple Braitenberg vehicles, seeing how a reactive control strategy based on some simple sensor inputs can lead to different emergent behabviours in the robot. In some cases, we might be tempted to call such behaviours “intelligent”, or to ascribe certain \sphinxstyleemphasis{desires} to the robot (such as ’\sphinxstyleemphasis{it}\sphinxstylestrong{wants}\sphinxstyleemphasis{to this}) but that is not really the case: the robot is simply reacting to particular inputs in a particular way.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}capture
import sys
sys.path.insert(0,\PYGZsq{}..\PYGZsq{})
import \PYGZus{}load\PYGZus{}nbev3devwidget\PYGZus{}requirements
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{o}{\PYGZpc{}}\PYG{o}{\PYGZpc{}}\PYG{n+nx}{javascript}
\PYG{c+c1}{//This allows us to resize this view}
\PYG{c+c1}{//Click on the right hand edge to drag}
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}notebook\PYGZhy{}container\PYGZdq{}} \PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{resizable}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n+nx}{ghost}\PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from \PYGZus{}load\PYGZus{}nbev3devwidget import roboSim, eds

\PYGZpc{}load\PYGZus{}ext nbev3devsim
\PYGZpc{}load\PYGZus{}ext nbtutor
\end{sphinxVerbatim}
}


\subsection{4 Reasoning and the sense\textendash{}think\textendash{}act model}
\label{\detokenize{content/03_Robot_Lab/Section_00_04:4-Reasoning-and-the-sense_think_act-model}}\label{\detokenize{content/03_Robot_Lab/Section_00_04::doc}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

colorLeft = ColorSensor(INPUT\PYGZus{}2)
colorRight = ColorSensor(INPUT\PYGZus{}3)

while ((colorLeft.reflected\PYGZus{}light\PYGZus{}intensity\PYGZgt{}5)
       and (colorLeft.reflected\PYGZus{}light\PYGZus{}intensity)\PYGZgt{}5):

    intensity\PYGZus{}left = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    intensity\PYGZus{}right = colorRight.reflected\PYGZus{}light\PYGZus{}intensity

    print(intensity\PYGZus{}left, intensity\PYGZus{}right)

    left\PYGZus{}motor\PYGZus{}speed = SpeedPercent(intensity\PYGZus{}left)
    right\PYGZus{}motor\PYGZus{}speed = SpeedPercent(intensity\PYGZus{}right)

    tank\PYGZus{}drive.on(left\PYGZus{}motor\PYGZus{}speed, right\PYGZus{}motor\PYGZus{}speed)
\end{sphinxVerbatim}
}


\subsubsection{4.1 Representing and using knowledge}
\label{\detokenize{content/03_Robot_Lab/Section_00_04:4.1-Representing-and-using-knowledge}}
Artificial intelligence and robotics have the major problem of \sphinxstyleemphasis{representing} facts and knowledge inside machines. We have a vast amount of knowledge in our brains. This knowledge is distributed over the brain, rather than each fact being neatly stored in a single memory unit.

The structure of the human brain is completely different from the structure of a robot’s or a real computer’s “brain”, and roboticists have found it very difficult to implant a wide range of experiences (real\sphinxhyphen{}world data) into robot brains. Significant progress has been made in Artificial Intelligence (AI) and Machine Learning (ML) approaches to machine vision in recent years by using ever more computational resources. Ever larger and more complex natural language processing (NLP) models are also
proving effective in parsing natural language statements and generating natural language texts.

One way of \sphinxstyleemphasis{explicitly} trying to encode knowledge is to use a \sphinxstyleemphasis{rule based system}.


\subsubsection{Eliza}
\label{\detokenize{content/03_Robot_Lab/Section_00_04:Eliza}}
Athough written fifty or so years ago, Joseph Weizenbaum’s \sphinxstyleemphasis{Eliza} programme is often referred to as one of the first great milestones in computational natural language interaction. You can see a copy of the original paper \sphinxhref{https://github.com/wadetb/eliza/blob/master/p36-weizenabaum.pdf}{here}, which includes examples of the code used to programme the original Eliza engine. Eliza has been reimplemented several times, such as in the Lisp language by Peter Norvig’s for his textbook \sphinxstyleemphasis{Paradigms
of Artificial Intelligence Programming}, as well as in Python reimplementation of Norvig’s code by Daniel Connelly (\sphinxhref{http://dhconnelly.com/paip-python/}{Paip\sphinxhyphen{}python: Peter Norvig’s Paradigms of AI Programming implemented in Python}).

A version of Connelly’s code, updated to run in the version of Python used in these notebooks, is contained in the file \sphinxurl{eliza.py}.

You can try it out for yourself by running the following code cell and starting your conversation with a \sphinxstyleemphasis{Hello}; end the conversation by starting your response with \sphinxstyleemphasis{Goodbye}):

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import eliza
eliza.hello\PYGZus{}doctor()
\end{sphinxVerbatim}
}

If you want to hear Eliza speak the responses aloud to you, start the programme by passing in the parameter \sphinxcode{\sphinxupquote{aloud=True}} in the following way: \sphinxcode{\sphinxupquote{eliza.hello\_doctor(aloud=True)}}.

If you \sphinxhref{eliza.json}{look at the rules file}, you will see that it contains a series of rules that have the form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONDITION}\PYG{p}{:} \PYG{p}{[}
    \PYG{n}{POSSIBLE\PYGZus{}RESPONSE\PYGZus{}1}\PYG{p}{,}
    \PYG{n}{POSSIBLE\PYGZus{}RESPONSE\PYGZus{}2}\PYG{p}{,}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{p}{]}
\end{sphinxVerbatim}

or more completely:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?*x KEYPHRASE ?*y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RESPONSE\PYGZus{}1 ?y?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RESPONSE\PYGZus{}2 ?y?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
        \PYG{p}{]}
\end{sphinxVerbatim}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?*x I want ?*y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{What would it mean if you got ?y?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Why do you want ?y?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Suppose you got ?y soon.}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{]}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{?*x}} and \sphinxcode{\sphinxupquote{?*y}} elements in the condition part of the rule are pattern matching operators that capture arbirtary text before and after the provided \sphinxcode{\sphinxupquote{KEYPHRASE}}. A rule matches a provided input if the \sphinxcode{\sphinxupquote{KEYPHRASE}} is contained in the text given to Eliza. The pattern matched content in the text can then be extracted from the input and used in the output response given by Eliza.

A rule matching engine, written in Python, takes the user input, tries to match it with one of the rules and then generates a response. If you are interested in how it works, Connelly provided a commentary \sphinxhref{https://dhconnelly.com/paip-python/docs/paip/eliza.html}{here} that explains how his version of the Eliza program works.


\paragraph{Optional Activity}
\label{\detokenize{content/03_Robot_Lab/Section_00_04:Optional-Activity}}
If you make a copy of the \sphinxcode{\sphinxupquote{eliza.json}} file, for example, as \sphinxcode{\sphinxupquote{dr\_me.json}} and edit it to contain your own rules, you can run Eliza using your ruleset by running the command: \sphinxcode{\sphinxupquote{eliza.hello\_doctor(\textquotesingle{}dr\_me.json\textquotesingle{})}}.

You can also provide a set of custom default responses that Eliza will select between if no rules match by passing in them into the \sphinxcode{\sphinxupquote{hello\_doctor()}} function via the \sphinxcode{\sphinxupquote{default=}} parameter. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{eliza}\PYG{o}{.}\PYG{n}{hello\PYGZus{}doctor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{doolittle.json}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                   \PYG{n}{default} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Very interesting}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I am not sure I understand you fully}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
                  \PYG{p}{)}
\end{sphinxVerbatim}

If you come up with an interesting script, please fee free to share it in the module forums.

\#\#\# Durable Rules Engine

The \sphinxhref{https://github.com/jruizgit/rules}{Durable Rules Engine} is a \sphinxstyleemphasis{polyglot} framework for creating rule based systems capable of reasonng over large collections of factual statements.

To say that the framework is \sphinxstyleemphasis{polyglot} means that we can write programmes for the same framework using different ployglot languages, specifically Python, Node.js (a flavour of Javascript) and Ruby. Underneath, the same rules engine (which itself happens to be written in the C programming language) processes the facts and the rules to allow the system to reason.

Note that the \sphinxstyleemphasis{Durable Rules Engine} is \sphinxstyleemphasis{not} available directly within our robot simulator programmes.

The engine iself is rather more powerful than the engine used in the Eliza program example and can accept a wide range of rule definitions. It also makes use of a knowledge base of asserted facts (as well as ephemeral events) that are reasoned against using the rules.

To see how this more comprehensive version of a rule based system works, let’s consider the example of reasoning over a set of “facts” that are asserted as \sphinxstyleemphasis{subject predicate object} statements. Separate rules parse one or more of these statements and then try to general additional statements as a logical consequence.

Facts might take the form \sphinxstyleemphasis{Sam is a student} where \sphinxstyleemphasis{Sam} is the subject of the statement, \sphinxstyleemphasis{student} is the object of the statement, and \sphinxstyleemphasis{is a} is a \sphinxstyleemphasis{predicate} that defines some sort of relationship between the subject and the object.

Rules test statements, and if they match the rule codition, the rule asserts another fact.

For example, \sphinxstyleemphasis{if Sam is a student, then Sam can use the module forums}.

Let’s see how that works in practice. Note that the following treatment uses a simplification of the syntax used by default in the durable rules framework. (There is just too much clutter in the original syntax to see what’s going on!)

Let’s import the packages we need and enable some magic…

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}\PYGZpc{}pip install  \PYGZhy{}\PYGZhy{}upgrade git+https://github.com/innovationOUtside/durable\PYGZus{}rules\PYGZus{}magic.git
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from durable.lang import ruleset, when\PYGZus{}all, assert\PYGZus{}fact, c, m
from durable\PYGZus{}rules\PYGZus{}tools.rules\PYGZus{}utils import new\PYGZus{}ruleset, SPO, Set, Subject
\PYGZpc{}reload\PYGZus{}ext durable\PYGZus{}rules\PYGZus{}tools
\end{sphinxVerbatim}
}

The ruleset definition syntax is little bewildering (the \sphinxcode{\sphinxupquote{@...}} statements are known as Python \sphinxstyleemphasis{decorators}; but that’s all you need to know in case you want to look them up them further, and further investigation is definitely \sphinxstyleemphasis{not required} and \sphinxstyleemphasis{not expected} of you for the purposes of this module.)

So take a deep breath, and let’s dive in, using a slightly simpler, and more generalised, statement of the same rule we considered above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if ?PERSON is student
    then ?PERSON can use forums
\end{sphinxVerbatim}

In this case, \sphinxcode{\sphinxupquote{?PERSON}} is a variable representing the subject, \sphinxstyleemphasis{forums} is the object, and \sphinxstyleemphasis{can use} is the predicate.

We can encode this a formal rule as follows (remember, you don’t need to understand what the \sphinxcode{\sphinxupquote{@...}} decorator is or how it works, just regard it as “syntactic sugar” intended to make the rule a but more readable than it might otherwise have to be; go with the flow and tried to read the rule as some sort of structured pattern you can recognise).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@when\PYGZus{}all}\PYG{p}{(}\PYG{n}{Subject}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{student}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{cm\PYGZus{}forum\PYGZus{}use}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Set}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{? : can use : forums}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
\end{sphinxVerbatim}

The rule has the form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@CONDITION}
\PYG{k}{def} \PYG{n+nf}{RULENAME}\PYG{p}{(}\PYG{n}{TESTED\PYGZus{}ASSERTION}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ACTION}
\end{sphinxVerbatim}

If you defocus your eyes, you can perhaps see how those elements might relate to a rule that coould perhaps be more logically presented as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RULENAME}\PYG{p}{:}
  \PYG{k}{if} \PYG{n}{TESTED\PYGZus{}ASSERTION} \PYG{n}{meets} \PYG{n}{CONDITION}
  \PYG{n}{then} \PYG{n}{ACTION}
\end{sphinxVerbatim}

The rule is used in the code cell below without further explanation, other than the commentary provided in the cell itself. What is important is that you see (if you close you eyes and squint hard enough!) the logical “shape” of the rule. The actual symbols used, and their placement, is “just syntax”.

Run the following cell to define a new ruleset:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} Get a unique identifier for the ruleset
RULESET\PYGZus{}1 = new\PYGZus{}ruleset()

\PYGZsh{} Add rules to the ruleset
with ruleset(RULESET\PYGZus{}1):

    \PYGZsh{} Rule condition (the \PYGZdq{}if\PYGZdq{} part)
    @when\PYGZus{}all(Subject(\PYGZdq{}is\PYGZdq{}, \PYGZdq{}student\PYGZdq{}))
    \PYGZsh{} Rule body (the \PYGZdq{}then\PYGZdq{} part)
    \PYGZsh{} \PYGZhy{} cm\PYGZus{}forum\PYGZus{}use is can be viewed as the name of the rule
    \PYGZsh{} \PYGZhy{} c is an assertion that is being tested by the rule
    def cm\PYGZus{}forum\PYGZus{}use(c):
        \PYGZsh{} This is what we actually do when the rule condition is satisfied
        \PYGZsh{} The ? in the first position says:
        \PYGZsh{}   \PYGZdq{}\PYGZdq{}\PYGZdq{}use the original value in this position (i.e. the subject)
        \PYGZsh{}      from the tested statement when creating the asserted statement\PYGZdq{}\PYGZdq{}\PYGZdq{}
        Set(c, \PYGZsq{}? : can use : forums\PYGZsq{} )

    \PYGZsh{}A \PYGZdq{}utility\PYGZdq{} rule that displays all asserted facts
    @when\PYGZus{}all(+m.subject)
    def output(c):
        print(\PYGZsq{}Fact: \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{}\PYGZsq{}.format(c.m.subject, c.m.predicate, c.m.object))
\end{sphinxVerbatim}
}

We can now assert a couple of facts, and see what conclusions can be draw about them from an application of the rules…

Facts are asserted in the form: \sphinxcode{\sphinxupquote{subject : predicate : object}}.

We assert facts in the context of a particular ruleset via a cell block magic, \sphinxcode{\sphinxupquote{\%\%assert\_facts \sphinxhyphen{}r RULESET\_NAME}}.

Run the following cell to assert some facts against the \sphinxcode{\sphinxupquote{RULESET\_1}} ruleset:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}assert\PYGZus{}facts \PYGZhy{}r RULESET\PYGZus{}1
Sam : is : student
Jo : is : course manager
\end{sphinxVerbatim}
}

We can’t easily add rules to a pre\sphinxhyphen{}exsiting ruleset, so let’s create another ruleset, building on the first, that contains another rule:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}RULESET\PYGZus{}2 = new\PYGZus{}ruleset()
with ruleset(RULESET\PYGZus{}2):

    @when\PYGZus{}all(Subject(\PYGZdq{}is\PYGZdq{}, \PYGZdq{}course manager\PYGZdq{}))
    def cm\PYGZus{}forum\PYGZus{}use(c):
        Set(c, \PYGZsq{}? : can read : forum discussions\PYGZsq{} )


    \PYGZsh{} \PYGZhy{}\PYGZhy{} PREVIOUS RULES \PYGZhy{}\PYGZhy{}

    @when\PYGZus{}all(Subject(\PYGZdq{}is\PYGZdq{}, \PYGZdq{}student\PYGZdq{}))
    def cm\PYGZus{}forum\PYGZus{}use(c):
        Set(c, \PYGZsq{}? : can use : forums\PYGZsq{} )

    @when\PYGZus{}all(+m.subject)
    def output(c):
        print(\PYGZsq{}Fact: \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{}\PYGZsq{}.format(c.m.subject, c.m.predicate, c.m.object))
\end{sphinxVerbatim}
}

Let’s test our assertions again:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}assert\PYGZus{}facts \PYGZhy{}r RULESET\PYGZus{}2
Sam : is : student
Jo : is : course manager
\end{sphinxVerbatim}
}

So, course managers can \sphinxstyleemphasis{read} forum discussions, but students can \sphinxstyleemphasis{use} forums. What might that entail?

In the following set, we define two rules that test the same condition, but with different actions:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}RULESET\PYGZus{}3 = new\PYGZus{}ruleset()
with ruleset(RULESET\PYGZus{}3):

    @when\PYGZus{}all(Subject(\PYGZdq{}can use\PYGZdq{}, \PYGZdq{}forums\PYGZdq{}))
    def forum\PYGZus{}read(c):
        Set(c, \PYGZsq{}? : can read : forum discussions\PYGZsq{} )

    @when\PYGZus{}all(Subject(\PYGZdq{}can use\PYGZdq{}, \PYGZdq{}forums\PYGZdq{}))
    def forum\PYGZus{}post(c):
        Set(c, \PYGZsq{}? : can post to : forum discussions\PYGZsq{} )


    \PYGZsh{} \PYGZhy{}\PYGZhy{} PREVIOUS RULES \PYGZhy{}\PYGZhy{}
    @when\PYGZus{}all(Subject(\PYGZdq{}is\PYGZdq{}, \PYGZdq{}course manager\PYGZdq{}))
    def cm\PYGZus{}forum\PYGZus{}use(c):
        Set(c, \PYGZsq{}? : can read : forum discussions\PYGZsq{} )

    @when\PYGZus{}all(Subject(\PYGZdq{}is\PYGZdq{}, \PYGZdq{}student\PYGZdq{}))
    def student\PYGZus{}forum\PYGZus{}use(c):
        Set(c, \PYGZsq{}? : can use : forums\PYGZsq{} )

    @when\PYGZus{}all(+m.subject)
    def output(c):
        print(\PYGZsq{}Fact: \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{}\PYGZsq{}.format(c.m.subject, c.m.predicate, c.m.object))
\end{sphinxVerbatim}
}

What can we determine now?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}assert\PYGZus{}facts \PYGZhy{}r RULESET\PYGZus{}3
Sam : is : student
Jo : is : course manager
\end{sphinxVerbatim}
}

At the next level of complexity, we might want to draw some conclusions about multiple facts. Suppose, for example, that we wish to identify people who have “engaged” with the forums. We might define such people as people who have read a forum post and who have posted to a forum.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}assert\PYGZus{}facts \PYGZhy{}r RULESET\PYGZus{}3

Al : has read : forum post
Al : has posted to : forum

Sam : has posted to : forum
\end{sphinxVerbatim}
}

The rules we have seen so far test just a single condition, so how do we test \sphinxstyleemphasis{two} conditions?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if ?PERSON has read forum post AND ?PERSON has posted to forum
then ?PERSON has engaged with forum
\end{sphinxVerbatim}

This is where things start getting trickier, and where we shall finish our quick introduction to creating rules with the \sphinxstyleemphasis{durable rules} framework. Briefly, we create a temporary reference when a fact matches a condition, and then compare those temporary references to see whether the same fact satisfied both conditions:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}RULESET\PYGZus{}4 = new\PYGZus{}ruleset()
with ruleset(RULESET\PYGZus{}4):

    @when\PYGZus{}all(c.first \PYGZlt{}\PYGZlt{} Subject(\PYGZsq{}has read\PYGZsq{}, \PYGZsq{}forum post\PYGZsq{}),
              c.second \PYGZlt{}\PYGZlt{} Subject(\PYGZsq{}has posted to\PYGZsq{}, \PYGZsq{}forum\PYGZsq{}) \PYGZam{} (m.subject == c.first.subject))
    def forum\PYGZus{}discussions(c):
        c.assert\PYGZus{}fact(\PYGZob{} \PYGZsq{}subject\PYGZsq{}: c.first.subject,
                       \PYGZsq{}predicate\PYGZsq{}: \PYGZsq{}has engaged with\PYGZsq{},
                       \PYGZsq{}object\PYGZsq{}: \PYGZsq{}forum\PYGZsq{} \PYGZcb{})

    @when\PYGZus{}all(+m.subject)
    def output(c):
        print(\PYGZsq{}Fact: \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{}\PYGZsq{}.format(c.m.subject, c.m.predicate, c.m.object))
\end{sphinxVerbatim}
}

Let’s now test the following assertions to see who has been identified as engaging with the forums:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}assert\PYGZus{}facts \PYGZhy{}r RULESET\PYGZus{}4

Al : has read : forum post
Al : has posted to : forum

Sam : has posted to : forum
\end{sphinxVerbatim}
}

Hopefully, from these examples and the earlier Eliza example, you have a feeling for how we can build up quite rich sequences of behaviour (conversations over time, logical reasoning over multiple facts, including over facts derived from earlier presented facts) using quite simple rules. But while each rule in and of itself might be quite simple, and the discrete actions performed by each rule might be quite simple, the emergent behaviour might be quite elaborate.

\#\#\# Trying out another ruleset

eg from example on druable rules README

We can define a really simple Python speech class that allows us to speak from code contained in a notebook using the browser’s Javascript speech engine:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from IPython.display import Javascript

class Speech():
    def say(self, txt):
        display(Javascript(f\PYGZsq{}speechSynthesis.speak(new SpeechSynthesisUtterance(\PYGZdq{}\PYGZob{}txt\PYGZcb{}\PYGZdq{}))\PYGZsq{}))

speaker = Speech()
speaker.say(\PYGZsq{}hello\PYGZsq{})
\end{sphinxVerbatim}
}

Building on the simple speech class for taling via the browser, I have created a class that keeps track of how many messages have been posted and returns a visual count of utterances, alongside a transcript of the utterance.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from IPython.display import Javascript

class Speech():
    def \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}(self, voice=None, reset=True):
        if reset:
            self.count = 1
        self.voice = voice
        self.\PYGZus{}get\PYGZus{}voices()
        self.voicelist = \PYGZsq{}\PYGZsq{}

    def set\PYGZus{}voice(self, voicenum):
        \PYGZdq{}\PYGZdq{}\PYGZdq{}Set voice number.\PYGZdq{}\PYGZdq{}\PYGZdq{}
        self.voice = voicenum

    def say(self, txt, showtext = True):
        \PYGZdq{}\PYGZdq{}\PYGZdq{}Speak an utterance.\PYGZdq{}\PYGZdq{}\PYGZdq{}
        js = f\PYGZsq{}\PYGZsq{}\PYGZsq{}
        var utterance = new SpeechSynthesisUtterance(\PYGZdq{}\PYGZob{}txt\PYGZcb{}\PYGZdq{});
        \PYGZsq{}\PYGZsq{}\PYGZsq{}
        if self.voice:
            js = js + f\PYGZsq{}\PYGZsq{}\PYGZsq{}
            utterance.voice = window.speechSynthesis.getVoices()[\PYGZob{}self.voice\PYGZcb{}];
            \PYGZsq{}\PYGZsq{}\PYGZsq{}
        js = js + \PYGZsq{}speechSynthesis.speak(utterance);\PYGZsq{}
        display(Javascript(js))

        if showtext:
            print(f\PYGZsq{}\PYGZob{}self.count\PYGZcb{}: \PYGZob{}txt\PYGZcb{}\PYGZsq{})
        self.count = self.count +1

    def reset\PYGZus{}count(self):
        \PYGZdq{}\PYGZdq{}\PYGZdq{}Reset the counter.\PYGZdq{}\PYGZdq{}\PYGZdq{}
        self.count = 1

    def \PYGZus{}get\PYGZus{}voices(self):
        \PYGZdq{}\PYGZdq{}\PYGZdq{}Show a list of supported voices.\PYGZdq{}\PYGZdq{}\PYGZdq{}
        \PYGZsh{} via https://developer.mozilla.org/en\PYGZhy{}US/docs/Web/API/SpeechSynthesis/getVoices
        js = \PYGZsq{}\PYGZsq{}\PYGZsq{}
        var voices =  window.speechSynthesis.getVoices();
    var voicelist = \PYGZsq{}\PYGZsq{};
   for(var i = 0; i \PYGZlt{} voices.length; i++) \PYGZob{}
   voicelist = voicelist+i+\PYGZsq{}: \PYGZsq{}+ voices[i].name + \PYGZsq{} (\PYGZsq{}+ voices[i].lang +\PYGZsq{})\PYGZsq{};
    if(voices[i].default) \PYGZob{}
      voicelist += \PYGZsq{} \PYGZhy{}\PYGZhy{} DEFAULT\PYGZsq{};
    \PYGZcb{}
   voicelist = voicelist + \PYGZsq{}*\PYGZsq{}
  \PYGZcb{}

IPython.notebook.kernel.execute(\PYGZdq{}\PYGZus{}browser\PYGZus{}voicelist = \PYGZsq{}\PYGZdq{}+ voicelist+\PYGZdq{}\PYGZsq{}\PYGZdq{});
        \PYGZsq{}\PYGZsq{}\PYGZsq{}
        display(Javascript(js))

    def show\PYGZus{}voices(self):
        self.voicelist = \PYGZus{}browser\PYGZus{}voicelist

        outlist = \PYGZsq{}\PYGZbs{}n\PYGZsq{}.join([s.strip() for s in \PYGZus{}browser\PYGZus{}voicelist.split(\PYGZsq{}*\PYGZsq{})])
        print(outlist)
        \PYGZsh{}return self.voicelist
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}speaker = Speech()

\PYGZsh{}speaker.set\PYGZus{}voice(49)
speaker.say(\PYGZsq{}hello how are you\PYGZsq{})
\end{sphinxVerbatim}
}

We can also show the list of voices.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}speaker.show\PYGZus{}voices()
\end{sphinxVerbatim}
}

You can use the folowing command to reset the message count:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}speaker.reset\PYGZus{}count()
speaker.say(\PYGZsq{}hello again\PYGZsq{})
\end{sphinxVerbatim}
}

Now we can listen to the rules as they are fired, as well as seeing a report that shows the order in which they were fired.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}RULESET = new\PYGZus{}ruleset()
with ruleset(RULESET):
    @when\PYGZus{}all(c.first \PYGZlt{}\PYGZlt{} Subject(\PYGZsq{}eats\PYGZsq{}, \PYGZsq{}flies\PYGZsq{}),
              Subject(\PYGZsq{}lives\PYGZsq{}, \PYGZsq{}water\PYGZsq{}) \PYGZam{} (m.subject == c.first.subject))
    def frog(c):
        c.assert\PYGZus{}fact(SPO(c.first.subject, \PYGZsq{}is\PYGZsq{}, \PYGZsq{}frog\PYGZsq{}))

    @when\PYGZus{}all(c.first \PYGZlt{}\PYGZlt{} Subject(\PYGZsq{}eats\PYGZsq{}, \PYGZsq{}flies\PYGZsq{}),
              Subject(\PYGZsq{}lives\PYGZsq{}, \PYGZsq{}land\PYGZsq{}) \PYGZam{} (m.subject == c.first.subject))
    def chameleon(c):
        c.assert\PYGZus{}fact(SPO(c.first.subject, \PYGZsq{}is\PYGZsq{}, \PYGZsq{}chameleon\PYGZsq{}))

    @when\PYGZus{}all(Subject(\PYGZsq{}eats\PYGZsq{}, \PYGZsq{}worms\PYGZsq{}))
    def bird(c):
        speaker.say(f\PYGZsq{}if \PYGZob{}c.m.subject\PYGZcb{} eats worms\PYGZsq{})
        Set(c, \PYGZsq{}? : is : bird\PYGZsq{})
        speaker.say(f\PYGZsq{}\PYGZob{}c.m.subject\PYGZcb{} is a bird\PYGZsq{})

    @when\PYGZus{}all(Subject(\PYGZsq{}is\PYGZsq{}, \PYGZsq{}frog\PYGZsq{}))
    def green(c):
        Set(c, \PYGZsq{}? : is : green\PYGZsq{})

    @when\PYGZus{}all(Subject(\PYGZsq{}is\PYGZsq{}, \PYGZsq{}chameleon\PYGZsq{}))
    def grey(c):
        Set(c, \PYGZsq{}? : is : grey\PYGZsq{})

    @when\PYGZus{}all(Subject(\PYGZsq{}is\PYGZsq{}, \PYGZsq{}bird\PYGZsq{}))
    def black(c):
        speaker.say(f\PYGZsq{}if \PYGZob{}c.m.subject\PYGZcb{} is a bird\PYGZsq{})
        Set(c, \PYGZsq{}? :is : black\PYGZsq{})
        speaker.say(f\PYGZsq{}\PYGZob{}c.m.subject\PYGZcb{} is black\PYGZsq{})

    @when\PYGZus{}all(Subject(\PYGZdq{}is\PYGZdq{}, \PYGZdq{}bird\PYGZdq{}))
    def can\PYGZus{}fly(c):
        speaker.say(f\PYGZsq{}if \PYGZob{}c.m.subject\PYGZcb{} is a bird\PYGZsq{})
        Set(c, \PYGZsq{}? : can : fly\PYGZsq{} )
        speaker.say(f\PYGZsq{}\PYGZob{}c.m.subject\PYGZcb{} can fly\PYGZsq{})

    @when\PYGZus{}all(+m.subject)
    def output(c):
        print(\PYGZsq{}\PYGZbs{}nFact: \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{}\PYGZsq{}.format(c.m.subject, c.m.predicate, c.m.object))
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}assert\PYGZus{}facts \PYGZhy{}r RULESET
Kermit : eats : worms
\end{sphinxVerbatim}
}


\subsubsection{More General Forms of Rules}
\label{\detokenize{content/03_Robot_Lab/Section_00_04:More-General-Forms-of-Rules}}
So far we have focused on reasoning about “facts” in the form of statements with the form \sphinxstyleemphasis{subject predicate object}.

But this actally represents a more complicated form of reasoning than the rules engine actually employs because the \sphinxstyleemphasis{atomic} smallest possible facts are not the \sphinxstyleemphasis{subject predicate object} triples at all, they are the individual properties: \sphinxcode{\sphinxupquote{\{subject: SUBJECT\}}}, \sphinxcode{\sphinxupquote{\{\textquotesingle{}predicate\textquotesingle{}: PREDICATE\}}} and \sphinxcode{\sphinxupquote{\{object: OBJECT\}}}.


\paragraph{Facts versus Events}
\label{\detokenize{content/03_Robot_Lab/Section_00_04:Facts-versus-Events}}
Facts persist, events are retracted once they have been evaluated. Events are particularly useful in a robotics context, where we may want to respond to repeated sensor events.

For example, imagine a case where we want to avoid a red line, because red lines indicate danger.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from durable.lang import post

RULESET = new\PYGZus{}ruleset()
with ruleset(RULESET):
    \PYGZsh{} this rule will trigger as soon as three events match the condition
    @when\PYGZus{}all(m.color==\PYGZsq{}red\PYGZsq{})
    def see\PYGZus{}red(c):
        speaker.say(f\PYGZsq{}I see red\PYGZsq{})
        c.assert\PYGZus{}fact(\PYGZob{}\PYGZsq{}status\PYGZsq{}: \PYGZsq{}danger\PYGZsq{}\PYGZcb{})

    @when\PYGZus{}all(m.color!=\PYGZsq{}red\PYGZsq{})
    def not\PYGZus{}red(c):
        speaker.say(f\PYGZsq{}I see \PYGZob{}c.m.color\PYGZcb{}\PYGZsq{})
        c.assert\PYGZus{}fact(\PYGZob{}\PYGZsq{}status\PYGZsq{}: \PYGZsq{}safe\PYGZsq{}\PYGZcb{})

    @when\PYGZus{}all( m.status == \PYGZsq{}danger\PYGZsq{})
    def dangerous(c):
        speaker.say(f\PYGZsq{}That is dangerous.\PYGZsq{})
        c.retract\PYGZus{}fact(\PYGZob{}\PYGZsq{}status\PYGZsq{}: \PYGZsq{}danger\PYGZsq{}\PYGZcb{})

    @when\PYGZus{}all( m.status == \PYGZsq{}safe\PYGZsq{})
    def safe(c):
        speaker.say(f\PYGZsq{}That is safe.\PYGZsq{})
        c.retract\PYGZus{}fact(\PYGZob{}\PYGZsq{}status\PYGZsq{}: \PYGZsq{}safe\PYGZsq{}\PYGZcb{})

\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}post(RULESET, \PYGZob{}\PYGZsq{}color\PYGZsq{}: \PYGZsq{}red\PYGZsq{} \PYGZcb{});
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}post(RULESET, \PYGZob{}\PYGZsq{}color\PYGZsq{}: \PYGZsq{}green\PYGZsq{} \PYGZcb{});
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}post(RULESET, \PYGZob{}\PYGZsq{}color\PYGZsq{}: \PYGZsq{}red\PYGZsq{} \PYGZcb{});
post(RULESET, \PYGZob{}\PYGZsq{}color\PYGZsq{}: \PYGZsq{}green\PYGZsq{} \PYGZcb{});
\end{sphinxVerbatim}
}


\paragraph{How might rules be useful in a robot context?}
\label{\detokenize{content/03_Robot_Lab/Section_00_04:How-might-rules-be-useful-in-a-robot-context?}}
Although we can easily create our own \sphinxcode{\sphinxupquote{if...}} statements in the programme downloaded to the simulator, and control the robot’s behaviour that way, it may more convenient to develop, and test, a large and possibly complex rule based set of behaviours using a framework such as a \sphinxstyleemphasis{Durable Rules}.

This may be achieved by capturing sensor values from the robot in the simulator, passing them back to the notebook’s Python context, passing them as events to the Durable Rules ruleset, applying the rules to create some statement of a desired motor action, and then returning this instruction to the simulated robot for execution there.

We will not pursue this approach further, here. However, you will have an opportunity to control the simulated robot in a similar way using a neural network running in the notebook context, rather than a rule based system, in a later notebook.


\paragraph{Addendum \sphinxhyphen{} Using Python to Respond to and Control Events in the Simulator}
\label{\detokenize{content/03_Robot_Lab/Section_00_04:Addendum---Using-Python-to-Respond-to-and-Control-Events-in-the-Simulator}}
\sphinxstylestrong{THESE ARE JUST MY WORKING NOTES AS I TRY TO FIGURE STUFF OUT…}

Can we find a way of getting the robot to post a message to Python, and Python to respond with a message back to the robot that the robot can respond to?

The original RobotLab activities include examples of round\sphinxhyphen{}tripping, with the simulated robot passing state out to a remote application, which then returned a response to the simulated robot. I’m pretty sure we can do the same, either with a predefined application or a user defined function. The latter would be best because then we could have an activity to write a helper application in notebook python that is called on by the simulated robot.

At the moment, I have managed to send a message to Py from the simulator via messages sent to the simulator output window. There is a callback that sends messages back from Py to the sim output window, but as yet the robot py code running in the simulator is oblivious to returned messages. (I need half a day, perhaps, a day, to actually get code into the simulator so the programme code can access it.)

The following recipe shows how to overwrite the default collaborative \sphinxcode{\sphinxupquote{responder()}} function with a custom one.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}class CollabSim(eds.Ev3DevWidget):
     def responder(self, obj):
        \PYGZdq{}\PYGZdq{}\PYGZdq{} Callback function that tries to respond to widget.\PYGZdq{}\PYGZdq{}\PYGZdq{}
        \PYGZsh{} obj is the message sent from the simulator
        \PYGZsh{}Generate a response
        response = f\PYGZsq{}pingpongBONG \PYGZob{}obj\PYGZcb{}\PYGZsq{}
        \PYGZsh{}Send the response back to the simulator
        \PYGZsh{}At the moment, this is simply echoed in the simulator output window
        self.set\PYGZus{}element(\PYGZdq{}response\PYGZdq{}, response)

\PYGZsh{} We now create an instance of the simulator with the custom collaborative callback function
roboSim = CollabSim()
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}Requirement for styling simulator widget toolbar
import \PYGZus{}load\PYGZus{}nbev3devwidget\PYGZus{}requirements
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}Style notebook
from IPython.display import Javascript
Javascript(\PYGZsq{}\PYGZdl{}( \PYGZdq{}\PYGZsh{}notebook\PYGZhy{}container\PYGZdq{} ).resizable(\PYGZob{}ghost: false\PYGZcb{})\PYGZsq{})

\PYGZsh{} Load nbev3devsim simulator
from \PYGZus{}load\PYGZus{}nbev3devwidget import roboSim

\PYGZsh{}Load nbev3devsim magic
\PYGZpc{}load\PYGZus{}ext nbev3devsim

\PYGZsh{}Load the nbtutor extension
\PYGZpc{}load\PYGZus{}ext nbtutor
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{}Load the nbtutor extension
\PYGZpc{}load\PYGZus{}ext nbtutor

\PYGZsh{}Reset the notebook style
from IPython.core.display import display, HTML

display(HTML(\PYGZdq{}\PYGZlt{}style\PYGZgt{}\PYGZsh{}notebook\PYGZhy{}container \PYGZob{} width:50\PYGZpc{}; float:left !important;\PYGZcb{}\PYGZlt{}/style\PYGZgt{}\PYGZdq{}))


\PYGZsh{}Launch the simulator
from nbev3devsim import ev3devsim\PYGZus{}nb as eds
\PYGZpc{}load\PYGZus{}ext nbev3devsim

roboSim = eds.Ev3DevWidget()

roboSim.set\PYGZus{}element(\PYGZdq{}response\PYGZdq{}, \PYGZsq{}\PYGZsq{})

display(roboSim)
roboSim.element.dialog();


roboSim.js\PYGZus{}init(\PYGZdq{}\PYGZdq{}\PYGZdq{}
element.dialog(\PYGZob{} \PYGZdq{}title\PYGZdq{} : \PYGZdq{}Robot Simulator\PYGZdq{} \PYGZcb{}).dialogExtend(\PYGZob{}
        \PYGZdq{}maximizable\PYGZdq{} : true,
        \PYGZdq{}dblclick\PYGZdq{} : \PYGZdq{}maximize\PYGZdq{},
        \PYGZdq{}icons\PYGZdq{} : \PYGZob{} \PYGZdq{}maximize\PYGZdq{} : \PYGZdq{}ui\PYGZhy{}icon\PYGZhy{}arrow\PYGZhy{}4\PYGZhy{}diag\PYGZdq{} \PYGZcb{}\PYGZcb{});
\PYGZdq{}\PYGZdq{}\PYGZdq{})
\end{sphinxVerbatim}
}


\subsection{5 Functions}
\label{\detokenize{content/03_Robot_Lab/Section_00_05:5-Functions}}\label{\detokenize{content/03_Robot_Lab/Section_00_05::doc}}
\sphinxstylestrong{TO DO: this needs to be earlier, before rules?}

Many of the programmes we have used so far have been quite short programmes with little, if any, reused code.

As programmes get larger, it is often convenient to encapsulate several lines of code within a \sphinxstyleemphasis{function}. The multiple lines of code within the function can then be called conveniently from a single statement whenever they are needed.

Functions are very powerful, and if you have studied other programming courses, you may well be familiar with them.

For our purposes, the following provides a very quick review of some of the key behaviours of Pyhton functions. Remember, this isn’t a Python programming module \sphinxstyleemphasis{per se}; rather, it’s a module where we explore how to use Python to get things done. What follows should be enough to get you started writing your own functions, without creating too many bad habits along the way.

To see how we can create our own functions, let’s consider a really simple example, a function that just prints out the word \sphinxstyleemphasis{Hello}.

The function definition has a very specific syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{FUNCTION\PYGZus{}NAME}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
     \PYG{n}{ONE\PYGZus{}OR\PYGZus{}MORE\PYGZus{}LINES\PYGZus{}OF\PYGZus{}CODE}
\end{sphinxVerbatim}

Here are some of the rules relating to the sytactic defintion of a Python function:
\begin{itemize}
\item {} 
the \sphinxcode{\sphinxupquote{FUNCTION\_NAME}} \sphinxstylestrong{MUST NOT} contain any spaces or punctuation other than underscore (\sphinxcode{\sphinxupquote{\_}}) characters;

\item {} 
the function name \sphinxstylestrong{MUST} be followed by a pair of brackets (\sphinxcode{\sphinxupquote{()}}), that may contain something (we’ll see what later), followed by a colon (\sphinxcode{\sphinxupquote{:}});

\item {} 
the body of the function \sphinxstylestrong{MUST} be indented using space or tab characters. The level of indentation of the firxt line sets the effective “left\sphinxhyphen{}hand margin” for the remaining lines of code in the function;

\item {} 
the body of the function must include \sphinxstylestrong{AT LEAST} one valid statement / line of code \sphinxstylestrong{EXCLUDING} comments. If you don’t want the function to do anything, but need it as a placeholder, use \sphinxcode{\sphinxupquote{pass}} as the single line of required code in the function body.

\end{itemize}

It is also good practice to annotate your function with a so\sphinxhyphen{}called “docstring” (\sphinxstyleemphasis{documentation string}) providing a concise, imperative description of what the function does.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{FUNCTION\PYGZus{}NAME}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}\PYGZdq{}Docstring contain a concise summary of the function behaviour.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
     \PYG{n}{ONE\PYGZus{}OR\PYGZus{}MORE\PYGZus{}LINES\PYGZus{}OF\PYGZus{}CODE}
\end{sphinxVerbatim}

Run the following code cell to define a simple function that prints the message \sphinxstyleemphasis{‘hello’}:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}def sayHello():
    print(\PYGZsq{}Hello\PYGZsq{})
\end{sphinxVerbatim}
}

When we \sphinxstyleemphasis{call} the function, the code contained within the function body is executed.

Run the following cell to call the function:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}sayHello()
\end{sphinxVerbatim}
}

Functions can contain multiple lines of code, which means they can provide a convenient way of calling multiple lines of code from a single line of code.

Functions can also be used to perform actions over one or more arguments passed into the function. For example, if you want to say hello to a specific person by name, we can pass their name into the function as an argument, and then use that argument within the body of the function.

We’ll use a Python \sphinxstyleemphasis{f}\sphinxhyphen{}string as a convenient way of passing the variable value, by reference, into a string:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}def sayHelloName(name):
    \PYGZdq{}\PYGZdq{}\PYGZdq{}Print a welcome messge.\PYGZdq{}\PYGZdq{}\PYGZdq{}
    print(f\PYGZdq{}Hello, \PYGZob{}name\PYGZcb{}\PYGZdq{})
\end{sphinxVerbatim}
}

Let’s call that function to see how it behaves:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}sayHelloName(\PYGZdq{}Sam\PYGZdq{})
\end{sphinxVerbatim}
}

What happens if we forget to provide a name?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}sayHelloName()
\end{sphinxVerbatim}
}

Oops… We have defined the argument as a \sphinxstyleemphasis{positional} argument that is REQUIRED if the function is to be called without raising an error.

If we want to make the argument optional, we need to provide a default value:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}def sayHelloName(name=\PYGZsq{}there\PYGZsq{}):
    \PYGZdq{}\PYGZdq{}\PYGZdq{}Print a message to welcome someone by name.\PYGZdq{}\PYGZdq{}\PYGZdq{}
    print(f\PYGZdq{}Hello, \PYGZob{}name\PYGZcb{}\PYGZdq{})

sayHelloName()
\end{sphinxVerbatim}
}

If we want to have different behaviours depending on whether a value is passed for the name, we can set a default such as \sphinxcode{\sphinxupquote{None}} and then use a conditional statement to determine what to do based on the value that is presented:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}def sayHelloName(name=None):
    \PYGZdq{}\PYGZdq{}\PYGZdq{}Print a message to welcome someone optionally by name.\PYGZdq{}\PYGZdq{}\PYGZdq{}
    if name:
        print(f\PYGZdq{}Hello, \PYGZob{}name\PYGZcb{}\PYGZdq{})
    else:
        print(\PYGZdq{}Hi there!\PYGZdq{})

sayHelloName()
\end{sphinxVerbatim}
}

Sometimes, we may want to get one or more values returned back from a function. We can do that using the \sphinxcode{\sphinxupquote{return}} statement. The \sphinxcode{\sphinxupquote{return}} statement essentially does two things when it is called: firstly, it terminates the function’s execution at that point; secondly, it optionally returns a value to the part of the program that called the function.

Run the following code cell to define a function that constructs a welcome message, displays the message \sphinxstyleemphasis{and returns it}:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}def sayAndReturnHelloName(name):
    \PYGZdq{}\PYGZdq{}\PYGZdq{}Print a welcome message and return it.\PYGZdq{}\PYGZdq{}\PYGZdq{}
    message = f\PYGZdq{}Hello, \PYGZob{}name\PYGZcb{}\PYGZdq{}
    print(\PYGZdq{}Printing:\PYGZdq{}, message)
    return message
\end{sphinxVerbatim}
}

What do you think will happen when we call the function?

\sphinxstyleemphasis{Write your prediction about what you think will happen when the function is run here}\sphinxstylestrong{before}\sphinxstyleemphasis{you run the code cell to call it.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}sayAndReturnHelloName(\PYGZsq{}Sam\PYGZsq{})
\end{sphinxVerbatim}
}

Did you get the response you expected?

In the first case, a message was \sphinxstyleemphasis{printed} out in the cells print area. In the second case, the message was returned as the value returned by the function. As the function appeared on the last line of the code cell, its value was \sphinxstyleemphasis{displayed} as the cell output.

As you might expect, we can set a variable to the value returned from a function:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}message = sayAndReturnHelloName(\PYGZsq{}Sam\PYGZsq{})
\end{sphinxVerbatim}
}

If we view the value of that variable by running the following cell, what do you think you will see? Will the message be printed as well as displayed?

\sphinxstyleemphasis{Write your prediction about what you think will happen when the function is run here}\sphinxstylestrong{before}\sphinxstyleemphasis{you run the code cell to call it.}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}message
\end{sphinxVerbatim}
}

Only the value returned from the function is displayed. The function is not called again, and so there is no instruction to \sphinxstyleemphasis{print} the message.

To return multiple values, we do that from a single return statement:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}def sayAndReturnHelloName(name):
    \PYGZdq{}\PYGZdq{}\PYGZdq{}Print a welcome message and return it.\PYGZdq{}\PYGZdq{}\PYGZdq{}
    message = f\PYGZdq{}Hello, \PYGZob{}name\PYGZcb{}\PYGZdq{}
    print(\PYGZdq{}Printing:\PYGZdq{}, message)
    return (name, message)

sayAndReturnHelloName(\PYGZsq{}Sam\PYGZsq{})
\end{sphinxVerbatim}
}

Finally, we can have multiple return statements in a function, but only one of them can be called from a single invocation of the function:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}def sayHelloName(name=None):
    \PYGZdq{}\PYGZdq{}\PYGZdq{}Print a message to welcome someone optionally by name.\PYGZdq{}\PYGZdq{}\PYGZdq{}
    if name:
        print(f\PYGZdq{}Hello, \PYGZob{}name\PYGZcb{}\PYGZdq{})
        return (name, message)
    else:
        print(\PYGZdq{}Hi there!\PYGZdq{})
    return

print(sayHelloName(), \PYGZsq{}and\PYGZsq{}, sayHelloName(\PYGZdq{}Sam\PYGZdq{}))
\end{sphinxVerbatim}
}

Generally, it is \sphinxstyleemphasis{not} good practice to return different sorts of object from different parts of the same function.

There is quite a lot more to know about functions, particularly in respect of how variables inside the function relate to variables defined outside the function, a topic referred to as \sphinxstyleemphasis{variable scope}. But for a treatment of that, you will need to refer to a module with a heavier emphasis on teaching programming.


\subsubsection{Using Functions in Robot Control Programs}
\label{\detokenize{content/03_Robot_Lab/Section_00_05:Using-Functions-in-Robot-Control-Programs}}
We’ll start by considering the simple program we wrote to make the robot trace out a square.

If you recall, our first version of this explicitly coded each turn and edge movement, and then we used a loop to repeat the same action several times.

Move the robot to the bottom left corner of the simulator window, run the following code cell to download the programme to the simulator and then run the programme in the simulator.

Tweak the parameter settings until the robot approximately traces out the shape of a square.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

SIDES = 4

\PYGZsh{} Try to draw a square
STEERING = \PYGZhy{}100
TURN\PYGZus{}ROTATIONS = 0.826
TURN\PYGZus{}SPEED = 40

STRAIGHT\PYGZus{}SPEED\PYGZus{}PC = SpeedPercent(40)
STRAIGHT\PYGZus{}ROTATIONS = 4

for side in range(SIDES):
    \PYGZsh{}Go straight
    \PYGZsh{} Set the left and right motors in a forward direction
    \PYGZsh{} and run for 1 rotation
    tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(STRAIGHT\PYGZus{}SPEED\PYGZus{}PC,
                                STRAIGHT\PYGZus{}SPEED\PYGZus{}PC,
                                STRAIGHT\PYGZus{}ROTATIONS)

    \PYGZsh{}Turn
    \PYGZsh{} Set the robot to turn on the spot
    \PYGZsh{} and run for a certain number of rotations *of the wheels*
    tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(STEERING,
                               SpeedPercent(TURN\PYGZus{}SPEED),
                               TURN\PYGZus{}ROTATIONS)
\end{sphinxVerbatim}
}

We could can extract this code into a function that allows us to draw a square whenever we want. By adding an option \sphinxcode{\sphinxupquote{side\_length}} parameter we can change the side length as required.

Download the following programme to the simulator and run it there.

Can you modify the programme to draw a third square with a size somewhere between the size of the first two squares?

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded

SIDES = 4

\PYGZsh{} Try to draw a square
STEERING = \PYGZhy{}100
TURN\PYGZus{}ROTATIONS = 0.826
TURN\PYGZus{}SPEED = 40

STRAIGHT\PYGZus{}SPEED\PYGZus{}PC = SpeedPercent(40)
STRAIGHT\PYGZus{}ROTATIONS = 6

def draw\PYGZus{}square(side=STRAIGHT\PYGZus{}ROTATIONS):
    \PYGZdq{}\PYGZdq{}\PYGZdq{}Draw square of specified side length.\PYGZdq{}\PYGZdq{}\PYGZdq{}
    for side in range(SIDES):
        \PYGZsh{}Go straight
        \PYGZsh{} Set the left and right motors in a forward direction
        \PYGZsh{} and run for 1 rotation
        tank\PYGZus{}drive.on\PYGZus{}for\PYGZus{}rotations(STRAIGHT\PYGZus{}SPEED\PYGZus{}PC,
                                    STRAIGHT\PYGZus{}SPEED\PYGZus{}PC,
                                    \PYGZsh{}Use provided side length
                                    side)

        \PYGZsh{}Turn
        \PYGZsh{} Set the robot to turn on the spot
        \PYGZsh{} and run for a certain number of rotations *of the wheels*
        tank\PYGZus{}turn.on\PYGZus{}for\PYGZus{}rotations(STEERING,
                                   SpeedPercent(TURN\PYGZus{}SPEED),
                                   TURN\PYGZus{}ROTATIONS)


\PYGZsh{} Call the function to draw a small size square
draw\PYGZus{}square(4)

\PYGZsh{} And an even smaller square
draw\PYGZus{}square(2)
\end{sphinxVerbatim}
}


\paragraph{Optional Activity}
\label{\detokenize{content/03_Robot_Lab/Section_00_05:Optional-Activity}}
Copy the code used to define the \sphinxcode{\sphinxupquote{draw\_square() function, and modify it so that it takes a second "turn" parameter that replaces the}}TURN\_ROTATIONS\textasciigrave{} value.

Use the \sphinxcode{\sphinxupquote{turn}} parameter to tune how far the robot turns at each corner.

Then see if you can use a \sphinxcode{\sphinxupquote{for..in range(N)}} loop to call the square drawing function several times.

Can you further modify the program so that the side length is increased each time the function is called by the loop?

Share your programmes in the module forum.


\subsubsection{5.3 Functions: a summary}
\label{\detokenize{content/03_Robot_Lab/Section_00_05:5.3-Functions:-a-summary}}
You have seen that a RobotLab \sphinxstyleemphasis{macro} is a named sequence of commands that can be ‘called’ or invoked from anywhere in the main program or from another macro. Macros offer four advantages:
\begin{itemize}
\item {} 
they allow a piece of program functionality to be ‘encapsulated’ in a clear and detached way

\item {} 
they allow the functionality to be used many times from anywhere in the program

\item {} 
they simplify the program, making it easier to understand

\item {} 
they make programs less prone to error.

\end{itemize}

Other programming languages have similar features to macros that offer additional benefits. Depending on the language, these may be known as \sphinxstyleemphasis{functions}, \sphinxstyleemphasis{methods}, \sphinxstyleemphasis{procedures} or \sphinxstyleemphasis{subroutines}.

This is the end of Robot Lab Session 4.


\section{Session 04 — RoboLab}
\label{\detokenize{index:session-04-robolab}}

\subsection{1 Introduction}
\label{\detokenize{content/04_Robot_Lab/Section_00_01:1-Introduction}}\label{\detokenize{content/04_Robot_Lab/Section_00_01::doc}}
In this RoboLab Session you will explore a range of simulator environments and sensor and motor drive noise settings, as well as modifying the robot configuration by changing the height of the simulated light sensor.

Through your experiments, you will investigate the way the sensors behave and how this information can be used to control the robot.


\subsubsection{1.1 Activity: The Simulator Environment as a Laboratory}
\label{\detokenize{content/04_Robot_Lab/Section_00_01:1.1-Activity:-The-Simulator-Environment-as-a-Laboratory}}
Let’s just recap on how we might be able to use the simulator as an experimental laboratory.

When the robot simulator widget is displayed, a blank background image is displayed by default. You can configure the simulator to use different background images by selecting the desired background from the dropdown list in the simulator.

Background images can also be loaded from a file. If you create your own background images they should be PNG or JPG images 2362 pixels wide and 1143 pixels high. Python code for generating some of the background images using the Python PIL package can be found in the notebook \sphinxcode{\sphinxupquote{\textasciigrave{}backgrounds/Background Image Generator.ipynb}} \textless{}../backgrounds/Background\%20Image\%20Generator.ipynb\textgreater{}\textasciigrave{}\_\_.

Loading in a background from the default list may also determine the starting location and orientation of the simulated robot, and even the configuration of the robot and and obstacles present in the world.

At the current time, robot configuration updates \sphinxstyleemphasis{cannot} be associated automatically with uploaded simulator backgrounds. However, it is possible to update both the robot and obstacle configuations via pop\sphinxhyphen{}up dialogues that can be opened using the simulator \sphinxstyleemphasis{Configure Robot} and \sphinxstyleemphasis{Obstacles…} buttons.

More generally, the RoboLab simulator provides controls for:
\begin{itemize}
\item {} 
load background

\item {} 
configure robot

\item {} 
configure obstacles

\item {} 
pen up / pen down

\item {} 
clear trace (that is, clear pen trace)

\item {} 
show chart
\begin{itemize}
\item {} 
select trace(s) (ultrasonic, color, Light\_left, Light\_right, gyro))

\end{itemize}

\item {} 
clear chart

\item {} 
set light sensor noise value {[}TO DO: at the moment this is one slider for all sensors, rather than a per input basis;{]}

\item {} 
set motor/wheel noise value {[}TO DO: at the moment this is one slider for all motors, rather than one per output;{]}

\item {} 
set the \(X\), \(Y\) co\sphinxhyphen{}ordinates and the \(Angle\) / orientation of robot; reset reset the robot position to this calues via the \sphinxstyleemphasis{Move} button; the \(X\) and \(Y\) values are updated when the robot is dragged across the canvas; the \sphinxstyleemphasis{Reset} button resets the robot’s location and orientation to the default for that background (if set).

\end{itemize}

\sphinxstyleemphasis{TO DO: need some way of adding keyboard shortcuts to simulator items.}

\sphinxstyleemphasis{TO DO: slow down the frame rate; show clock / counter; zoom in / out on canvas or stop robot going off the edge of the world; show robot motor status and sensor values; show robot current location; support measuring on canvas (I think that may still be there from original ev3devsim).}

\sphinxstyleemphasis{TO DO: should we provide a simple drawing tool on the canvas so students can modify a blank canvas, and perhaps save it? eg http://www.williammalone.com/articles/create\sphinxhyphen{}html5\sphinxhyphen{}canvas\sphinxhyphen{}javascript\sphinxhyphen{}drawing\sphinxhyphen{}app/}


\subsection{2 Line followers}
\label{\detokenize{content/04_Robot_Lab/Section_00_02:2-Line-followers}}\label{\detokenize{content/04_Robot_Lab/Section_00_02::doc}}
In this section you will investigate how a robot can be made to follow a desired path as it navigates its environment.

When humans navigate around a house or a supermarket, most use the information provided by their eyes to control their movements. Many simple robots do not have complex vision systems like this and have to rely on much simpler sensors. One of the most commonly used methods for navigation by robots with simple light sensors is to follow a line.

The idea behind \sphinxstyleemphasis{line following} is that the environment has been adapted by the creation of a marked path that the robot can follow. For example, it could be a black line on a white background, or a wire embedded in the floor creating a magnetic field.

You will experiment with a number of robot navigation systems using the following strategy. In the first instance, instead of trying to follow a black line on a white background, we will instead follow the \sphinxstyleemphasis{edge} of a line that represents the sharp transition between black and white (or dark and light).

The basic idea is that, as the robot moves forwards, the light sensor tells it if it should move towards the edge or away from it. For example, if the light sensor picks up a light background, the robot needs to turn (say to the right) until it detects the dark line. Once the light sensor detects it is over the dark line, the robot should start moving forwards whislt also turning back to the left to find the edge of the line again. In this way, the robot would “edge” forwards as it follows the
\sphinxstyleemphasis{right hand} edge of the black line.

The behaviour of the sensors and the interpretation of the data they provide is very important when creating line\sphinxhyphen{}following robots and we will look at these aspects in some detail.


\subsubsection{2.1 Challenge: Writing an edge\sphinxhyphen{}follower program}
\label{\detokenize{content/04_Robot_Lab/Section_00_02:2.1-Challenge:-Writing-an-edge-follower-program}}
The challenge is to write a RoboLab program to make the robot follow the line until it reaches the red bar. Make sure you still have the \sphinxstyleemphasis{Lollipop} background loaded in to the simulator. Before you can do the programming you will need to collect some data to calibrate the sensor responses to the various colours.

One approach to keeping the robot on track is to get it to read the light sensor. If the light sensor shows grey, the robot needs to turn back towards the edge of the line, that is, turn to its right. If it shows black then the robot is already over the black line and needs to turn back to the left to find the edge again.

(TO DO \sphinxhyphen{} FIX \sphinxhyphen{} The following image is rotated 90 degrees counter\sphinxhyphen{}clockwise compared to the bacground in the simulator.)

The challenge is complicated by the presence of a yellow line, which the robot must ignore.

\#\#\# Calibrating the Required Sensor Readings

You first need to record the light sensor readings associated with each of the coloured bands on the chart, as well as for the black line and the grey background.

The backgound colours are represented as 3\sphinxhyphen{}tuple RGB (red\sphinxhyphen{}green\sphinxhyphen{}blue values). Each component is in the range 0..255 with a higher value showing an increased intensity of that component. A pure red color is


\paragraph{Activity}
\label{\detokenize{content/04_Robot_Lab/Section_00_02:Activity}}
explore colors

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from PIL import Image, ImageDraw
Image.new(\PYGZsq{}RGB\PYGZsq{}, (50, 50), (0,255,0))
\end{sphinxVerbatim}
}


\paragraph{Taking readings}
\label{\detokenize{content/04_Robot_Lab/Section_00_02:Taking-readings}}
The \sphinxcode{\sphinxupquote{reflected light}} reading in the simulator is actually recorded as the value of the first RGB component.

{[}TO DO \sphinxhyphen{} would the max value across all three channels make more sense? Or the median? Or the mean?{]}

Drag the robot around the screen, dropping it so the left light sensor is directly over the area you want to record the sensor reading for. When you drop the robot, the light sensor reading should be updated in the simulator “Sensor readings” area.

light sensorWhen the blue light sensor on Simon’s ‘nose’ is placed over an object, the control panel shows the light sensor reading for that object. Colours are made up of different amounts of red, blue and green. The simulator adds the red, green and blue values, and takes an average (i.e. it divides the total by three). For example, ‘yellow’ has red = 100\%, green = 100\%, and blue = 0\%, so Simon sees this colour as 200/3 = 66 as a whole number (the simulator ‘rounds down’). Drag Simon over the
background image and fill in a table like Table 2.1.





Table 2.1 Light sensor readings









grey:





\_\_\_\_\_\_ \%









yellow:





\_\_\_\_\_\_ \%









red:





\_\_\_\_\_\_ \%









black:





\_\_\_\_\_\_ \%









Spend five to ten minutes writing a program to get Simon to navigate from its starting position along the black line and to stop at the red bar. Good luck!

Open \sphinxcode{\sphinxupquote{Line\_follower}} to see my version of the program code.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}
\end{sphinxVerbatim}
}


\subsection{4 The design engineer as detective}
\label{\detokenize{content/04_Robot_Lab/Section_00_04:4-The-design-engineer-as-detective}}\label{\detokenize{content/04_Robot_Lab/Section_00_04::doc}}
If you have never before experienced a disappointment when building systems, welcome to the world of engineering design!

Design is characterised by defining \sphinxstyleemphasis{requirements}, translating these into a \sphinxstyleemphasis{specification}, generating a possible solution to the specified problem and \sphinxstyleemphasis{evaluating} the outcome. If the “solution” is not satisfactory, it is necessary to go back and try to formulate another possible solution. This is called the \sphinxstyleemphasis{design cycle} .

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} TO DO \PYGZhy{} this will be provided by installed / importable package
\PYGZsh{} Maybe also some magic

fcode=\PYGZsq{}\PYGZsq{}\PYGZsq{}
st=\PYGZgt{}start: Start
e=\PYGZgt{}end: End
op1=\PYGZgt{}operation: Generate
op2=\PYGZgt{}parallel: Evaluate
st(right)\PYGZhy{}\PYGZgt{}op1(right)\PYGZhy{}\PYGZgt{}op2
op2(path1, top)\PYGZhy{}\PYGZgt{}op1
op2(path2, right)\PYGZhy{}\PYGZgt{}e
\PYGZsq{}\PYGZsq{}\PYGZsq{}

\PYGZsh{}Original alt text.
\PYGZsh{} Could we generate something like this from the flow chart specification?
alt\PYGZus{}txt = \PYGZdq{}\PYGZdq{}\PYGZdq{}
A diagram of the design cycle, drawn as a simple flow chart.
This starts in an oval labelled ‘Start’ and finishes in another oval labelled ‘End’.
From ‘Start’ an arrow leads to a box labelled ‘Generate’;
from here an arrow leads to a box ‘Evaluate’.
From ‘Evaluate’ there are two arrows:
one leads directly to the ‘End’, the other loops back to ‘Generate’.
Thus there are two paths in the diagram,
one straight from Start to Generate to Evaluate to End,
the other that forms a loop around Generate and Evaluate.\PYGZdq{}\PYGZdq{}\PYGZdq{}

import jp\PYGZus{}proxy\PYGZus{}widget
import uuid
class FlowchartWidget(jp\PYGZus{}proxy\PYGZus{}widget.JSProxyWidget):
    def \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}(self, *pargs, **kwargs):
        super(FlowchartWidget, self).\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}(*pargs, **kwargs)
        e = self.element

        e.empty()
        self.load\PYGZus{}js\PYGZus{}files([\PYGZdq{}https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js\PYGZdq{},
                            \PYGZsq{}https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.13.0/flowchart.js\PYGZsq{}])

    def charter(self, chart, embed=False):
        uid = uuid.uuid4()
        self.element.html(f\PYGZsq{}\PYGZlt{}div id=\PYGZdq{}\PYGZob{}uid\PYGZcb{}\PYGZdq{}\PYGZgt{}\PYGZlt{}/div\PYGZgt{}\PYGZsq{})
        self.set\PYGZus{}element(\PYGZdq{}chartdef\PYGZdq{}, chart)
        self.js\PYGZus{}init(f\PYGZdq{}chart = flowchart.parse(element.chartdef); chart.drawSVG(\PYGZsq{}\PYGZob{}uid\PYGZcb{}\PYGZsq{});\PYGZdq{})
        if embed:
            return self

testEmbed = FlowchartWidget()
testEmbed.charter(fcode)
testEmbed

\end{sphinxVerbatim}
}

During the design cycle, candidate soluions are generated and evaluated. If the design fails to meet expectations, then a new up or updated design must be generated. If the evaluation of the design is satisfactory, then the design can be accepted and the process may end.

In a continuous improvement design cycle, the the design may be used but it may also be reconsidered. If an improvement is found the new design may be both adopted and passed back round the cycle for further reconsideration.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import sys
sys.path.insert(0,\PYGZsq{}..\PYGZsq{})
import \PYGZus{}load\PYGZus{}nbev3devwidget\PYGZus{}requirements
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}from \PYGZus{}load\PYGZus{}nbev3devwidget import roboSim, eds

\PYGZpc{}load\PYGZus{}ext nbev3devsim
\PYGZpc{}load\PYGZus{}ext nbtutor
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{o}{\PYGZpc{}}\PYG{o}{\PYGZpc{}}\PYG{n+nx}{javascript}
\PYG{c+c1}{//This allows us to resize this view}
\PYG{c+c1}{//Click on the right hand edge to drag}
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{}notebook\PYGZhy{}container\PYGZdq{}} \PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{resizable}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n+nx}{ghost}\PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\sphinxstyleemphasis{Note that things have moved on in the simulator. We can now specify a background and robot configuration as parameters to the magic ( TO DO \sphinxhyphen{} NOT YET AVAILABLE IN ALL MAGICS).}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded \PYGZhy{}\PYGZhy{}background Lollipop \PYGZhy{}r Small\PYGZus{}Robot
import ev3dev2\PYGZus{}glue as glue

colorLeft = ColorSensor(INPUT\PYGZus{}2)
colorRight = ColorSensor(INPUT\PYGZus{}3)
print(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity)
while (colorLeft.reflected\PYGZus{}light\PYGZus{}intensity \PYGZlt{} 30 or colorLeft.reflected\PYGZus{}light\PYGZus{}intensity \PYGZgt{} 35):

    intensity\PYGZus{}left = colorLeft.reflected\PYGZus{}light\PYGZus{}intensity
    \PYGZsh{}intensity\PYGZus{}right = colorRight.reflected\PYGZus{}light\PYGZus{}intensity

    print(intensity\PYGZus{}left)

    print(\PYGZsq{}gs\PYGZsq{},glue.pyState())
    if intensity\PYGZus{}left \PYGZlt{} 50:
        left\PYGZus{}motor\PYGZus{}speed = SpeedPercent(0)
        right\PYGZus{}motor\PYGZus{}speed = SpeedPercent(20)
    else:
        left\PYGZus{}motor\PYGZus{}speed = SpeedPercent(20)
        right\PYGZus{}motor\PYGZus{}speed = SpeedPercent(0)
    tank\PYGZus{}drive.on(left\PYGZus{}motor\PYGZus{}speed, right\PYGZus{}motor\PYGZus{}speed)

\end{sphinxVerbatim}
}


\subsubsection{Following the Design Cycle}
\label{\detokenize{content/04_Robot_Lab/Section_00_04:Following-the-Design-Cycle}}
In the current example, the system was specified according to the requirement that the robot would go all the way round the track and stop at the red bar. I generated a solution based on my ‘model’ of the system. When I ran it, my evaluation was that the system did not work! (Even if it had worked first time, it’s possible that the solution was not very good either in terms of the way the robot behaved, or in terms of how the programme was written.)

Under these circumstances, the design engineer looks for reasons why things went wrong, using all the available information. Sometimes this involves devising experiments. It’s rather like being a detective, trying to piece together the solution.

One of the main assumptions underlying my first program was that the colours could be separated by thresholds. I decided to test this assumption to try to find out what Simon really ‘sees’.

The following program drives the robot forward a short way, far enough from it to cross the black line. Download and run the programme so that

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZpc{}\PYGZpc{}sim\PYGZus{}magic\PYGZus{}preloaded
import time
tank\PYGZus{}drive.on(SpeedPercent(20), SpeedPercent(20))

for i in range(60):

    print(\PYGZsq{}Colour: \PYGZsq{} + str(colorLeft.reflected\PYGZus{}light\PYGZus{}intensity ))
    time.sleep(0.02)
\end{sphinxVerbatim}
}

Grab the data from the datalog:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYGZsh{} Get the data
\PYGZsh{}eds.sim\PYGZus{}get\PYGZus{}data(roboSim)
data = roboSim.results\PYGZus{}log
df = eds.get\PYGZus{}dataframe\PYGZus{}from\PYGZus{}datalog(data)
\PYGZsh{} TO DO \PYGZhy{} should we simplify this so if no data is passed we pull it from self?

df.head()
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}df[\PYGZsq{}time\PYGZsq{}] = df[\PYGZsq{}index\PYGZsq{}].dt.total\PYGZus{}seconds()
\end{sphinxVerbatim}
}

Now lets plot each of those data points:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import matplotlib.pyplot as plt
import seaborn as sns

g = sns.FacetGrid(df, row=\PYGZdq{}variable\PYGZdq{},
                  height=5, aspect=2, sharey=False)
g = g.map(plt.plot, \PYGZdq{}time\PYGZdq{}, \PYGZdq{}value\PYGZdq{}, marker=\PYGZdq{}.\PYGZdq{});

\PYGZsh{} This is rather obscure and relates to the structure
\PYGZsh{} of the chart object.
ax1= g.axes[0][0]
ax1.axhline(y=10, ls=\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
\end{sphinxVerbatim}
}

The \sphinxcode{\sphinxupquote{cufflinks}} packages adds support for plotting charts using the \sphinxcode{\sphinxupquote{plotly}} package directly from \sphinxstyleemphasis{pandas} datadrames.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}import cufflinks as cf
cf.go\PYGZus{}offline()
\end{sphinxVerbatim}
}

We can now create a plotly chart using \sphinxstyleemphasis{markers} to identify each sensor reading sample point as well as a \sphinxstyleemphasis{line} that connects them. A horizontal band, identified by the \sphinxcode{\sphinxupquote{hband={[}(MIN\_Y, MAX\_Y){]}}} parameter adds a horizontal band to the chart corresponding to the thresholded range I was using to identify whether the robot had encountered the red line:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}df.iplot( x = \PYGZsq{}time\PYGZsq{}, y = \PYGZsq{}value\PYGZsq{},
         mode=\PYGZsq{}markers+lines\PYGZsq{}, hspan=[(30,35)])
\end{sphinxVerbatim}
}

Here’s a screenshot of the trace of light readings I got as the simulated robot went from the grey background, over the black line and back to the grey background:

\noindent\sphinxincludegraphics[width=700\sphinxpxdimen,height=450\sphinxpxdimen]{{plotly_sensor_false_positive}.png}

\sphinxstylestrong{TO DO: should long desc text only be for partially sighted students, or does it actually make things easier for all students? Here’s an example of using a long desc style description in the main body of the teaching material.}

The vertical scale shows sensor values on a vertical y\sphinxhyphen{}axis scale ranging 0\sphinxhyphen{}85 or so (the actual readings in principle range form 0..100 per cent). The horizontal scale is a time base showing a time of 0 to 2 seconds, with a plot every 0.02s (that is, about every fiftieth of a second. The sensor readings are also joined to form a line. The line starts with high values, starting at a y value of just over 80. There is then an abrupt fall in the values until they reach a low point of 0 for 3
samples, followed by a return to the high values around 80. On the diagram, I have marked a horizontal band highlighting values between

This chart helps to explain why my original program did not work as intended. On the right of the black line, in the transition from black to grey, the simulated robot has recorded a value of about 34, within the thresholded band value I was using to identify the red line.

The sensor value is calculated as some function of the value of several pixels in view of the sensor at any one time and it just so happens that the calculation may return a reading I had associated with the red line.

In fact, the \sphinxcode{\sphinxupquote{.reflected\_light()}} mode is \sphinxstyleemphasis{not} a good indicator of colour at all. What happens if you run the robot over the \sphinxstyleemphasis{Coloured\_bands} background, for example, logging the reflected light sensor data as you so so? (Either chart the data in the simulator to review it, or grab the datalog into the notebook and view it here at you leisure.)

\noindent\sphinxincludegraphics{{content/04_Robot_Lab/../images/tm129_rob_p6_f014}.jpg}

A diagram which shows the graph previously described, below which a diagram shows the black line (actually shown as dark grey) highly enlarged. A series of circles is also shown starting on the pale grey background and continuing across the black line and then back on to the grey. These represent the position of the sensor each time a reading is taken, and an arrow leads from each circle indicating a sensor reading to the corresponding point plotted on the graph. Most of these circles are wholly
on either the grey or the black line and produce a correspondingly high (80\sphinxhyphen{}95) or a low (20\sphinxhyphen{}30) reading. However, one circle straddles the edge of the line, so half of the interior is black and the other half grey. This produces an intermediate sensor value of 50.

This is a tough lesson. What ought to be easily classified as either a black or white sensor reading is ambiguously somewhere in the middle. The value of 50\% is exactly in the range that the program interprets as red. The assumption underlying the program that a sensor reading of 50\% indicates red is clearly incorrect, and another approach is required.

We note that if a sampled data point falls between the values I used for my threshold settings that were intended to identify the red line, then the robot would have a “false positive” match and stop before it was supposed to.



\renewcommand{\indexname}{Index}
\printindex
\end{document}