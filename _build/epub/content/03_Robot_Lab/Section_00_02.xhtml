<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2 Dead reckoning</title>
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container,
div.nbinput.container div.prompt,
div.nbinput.container div.input_area,
div.nbinput.container div[class*=highlight],
div.nbinput.container div[class*=highlight] pre,
div.nboutput.container,
div.nboutput.container div.prompt,
div.nboutput.container div.output_area,
div.nboutput.container div[class*=highlight],
div.nboutput.container div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    background: #f5f5f5;
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span># Run this cell to set up the robot simulator environment

#Load the nbtutor extension
%load_ext nbtutor

#Reset the notebook style
from IPython.core.display import display, HTML

display(HTML(&quot;&lt;style&gt;#notebook-container { width:50% !important; float:left !important;}&lt;/style&gt;&quot;))


#Launch the simulator
from nbev3devsim import ev3devsim_nb as eds
%load_ext nbev3devsim

roboSim = eds.Ev3DevWidget()
display(roboSim)
roboSim.element.dialog();
</pre></div>
</div>
</div>
<div class="section" id="2-Dead-reckoning">
<h1>2 Dead reckoning</h1>
<p><em>Dead reckoning</em> is a means of navigation that does not rely on external observations. Instead, a robot’s position is estimated by summing its incremental movements relative to a known starting point.</p>
<p>Estimates of the distance traversed are usually obtained from measuring how many times the wheels have turned, and how many times they have turned in relation to each other. For example, the wheels of the robot could be attached to an odometer, similar to the device that records the mileage of a car.</p>
<p>In RoboLab we will calculate the position of a robot from how long it moves in a straight line or rotates about its centre. We will assume that the length of time for which the motors are switched on is directly related to the distance travelled by the wheels.</p>
<div class="section" id="2.1-Activity:-Dead-reckoning">
<h2>2.1 Activity: Dead reckoning</h2>
<p>An environment for the simulated robot to navigate is shown below, based on the 2018 First Lego League “Into Orbit” challenge.</p>
<p>The idea is that the robot must get to the target satellite from its original starting point by avoiding the obstacles in its direct path.</p>
<p><img alt="Space scene showing the robot, some satellites against a “space” bacground, and some wall like obstacles between the robot starting point and a target satellite" src="../../_images/Section_00_02_-_Jupyter_Notebook.png" /></p>
<p>The following programme should drive the robot from its starting point, to the target, whilst avoiding the obstacles. We define the obstacle as being avoided if it is not crossed by the robot’s <em>pen down</em> trail.</p>
<p>Load the <em>FLL 2018 - Into Orbit</em> background into the simulator. Run the code cell to download the program to the simulator and then, with the <em>Pen Down</em> checkbox enabled, run the programme in the simulator.</p>
<p><em>Remember that you can reset the original location and orientation of the robot by clicking the simularo ``Reset`` button. You can clear the pen trace by clicking the simulator ``Clear Trace`` button.</em></p>
<p>Does the robot reach the target satellite without encountering any obstacles?</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>%%sim_magic_preloaded

import playsound

# Turn on the spot to the right
tank_turn.on_for_rotations(100, SpeedPercent(75), 0.8 )

# Go forwards
tank_drive.on_for_rotations(SpeedPercent(30), SpeedPercent(30), 4)

# Slight graceful turn to right
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(30), 2.5)

# Turn on the spot to the left
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.8 )

# Forwards a bit
tank_drive.on_for_rotations(SpeedPercent(30), SpeedPercent(30), 0.8)

#Turn on the spot a bit more to the left
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.6 )

# Go forwards a bit more and dock on the satellite
tank_drive.on_for_rotations(SpeedPercent(30), SpeedPercent(30), 1.5)

playsound.say(&quot;Hopefully I have docked with the satellite...&quot;)
</pre></div>
</div>
</div>
<p>To set the speeds and times, I used a bit of trial and error.</p>
<p>If the route had been much more complex, I would have been tempted to comment out the steps up I had already run an add new steps that would be applied from wherever the robot was currently located.</p>
<p>Note that the robot could have taken other routes to get to the satellite - I just thought I should avoid the asteroid!</p>
</div>
<div class="section" id="2.2-Challenge:-Reaching-the-moon-base">
<h2>2.2 Challenge: Reaching the moon base</h2>
<p>In the following code cell, write a program to move the simulated robot from its location servicing the satellite to the moon base identified as the circlular area marked on the moon in the top right hand corner of the simulated world.</p>
<p>In the simulator, set the robot’s X location to <code class="docutils literal notranslate"><span class="pre">1250</span></code> and Y location <code class="docutils literal notranslate"><span class="pre">450</span></code> and use the <em>Move</em> button to loate the robot there.</p>
<p>Use the following code cell to write your own dead reckoning programme to drive the robot to the moon base at location <code class="docutils literal notranslate"><span class="pre">(2150,</span> <span class="pre">950)</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>%%sim_magic_preloaded

# YOUR CODE HERE

</pre></div>
</div>
</div>
</div>
<div class="section" id="2.3-Activity:-Dead-reckoning-with-noise">
<h2>2.3 Activity: Dead reckoning with noise</h2>
<p>The robot traverses its path using timing information for dead reckoning. In principle, if the simulated robot had a map, it could calculate all the distances and directions for itself, convert these to times, and dead reckon its way to the target. However, there is a problem with dead reckoning: <em>noise</em>.</p>
<p>In many physical systems, a perfect intended behaviour is subject to <em>noise</em>, random perturbations that arise within the system as time goes on as a side-effect of its operation. In a robot, noise might arise in the behaviour of the motors, the transmission or the wheels. The result is that the robot does not execute its motion without error. We can model noise effects in the mobility system of out robot by adding a small amount of noise to the motor speeds as the simulator runs. This noise
componenent may speed up, or slow down, the speed of each motor, in a random way. As with real systems, the noise represents are slight random deviations from the theoretical, ideal behaviour.</p>
<p>Run the following code cell to download the programme to the simulator. Select an empty background (select the <em>Empty Map</em>) and tick the <em>Pen Down</em> checkbox. Also reset the initial location of the robot to an X value of <code class="docutils literal notranslate"><span class="pre">50</span></code> and Y value of <code class="docutils literal notranslate"><span class="pre">400</span></code>; use the simulator <em>Move</em> button to move the robot to that location.</p>
<p>Run the program in the simulator and observe what happens.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>%%sim_magic_preloaded

tank_drive.on_for_rotations(SpeedPercent(30), SpeedPercent(30), 3)
</pre></div>
</div>
</div>
<p>When you run the programme, you should see the robot drive forwards a short way in a straight line, leaving a staight line trail behind it.</p>
<p>Reset the location of the robot by clicking the simulator <em>Move</em> button. Also within the simulator, increase the <em>Wheel noise</em> value from zero by dragging the slider to the right a little way.</p>
<p>Run the programme in the simulator again.</p>
<p>You should notice this time that the robot does not travel in a straight line. Instead, it drifts from side to slide although possible to one side of the line.</p>
<p>Move the robot back to the start poistion (click the <em>Move</em> button) and run the programme in the simulator again. This time, you should see it follows yet another different path.</p>
<p>Depending on how severe the noise setting is, the robot will travel closer (low noise) the original straight libe, or follow an ever more erratic path (high noise).</p>
<p>Now run the original satellite finding dead reckoning programme again, using the <em>FLL 2018 - Into Orbit</em> background, but in the presence of <em>Wheel noise</em>. Does it:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>%%sim_magic_preloaded

import playsound

# Turn on the spot to the right
tank_turn.on_for_rotations(100, SpeedPercent(75), 0.8 )

# Go forwards
tank_drive.on_for_rotations(SpeedPercent(30), SpeedPercent(30), 4)

# Slight graceful turn to right
tank_drive.on_for_rotations(SpeedPercent(50), SpeedPercent(30), 2.5)

# Turn on the spot to the left
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.8 )

# Forwards a bit
tank_drive.on_for_rotations(SpeedPercent(30), SpeedPercent(30), 0.8)

#Turn on the spot a bit more to the left
tank_turn.on_for_rotations(-100, SpeedPercent(75), 0.6 )

# Go forwards a bit more and dock on the satellite
tank_drive.on_for_rotations(SpeedPercent(30), SpeedPercent(30), 1.5)

playsound.say(&quot;Hopefully I have docked with the satellite...&quot;)
</pre></div>
</div>
</div>
</div>
<div class="section" id="Summary">
<h2>Summary</h2>
<p>In this notebook you have seen how we can use dead reckoning to move the robot along a specified path. However, in the presence of noise, this is very unreliable: whilst the robot may think it is following one path, it may in fact be following another. And whilst in some cases it may reach the target safely, in others it may end somewhere completely different, or encounter an obstacle along the way.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>